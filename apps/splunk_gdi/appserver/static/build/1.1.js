webpackJsonp([1],{"views/shared/jschart/Master":function(e,n,t){var i,r;i=[t("shim/jquery"),t("require/underscore"),e,t("models/config"),t("views/shared/viz/Base"),t("util/jscharting_utils"),t("util/general_utils"),t("shim/splunk.util"),t("shim/splunk.legend"),t("uri/route"),t(572)],r=function(e,n,t,i,r,a,o,s,l,h,d){n("Invalid timestamp").t(),n("Reset").t(),n("Reset Zoom").t(),n("Pan Right").t(),n("Pan Left").t(),n("No Results").t(),n("Invalid Data").t(),n("Numeric Data Required").t(),n("Invalid data: second column must be numeric for a pie chart").t(),a.prepareChartingLibrary(d);var c=r.extend({VIZ_PROPERTY_PREFIX_REGEX:/^display\.visualizations\.charting\./,className:"chart",moduleId:t.id,initialize:function(t){r.prototype.initialize.apply(this,arguments),this.options=t||{},this._selectedRange=null,this.$el.width(this.options.width||"100%"),this.$el.height(this.options.height||"100%"),this.$chart=e("<div></div>"),this.$inlineMessage=e("<div></div>").css("text-align","center").addClass(this.options.messageContainerClass||""),this.computeDisplayProperties(),this.listenTo(this.getPrimaryDataSource(),"destroy",this.empty),this.onExternalPaletteChange=n(this.onExternalPaletteChange).bind(this),this.legendId=(this.options.parentCid||"")+this.cid,l.register(this.legendId),l.addEventListener("labelIndexMapChanged",this.onExternalPaletteChange)},empty:function(){return this.destroyChart(),this.$chart.empty(),this.$inlineMessage.empty(),this},remove:function(){return this.removed=!0,this.destroyChart(),l.unregister(this.legendId),l.removeEventListener("labelIndexMapChanged",this.onExternalPaletteChange),r.prototype.remove.apply(this,arguments)},render:function(){return this.$chart.appendTo(this.el),this.$inlineMessage.appendTo(this.el),r.prototype.render.apply(this,arguments)},onConfigChange:function(e){var t=n(e).chain().keys().any(function(e){return 0===e.indexOf("display.visualizations.charting.")}).value();if(t){this.computeDisplayProperties();var i=["display.visualizations.charting.chart","display.visualizations.charting.chart.resultTruncationLimit","display.visualizations.charting.resultTruncationLimit","display.visualizations.charting.axisY2.enabled","display.visualizations.charting.chart.overlayFields","display.visualizations.charting.chart.stackMode"],r=n(e).any(function(e,t){return n(i).contains(t)});r?this.invalidate("formatDataPass"):this.invalidate("updateViewPass")}},combineData:function(e){return n.extend({},e.primary,{annotation:e.annotation})},formatData:function(e){if(!e||!e.columns||0===e.columns.length)return d.extractChartReadyData({fields:[],columns:[]});var n=a.preprocessChartData(e,this.displayProperties);n.columns.length>0&&(n.columns.length<e.columns.length||n.columns[0].length<e.columns[0].length)&&(n.areTruncated=!0),e.annotation&&(n.annotations=this.formatAnnotationData(e.annotation));var t=d.extractChartReadyData(n);n.areTruncated&&(t.resultsAreTruncated=!0);try{window.__splunk__prepareChartCfgDownload&&window.__splunk__prepareChartCfgDownload(this.cid,JSON.stringify({data:e,props:this.displayProperties},null,2))}catch(i){}return t},formatAnnotationData:function(e){var t=[];if(e&&e.columns&&e.columns.length>0){var i=d.extractChartReadyData(e);if(i.hasField("_time")){var r=i.getSeriesAsTimestamps("_time"),a=i.getSeries("annotation_label"),o=i.getSeries("annotation_color"),s=i.getSeries("annotation_category");n.each(r,function(e,n){t.push({time:e,label:a[n],color:o[n],category:s[n]})},this)}}return t},provideScaleValues:function(e,t){if(e.seriesList&&e.seriesList.length>1){var i=e.getFieldData(),r=i.yFields;if(s.normalizeBoolean(t["display.visualizations.charting.axisY2.enabled"])){var a=s.stringToFieldList(t["display.visualizations.charting.chart.overlayFields"]),o=[];n.each(a,function(t){var i=n.indexOf(e.fields,t);i>-1&&(o=o.concat(e.seriesList[i]))}),r=n.difference(i.yFields,a)}var l=[],h=[];if(n.each(r,function(t){var i=n.indexOf(e.fields,t);i>-1&&(l=l.concat(e.seriesList[i]),h.push(n.max(e.getSeriesAsFloats(t))))}),"stacked"===t["display.visualizations.charting.chart.stackMode"]){var d=n.reduce(h,function(e,n){return e+n},0);l.push(d)}var c=[];return n.each(i.xFields,function(t){var i=n.indexOf(e.fields,t);i>-1&&(c=c.concat(e.seriesList[i]))}),{xAxis:c,yAxis:l,overlayAxis:o}}},updateView:function(t,r,o){var s=o();if(!n.isUndefined(t.seriesList)){this.$inlineMessage.empty();var h=this.getPrimaryDataSource().getFetchParams().count;if(t.resultsAreTruncated?this.renderResultsTruncatedMessage():t.seriesList.length>0&&h>0&&t.seriesList[0].length>=h&&this.renderMaxResultCountMessage(h),!n.isUndefined(this.getScale("xAxis")))var c={xCategories:this.getScale("xAxis").get("actualCategories")};if(!n.isUndefined(this.getScale("yAxis"))){var p=this.getScale("yAxis").get("actualMinimum"),u=this.getScale("yAxis").get("actualMaximum");if(p<u)var f={yAxisMin:p,yAxisMax:u}}if(!n.isUndefined(this.getScale("overlayAxis"))){var m=this.getScale("overlayAxis").get("actualMinimum"),g=this.getScale("overlayAxis").get("actualMaximum");if(m<g)var x={overlayAxisMin:m,overlayAxisMax:g}}var b=e.extend({},this.displayProperties,a.getCustomDisplayProperties(t,i.toJSON()),c,f,x);this.chart&&n.isEqual(b,this.chart.getCurrentDisplayProperties())?this.chart.off():(this.destroyChart(),this.chart=d.createChart(this.$chart[0],b)),this.updateChartContainerHeight();var y=this;this.chart.prepare(t,{});var v=this.chart.getFieldList();this.chart.requiresExternalColorPalette()&&(l.setLabels(this.legendId,v),this.externalPalette=this.getExternalColorPalette(),this.chart.setExternalColorPalette(this.externalPalette.fieldIndexMap,this.externalPalette.numLabels)),this.chart.on("pointClick",function(e){var n=y.normalizeDrilldownEvent(e,"cell");y.trigger("drilldown",n)}),this.chart.on("legendClick",function(e){var n;n=e.hasOwnProperty("name")&&e.hasOwnProperty("value")?y.normalizeDrilldownEvent(e,"row"):y.normalizeDrilldownEvent(e,"column"),y.trigger("drilldown",n)}),this.chart.on("chartRangeSelect",function(e){var t=n(e).pick("startXIndex","endXIndex","startXValue","endXValue");n.isEqual(t,y._selectedRange)||(y._selectedRange=t,y.trigger("chartRangeSelect",e))}),this.chart.draw(function(e){y.model.config.set({currentChartFields:v},{"transient":!0}),s()})}},normalizeDrilldownEvent:function(e,t){return n.extend({type:t,originalEvent:e},n(e).pick("name","value","name2","value2","_span","rowContext","modifierKey"))},getExternalColorPalette:function(){this.synchronizingExternalPalette=!0;var e={};return n(this.chart.getFieldList()).each(function(n){e[n]=l.getLabelIndex(n)}),this.synchronizingExternalPalette=!1,{fieldIndexMap:e,numLabels:l.numLabels()}},onExternalPaletteChange:function(){if(!this.synchronizingExternalPalette){var e=this.externalPalette;this.externalPalette=this.getExternalColorPalette(),this.chart&&this.chart.requiresExternalColorPalette()&&!n.isEqual(e,this.externalPalette)&&this.invalidate("updateViewPass")}},destroyChart:function(){this.chart&&(this.chart.off(),this.chart.destroy(),delete this.chart)},reflow:function(){this.chart&&this.$el.height()>0&&(this.updateChartContainerHeight(),this.chart.resize())},updateChartContainerHeight:function(){var e=this.$inlineMessage.is(":empty")?0:this.$inlineMessage.outerHeight();this.$chart.height(this.$el.height()-e)},renderResultsTruncatedMessage:function(){var e=n("These results may be truncated. Your search generated too much data for the current visualization configuration.").t();e=this.addTruncationDocsLink(e),this.$inlineMessage.html(n(this.inlineMessageTemplate).template({message:e,level:"warning"}))},renderMaxResultCountMessage:function(e){var t=s.sprintf(n("These results may be truncated. This visualization is configured to display a maximum of %s results per series, and that limit has been reached.").t(),e);t=this.addTruncationDocsLink(t),this.$inlineMessage.html(n(this.inlineMessageTemplate).template({message:t,level:"warning"}))},computeDisplayProperties:function(){this.displayProperties={};var e=this.model.config.toJSON();n.each(e,function(e,n){this.VIZ_PROPERTY_PREFIX_REGEX.test(n)&&(this.displayProperties[n.replace(this.VIZ_PROPERTY_PREFIX_REGEX,"")]=e)},this)},addTruncationDocsLink:function(e){var t=h.docHelp(this.model.application.get("root"),this.model.application.get("locale"),"learnmore.charting.datatruncation"),i=' <a href="<%- href %>" target="_blank"><span><%- text %></span><i class="icon-external icon-no-underline"></i></a>';return e+n(i).template({href:t,text:n("Learn More").t()})},inlineMessageTemplate:'\t            <div class="alert alert-inline alert-<%= level %> alert-inline"> \t                <i class="icon-alert"></i> \t                <%= message %> \t            </div> \t        '});return c}.apply(n,i),!(void 0!==r&&(e.exports=r))},572:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=104)}([function(e,n){e.exports=t("shim/jquery")},function(e,n){e.exports=t("require/underscore")},function(e,n){e.exports=t(573)},function(e,n){e.exports=t(574)},function(e,n){e.exports=t(575)},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){d[e]?p=e:(console.warn('Theme "'+e+'" not available - falling back to default'),p="default"),c=d[p]}function a(e){return c[e]?c[e]:void console.log('Theme property "'+e+'" not available in '+p+" theme")}function o(){return p}Object.defineProperty(n,"__esModule",{value:!0});var s=t(105),l=i(s);n.setTheme=r,n.getThemeProperty=a,n.getCurrentTheme=o;var h=t(22),d={"default":(0,l["default"])({},h.COLORS,{LEGEND_OVERFLOW_ARROW_COLOR_ACTIVE:"#003399",LEGEND_OVERFLOW_ARROW_COLOR_INACTIVE:"#cccccc",LEGEND_OVERFLOW_FONT_COLOR:h.COLORS.DEFAULT_FONT_COLOR,TOOLTIP_BACKGROUND_COLOR:"#000000",TOOLTIP_FONT_COLOR:"#ffffff",TOOLTIP_FONT_COLOR_SOFT:"#cccccc",TOOLTIP_BORDER_COLOR:"#ffffff"}),dark:(0,l["default"])({},h.COLORS_DARK_MODE,{LEGEND_OVERFLOW_ARROW_COLOR_ACTIVE:h.COLORS_DARK_MODE.DEFAULT_FONT_COLOR,LEGEND_OVERFLOW_ARROW_COLOR_INACTIVE:h.COLORS_DARK_MODE.DEFAULT_LINE_COLOR_SOFTER,LEGEND_OVERFLOW_FONT_COLOR:h.COLORS_DARK_MODE.DEFAULT_FONT_COLOR,TOOLTIP_BACKGROUND_COLOR:"#ffffff",TOOLTIP_FONT_COLOR:"#171d21",TOOLTIP_FONT_COLOR_SOFT:"#5c6773",TOOLTIP_BORDER_COLOR:"none"})},c=d["default"],p="default"},function(e,n,t){var i=t(70),r="object"==typeof self&&self&&self.Object===Object&&self,a=i||r||Function("return this")();e.exports=a},function(e,n){e.exports=t(576)},function(e,n){e.exports=t(577)},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0});var r=t(0),a=i(r);n["default"]={on:function(e,n){(0,a["default"])(this).on(e,n)},off:function(e,n){(0,a["default"])(this).off(e,n)},trigger:function(e,n){(0,a["default"])(this).trigger(e,n)}},e.exports=n["default"]},function(e,n){e.exports=t(578)},function(e,n,t){var i=t(61)("wks"),r=t(62),a=t(13).Symbol,o="function"==typeof a,s=e.exports=function(e){return i[e]||(i[e]=o&&a[e]||(o?a:r)("Symbol."+e))};s.store=i},function(e,n){e.exports=t(579)},function(e,n){var t=e.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=t)},function(e,n){function t(e){var n=typeof e;return null!=e&&("object"==n||"function"==n)}e.exports=t},function(e,n){function t(e){return null!=e&&"object"==typeof e}e.exports=t},function(e,n){var t=e.exports={version:"2.5.1"};"number"==typeof __e&&(__e=t)},function(e,n,t){var i=t(18),r=t(33);e.exports=t(20)?function(e,n,t){return i.f(e,n,r(1,t))}:function(e,n,t){return e[n]=t,e}},function(e,n,t){var i=t(19),r=t(110),a=t(111),o=Object.defineProperty;n.f=t(20)?Object.defineProperty:function(e,n,t){if(i(e),n=a(n,!0),i(t),r)try{return o(e,n,t)}catch(s){}if("get"in t||"set"in t)throw TypeError("Accessors not supported!");return"value"in t&&(e[n]=t.value),e}},function(e,n,t){var i=t(31);e.exports=function(e){if(!i(e))throw TypeError(e+" is not an object!");return e}},function(e,n,t){e.exports=!t(32)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(e,n){var t={}.hasOwnProperty;e.exports=function(e,n){return t.call(e,n)}},function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.FONT_FAMILY='"Splunk Platform Sans", "Proxima Nova", "Lucinda Grande", Roboto, Droid, "Helvetica Neue", Helvetica, Arial, sans-serif',n.FONT_SIZE="12px",n.COLORS={DEFAULT_BACKGROUND_COLOR:"#ffffff",DEFAULT_FOREGROUND_COLOR:"#000000",DEFAULT_FONT_COLOR:"#3c444d",DEFAULT_LINE_COLOR:"#000000",DEFAULT_LINE_COLOR_SOFT:"#c3cbd4",DEFAULT_LINE_COLOR_SOFTER:"#e1e6eb",SEMANTIC_SUCCESS:"#53a051",SEMANTIC_WARNING:"#f8be34",SEMANTIC_ERROR:"#dc4e41"},n.COLORS_DARK_MODE={DEFAULT_BACKGROUND_COLOR:"#212527",DEFAULT_FOREGROUND_COLOR:"#ffffff",DEFAULT_FONT_COLOR:"#ffffff",DEFAULT_LINE_COLOR:"#000000",DEFAULT_LINE_COLOR_SOFT:"#D9DDE1",DEFAULT_LINE_COLOR_SOFTER:"#324147",SEMANTIC_SUCCESS:"#53a051",SEMANTIC_WARNING:"#f8be34",SEMANTIC_ERROR:"#dc4e41"}},function(e,n){function t(e){return e}e.exports=t},function(e,n,t){function i(e){return null==e?void 0===e?l:s:h&&h in Object(e)?a(e):o(e)}var r=t(69),a=t(132),o=t(133),s="[object Null]",l="[object Undefined]",h=r?r.toStringTag:void 0;e.exports=i},function(e,n,t){function i(e){return function(){var n=arguments;switch(n.length){case 0:return new e;case 1:return new e(n[0]);case 2:return new e(n[0],n[1]);case 3:return new e(n[0],n[1],n[2]);case 4:return new e(n[0],n[1],n[2],n[3]);case 5:return new e(n[0],n[1],n[2],n[3],n[4]);case 6:return new e(n[0],n[1],n[2],n[3],n[4],n[5]);case 7:return new e(n[0],n[1],n[2],n[3],n[4],n[5],n[6])}var t=r(e.prototype),i=e.apply(t,n);return a(i)?i:t}}var r=t(39),a=t(14);e.exports=i},function(e,n){function t(e,n){for(var t=-1,r=e.length,a=0,o=[];++t<r;){var s=e[t];s!==n&&s!==i||(e[t]=i,o[a++]=t)}return o}var i="__lodash_placeholder__";e.exports=t},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,n){C["default"].call(this,e,n)}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(87),c=r(d),p=t(46),u=r(p),f=t(8),m=r(f),g=t(2),x=t(89),b=i(x),y=t(3),v=i(y),w=t(7),k=i(w),S=t(47),T=r(S),O=t(188),M=t(88),P=i(M),A=t(64),L=i(A),_=t(90),C=r(_),H=t(45),I=r(H),D=t(189),E=r(D),R=t(190),z=r(R),N=t(49),W=r(N),j=t(192),F=r(j),B=t(193),G=r(B),Y=t(194),V=r(Y),X=t(198),U=r(X),K=t(201),q=r(K),Z=t(28),$=r(Z),J=t(202),Q=r(J),ee=t(203),ne=r(ee),te=t(22),ie="seriesCompare";(0,g.inherit)(a,C["default"]),s["default"].extend(a.prototype,{HOVER_DELAY:160,EXPORT_WIDTH:600,EXPORT_HEIGHT:400,FALLBACK_HEIGHT:250,FALLBACK_WIDTH:600,PROGRESSIVE_DRAW_THRESHOLD:1e3,ANNOTATION_COLORS:["#E19747","#5F7395","#3E9887","#784772","#A24940"].map(k.hexFromColor),hasLegend:!0,hasTooltip:!0,hasXAxis:!0,hasYAxis:!0,legendMode:"standard",requiresExternalColors:!0,externalPaletteMapping:{},externalPaletteSize:0,prepare:function(e,n){this.benchmark("Prepare Started");var t=this.isEmpty(),i=this.hasTimeXAxis();C["default"].prototype.prepare.call(this,e,n),"all"!==this.showLabels&&"minmax"!==this.showLabels||this.initializeDataLabels(),this.initializeFields(),this.isiOS=!!u["default"].ios;var r=this.isEmpty(),a=this.hasTimeXAxis();r===t&&i===a||(this._isDirty=!0),this.shouldUpdateInPlace()?(this.updateSeriesProperties(),this.updateAxisProperties(),r||this.setAllSeriesData()):(r||this.initializeColorPalette(),this.initializeSeriesList(),this.axesAreInverted="bar"===this.type,this.hasXAxis&&this.initializeXAxisList(),this.hasYAxis&&this.initializeYAxisList(),r?(this.legend&&(this.legend.destroy(),this.legend=null),this.tooltip&&(this.tooltip.destroy(),this.tooltip=null)):(this.hasLegend&&this.initializeLegend(),this.hasTooltip&&this.initializeTooltip(),this.setAllSeriesData(),this.bindSeriesEvents()))},initializeDataLabels:function(){this.dataLabels=new Q["default"]({showLabels:this.showLabels,splitSeries:this.splitSeries})},getFieldList:function(){return(0,h["default"])(this.seriesList).chain().invoke("getFieldList").flatten(!0).compact().value()},setExternalColorPalette:function(e,n){this.externalPaletteMapping=s["default"].extend({},e),this.externalPaletteSize=n},handleDraw:function(e){if(L.debug("drawing a chart with dimensions:",{width:this.width,height:this.height}),L.debug("drawing a chart with properties:",this.properties),L.debug("drawing a chart with data:",this.dataSet.toJSON()),this.benchmark("Draw Started"),this.applyColorPalette(),this.cancelPendingDraw(),this.shouldUpdateInPlace())return void this.redrawInPlace(e);this.hcConfig=this.getConfig(),L.debug("config object to be sent to highcharts:",this.hcConfig),this.hcChart&&(this.destroy(),this.bindSeriesEvents(),this.legend&&this.bindLegendEvents()),this.shouldProgressiveDraw()&&(this.hcConfig.firstRenderOverride=(0,h["default"])(this.firstRenderOverride).bind(this),this.hcConfig.renderOverride=(0,h["default"])(this.renderOverride).bind(this));var n=this;new m["default"].Chart(this.hcConfig,function(t){n.hcChart=t,n.testMode&&(b.initializeTestingMetaData(n,n.xFields,n.getClassName()),b.createGlobalReference(n,t)),n.onChartLoad(t),n.onChartLoadOrRedraw(t),n.hasTooltip&&!n.isEmpty()&&n.enableTooltip(t),n.cacheDrawnDimensions(),n.benchmark("Draw Finished"),e(n,n.benchmarks)})},redrawInPlace:function(e){var n=this;if(L.debug("in place redraw!"),!this.hcChart)throw new Error("Cannot call redrawInPlace if chart does not already exist");(0,h["default"])(this.seriesList).invoke("redraw",!1);var t=this.hcChart.series,i=this.getSeriesConfigList();t.length>i.length?(0,h["default"])(t.slice(i.length)).invoke("remove",!1):t.length<i.length&&(0,h["default"])(i.slice(t.length)).each(function(e){n.hcChart.addSeries(e,!1,!1)});var r=void 0,a=void 0,o=this.xAxisList[0],s=o.isZoomed;s?(r=this.hcChart.xAxis[0].getExtremes(),r.max-=o.hasTickmarksBetween()?0:1):this.selectionWindow&&(r=this.selectionWindow.getExtremes(),r.min+=o.hasTickmarksBetween()?1:0),r&&(a=this.calculatePostUpdateExtremes(r)),(0,h["default"])(this.xAxisList).invoke("redraw",!1),(0,h["default"])(this.yAxisList).invoke("redraw",!1),s?null===a.min||null===a.max?this.hcChart.xAxis[0].zoom():(a.max+=o.hasTickmarksBetween()?0:1,this.hcChart.xAxis[0].zoom(a.min,a.max)):this.selectionWindow&&(null===a.max?(this.selectionWindow.destroy(),this.selectionWindow=null):(a.min=(a.min||0)-(o.hasTickmarksBetween()?1:0),this.selectionWindow.setExtremes(a))),this.hcChart.redraw(),this.benchmark("Series Redraw Finished"),e(this,this.benchmarks)},cancelPendingDraw:function(){this.pendingDraw&&"pending"===this.pendingDraw.state()&&this.pendingDraw.cancel()},setSize:function(e,n){if(this.hcChart){var t=this.hcChart.xAxis[0];t&&this.xAxisList[0].isZoomed&&(t.userMin=t.userMin||t.oldUserMin,t.userMax=t.userMax||t.oldUserMax),this.hcChart.setSize(e,n,!1),this.cacheDrawnDimensions()}},destroy:function(){this.cancelPendingDraw(),this.hcChart&&(this.onChartDestroy(),this.hcChart.pointer&&this.hcChart.pointer.reset(),this.hcChart.destroy(),this.hcChart=null)},getSVG:function(){var e=this.hcChart;this.hcConfig.legend.enabled&&e.legend.nav&&e.legend.nav.destroy(),(0,s["default"])(e.series).each(function(e,n){n.area&&0===k.getComputedOpacity(n.area)&&(n.area.destroy(),delete n.area)});var n=(0,s["default"])(".highcharts-container").find("svg");return n.siblings().remove(),n.find(".highcharts-tracker").remove(),n.find(".highcharts-legend g[clip-path]").each(function(){(0,s["default"])(this).removeAttr("clip-path")}),n.parent().html()},processProperties:function(){var e=this;C["default"].prototype.processProperties.call(this),this.properties.hasOwnProperty("drilldown")?this.chartClickEnabled=this.legendClickEnabled="all"===this.properties.drilldown:(this.properties.hasOwnProperty("chart.clickEnabled")?this.chartClickEnabled=v.normalizeBoolean(this.properties["chart.clickEnabled"]):this.chartClickEnabled=v.normalizeBoolean(this.properties.enableChartClick),this.properties.hasOwnProperty("chart.legend.clickEnabled")?this.legendClickEnabled=v.normalizeBoolean(this.properties["chart.legend.clickEnabled"]):this.legendClickEnabled=v.normalizeBoolean(this.properties.enableLegendClick));var n=["line","area"];this.legendMode=(0,h["default"])(n).indexOf(this.type)===-1?"standard":s["default"].trim(this.properties["legend.mode"]),this.legendMode!==ie&&"none"===this.properties["legend.placement"]&&(this.hasLegend=!1),(this.hasXAxis||this.hasYAxis)&&(this.axisColorScheme={"axis.foregroundColorSoft":this.axisColorSoft,"axis.foregroundColorSofter":this.axisColorSofter,"axis.fontColor":this.fontColor}),!this.properties.hasOwnProperty("legend.masterLegend")||this.properties["legend.masterLegend"]&&"null"!==s["default"].trim(this.properties["legend.masterLegend"])||(this.requiresExternalColors=!1),this.stackMode=this.properties["chart.stackMode"]||"default",this.legendLabels=v.stringToArray(this.properties["legend.labels"]||"[]"),this.showHideMode="show_hide"===this.properties["data.fieldListMode"],this.fieldHideList=h["default"].union(this.properties.fieldHideList||[],v.stringToArray(this.properties["data.fieldHideList"])||[]),this.fieldShowList=v.stringToArray(this.properties["data.fieldShowList"])||[];var t=this.properties["chart.seriesColors"]||this.properties.seriesColors;this.seriesColors=v.stringToHexArray(t)||null;var i=this.properties["chart.fieldColors"]||this.properties.fieldColors;this.internalFieldColors=v.stringToHexObject(i||"{}");var r=this.properties["annotation.categoryColors"];this.annotationCategoryColors=v.stringToHexObject(r||"{}"),this.overlayFields=v.stringToFieldList(this.properties["chart.overlayFields"]),this.seriesTypeMapping={},(0,h["default"])(this.overlayFields).each(function(n){e.seriesTypeMapping[n]="line"}),this.yAxisMapping={};var a=v.normalizeBoolean(this.properties["axisY2.enabled"]);if(a){var o=this.properties["axisY2.fields"]?v.stringToFieldList(this.properties["axisY2.fields"]):this.overlayFields;(0,h["default"])(o).each(function(n){e.yAxisMapping[n]=1})}this.enableAnimation=v.normalizeBoolean(this.properties.enableAnimation,!1);var l=["x","y","xy","off"];(0,h["default"])(l).indexOf(this.properties.zoomType)!==-1&&(this.zoomType=this.properties.zoomType),this.showLabels=this.properties["chart.showDataLabels"],"undefined"==typeof this.showLabels&&(this.showLabels="none"),this.splitSeries=v.normalizeBoolean(this.properties["layout.splitSeries"],!1),this.splitSeriesAllowIndependentYRanges=v.normalizeBoolean(this.properties["layout.splitSeries.allowIndependentYRanges"],!1)},firstRenderOverride:function(e){this.hcChart=e;var n=m["default"].Pointer,t=m["default"].fireEvent,i=m["default"].each,r=e.options;e.isReadyToRender()&&(e.getContainer(),t(e,"init"),e.resetMargins(),e.setChartSize(),e.propFromSeries(),e.getAxes(),i(r.series||[],function(n){e.initSeries(n)}),e.linkSeries(),t(e,"beforeRender"),n&&(e.pointer=new n(e,r)),e.render(function(){!e.renderer.imgCount&&e.onload&&e.onload(),e.temporaryDisplay(!0)}))},renderOverride:function(e,n){var t,i,r,a,o=m["default"].each,s=e.axes,l=e.renderer,h=e.options;e.setTitle(),e.legend=new m["default"].Legend(e,h.legend),e.getStacks&&e.getStacks(),e.getMargins(!0),e.setChartSize(),t=e.plotWidth,i=e.plotHeight=e.plotHeight-21,o(s,function(e){e.setScale()}),e.getAxisMargins(),r=t/e.plotWidth>1.1,a=i/e.plotHeight>1.05,(r||a)&&(o(s,function(e){(e.horiz&&r||!e.horiz&&a)&&e.setTickInterval(!0)}),e.getMargins()),e.drawChartBox(),e.hasCartesianSeries&&o(s,function(e){e.visible&&e.render()}),e.seriesGroup||(e.seriesGroup=l.g("series-group").attr({zIndex:3}).add()),this.pendingDraw=(0,O.asyncEach)(e.series,function(e){e.translate(),e.render()}),this.pendingDraw.done(function(){e.renderLabels(),e.addCredits(),e.setResponsive&&e.setResponsive(),e.hasRendered=!0,n()})},initializeFields:function(){var e=this.dataSet.getFieldData();this.xFields=e.xFields,this.yFields=e.yFields;var n=s["default"].extend([],this.fieldShowList),t=s["default"].extend([],this.fieldHideList),i=h["default"].intersection(n,t);this.showHideMode?t=h["default"].difference(t,i):n=h["default"].difference(n,i),this.yFields=h["default"].difference(this.yFields,t),n.length>0&&(this.yFields=h["default"].intersection(this.yFields,n)),this.yFields.length>0&&this.legendLabels.length>0&&(this.yFields=h["default"].union(this.legendLabels,this.yFields))},isEmpty:function(){return!this.yFields||0===this.yFields.length},hasTimeXAxis:function(){return(0,h["default"])(this.xFields||[]).any(this.seriesIsTimeBased,this)},hasBinnedTimeXAxis:function(){return this.hasTimeXAxis()&&this.dataSet.hasField("_span")},shouldProgressiveDraw:function(){if(this.isEmpty())return!1;var e=this.yFields.length*this.dataSet.getSeries(this.yFields[0]).length;return e>this.PROGRESSIVE_DRAW_THRESHOLD},shouldUpdateInPlace:function(){return this.hcChart&&!this.isDirty()},initializeColorPalette:function(){this.colorPalette=new I["default"](this.seriesColors),this.annotationColorPalette=new I["default"](this.ANNOTATION_COLORS,(!0))},initializeSeriesList:function(){this.seriesList=(0,h["default"])(this.initializeSeriesPropertiesList()).map(function(e){return ne["default"].create(e)})},updateSeriesProperties:function(){var e=this,n=this.initializeSeriesPropertiesList(),t=!1;h["default"].each(this.seriesList,function(e,i){n[i]&&e.getType()!==n[i].type&&(t=!0)}),t?(this.seriesList=null,this._isDirty=!0,this.initializeSeriesList()):this.seriesList.length>n.length?this.seriesList=(0,h["default"])(this.seriesList).filter(function(e,t){return t>=n.length?(e.destroy(),!1):(e.update(n[t]),!0)},this):this.seriesList.length<=n.length&&(this.seriesList=(0,h["default"])(n).map(function(n,t){if(t<e.seriesList.length)return e.seriesList[t].update(n),e.seriesList[t];var i=ne["default"].create(n);return e.bindIndividualSeries(i),i}))},initializeSeriesPropertiesList:function(){var e=this;if(this.isEmpty())return[{type:this.type}];var n=void 0,t=P.isRangeSeriesDataSet(this.dataSet),i=t?P.getRangeSeriesConfig(this.dataSet):[],r=this.getDashStyle();return t&&(n=(0,h["default"])(i).pluck("predicted")),(0,h["default"])(this.yFields).map(function(a){var o=void 0;n&&(0,h["default"])(n).contains(a)?o="range":e.seriesTypeMapping.hasOwnProperty(a)&&(o=e.seriesTypeMapping[a]);var l=null;e.hasTimeXAxis()&&"column"!==e.type&&"bar"!==e.type&&(l="on");var d=s["default"].extend(!0,{},e.properties,{type:o||e.type,name:a,pointPlacement:l,stacking:t?"default":e.stackMode,clickEnabled:e.chartClickEnabled,dashStyle:r});return"range"===o&&(d.names=(0,h["default"])(i).findWhere({predicted:a})),e.yAxisMapping.hasOwnProperty(a)&&(d.yAxis=e.yAxisMapping[a]),d})},initializeXAxisList:function(){var e=this,n=this.isEmpty();this.xAxisList=(0,h["default"])(this.xFields).map(function(t,i){var r=(0,h["default"])(e.seriesList).any(function(e){return e.getXAxisIndex()===i&&{column:!0,bar:!0}.hasOwnProperty(e.getType())}),a=s["default"].extend(v.getXAxisProperties(e.properties),e.axisColorScheme,{"axis.orientation":e.axesAreInverted?"vertical":"horizontal",isEmpty:n,crosshair:e.legendMode===ie});if(a["axisTitle.text"]=e._getComputedXAxisTitle(a,t),e.seriesIsTimeBased(t)){a["axisLabels.tickmarkPlacement"]=r?"between":"on";var o=e._getComputedTimeAxisMaxValue(r);return null!==o&&(a["axis.maximumValue"]=o),e.isAnnotationSupported()&&(a["axis.annotations"]=e.getFormattedAnnotations()),new E["default"](a)}return a["axis.categories"]=e.dataSet.getSeries(t),a["axisLabels.tickmarkPlacement"]="between",new z["default"](a)})},initializeYAxisList:function(){var e=this,n=this.isEmpty();this.yAxisList=[];var t=(0,h["default"])(this.seriesList).chain().invoke("getYAxisIndex").max().value();(0,h["default"])(t+1).times(function(t){e._initializeYAxis(t,n)})},_initializeYAxis:function(e,n){var t=this.initializeYAxisProperties(e,n);t["axisTitle.text"]=this._getComputedYAxisTitle(t,e),"default"!==this.stackMode&&(t["axis.scale"]="linear");var i=this.splitSeries&&!this.splitSeriesAllowIndependentYRanges;"stacked100"===this.stackMode&&this.isStackable()&&(i||0===e)&&(t.sharedMin=0,t.sharedMax=100),this.yAxisList.push(new W["default"](t))},initializeYAxisProperties:function(e,n){var t=e%2!==0,i=s["default"].extend(v.getYAxisProperties(this.properties,e),this.axisColorScheme,{"axis.orientation":this.axesAreInverted?"horizontal":"vertical",isEmpty:n,opposite:t,sharedMax:t?this.properties.overlayAxisMax:this.properties.yAxisMax,sharedMin:t?this.properties.overlayAxisMin:this.properties.yAxisMin});return i},updateAxisProperties:function(){var e=this;if(this.hasXAxis){var n=this.xAxisList[0],t=this.xFields[0];if(n instanceof z["default"])n.setCategories(this.dataSet.getSeries(t));else if(n instanceof E["default"]){var i=n.hasTickmarksBetween(),r=this._getComputedTimeAxisMaxValue(i);null!==r&&n.setMaximumValue(r),this.isAnnotationSupported()&&n.setAnnotations(this.getFormattedAnnotations())}var a=v.getXAxisProperties(this.properties);n.setTitle(this._getComputedXAxisTitle(a,t))}if(this.hasYAxis){var o=(0,h["default"])(this.seriesList).chain().invoke("getYAxisIndex").max().value();this.yAxisList.length<o+1&&(this.initializeYAxisList(),this._isDirty=!0)}h["default"].each(this.yAxisList,function(n,t){var i=v.getYAxisProperties(e.properties,t);n.setTitle(e._getComputedYAxisTitle(i,t))})},getFormattedAnnotations:function(){var e=this,n=h["default"].filter(this.dataSet.getAnnotations(),function(e){return e.time&&(0,c["default"])(e.time).isValid()}),t=h["default"].uniq(h["default"].pluck(n,"category"));return h["default"].map(n,function(n){var i=n.category,r=(0,c["default"])(n.time).toDate(),a=n.color;return a||(a=e.annotationCategoryColors.hasOwnProperty(i)?k.colorFromHex(e.annotationCategoryColors[i]):e.annotationColorPalette.getColorAsRgb(i,t.indexOf(i),t.length)),{value:r,color:a,label:n.label,category:i}})},_getComputedXAxisTitle:function(e,n){return h["default"].isUndefined(e["axisTitle.text"])||""===e["axisTitle.text"]?this._getDefaultXAxisTitleFromField(n):e["axisTitle.text"]},_getComputedYAxisTitle:function(e,n){return h["default"].isUndefined(e["axisTitle.text"])||""===e["axisTitle.text"]?this._getDefaultYAxisTitle(n):e["axisTitle.text"]},_getDefaultXAxisTitleFromField:function(e){return e},_getDefaultYAxisTitle:function(e){var n=(0,h["default"])(this.seriesList).filter(function(n){return n.getYAxisIndex()===e});return 1===n.length?n[0].getName():void 0},_getComputedTimeAxisMaxValue:function(e){if(!e&&this.hasBinnedTimeXAxis()){var n=this.dataSet.getSeriesAsEpochTimes(this.xFields[0]),t=this.dataSet.getSeriesAsFloats("_span");return h["default"].last(n)+1e3*h["default"].last(t)}return null},initializeLegend:function(){var e=v.getLegendProperties(this.properties);(0,h["default"])(e.clickEnabled).isUndefined()&&(e.clickEnabled=this.legendClickEnabled),s["default"].extend(e,{fontColor:this.fontColor,isMultiSeries:this.legendMode===ie,isExportMode:this.exportMode}),this.legend=new F["default"](e),this.bindLegendEvents()},bindLegendEvents:function(){var e=this,n={highlightDelay:125,unhighlightDelay:50,onMouseOver:function(n){e.handleLegendMouseOver(n)},onMouseOut:function(n){e.handleLegendMouseOut(n)}},t=new $["default"](n);this.legend.on("mouseover",function(e,n){t.mouseOverHappened(n)}),this.legend.on("mouseout",function(e,n){t.mouseOutHappened(n)}),this.legend.on("click",function(n,t){e.handleLegendClick(n,t)})},initializeTooltip:function(){var e={borderColor:this.foregroundColorSoft,mode:this.legendMode};this.tooltip=new G["default"](e)},setAllSeriesData:function(){
var e=this;(0,h["default"])(this.seriesList).each(function(n){"range"===n.getType()?e.setRangeSeriesData(n):e.setBasicSeriesData(n)})},setBasicSeriesData:function(e){var n=this.getSeriesXInfo(e),t=this.getSeriesYInfo(e);n.axis instanceof W["default"]?e.setData({x:this.formatNumericAxisData(n.axis,n.fieldName),y:this.formatNumericAxisData(t.axis,t.fieldName)}):n.axis instanceof E["default"]?e.setData({x:this.formatTimeAxisData(n.axis,n.fieldName),y:this.formatNumericAxisData(t.axis,t.fieldName)},{sortXValues:!this.hasBinnedTimeXAxis()}):e.setData({y:this.formatNumericAxisData(t.axis,t.fieldName)})},setRangeSeriesData:function(e){var n=this.getSeriesXInfo(e),t=this.getSeriesYInfo(e),i=(0,h["default"])(P.getRangeSeriesConfig(this.dataSet)).findWhere({predicted:e.getName()}),r={predicted:this.formatNumericAxisData(t.axis,i.predicted),lower:this.formatNumericAxisData(t.axis,i.lower),upper:this.formatNumericAxisData(t.axis,i.upper)};n.axis instanceof W["default"]?r.x=this.formatNumericAxisData(n.axis,n.fieldName):n.axis instanceof E["default"]&&(r.x=this.formatTimeAxisData(n.axis,n.fieldName)),e.setData(r)},bindSeriesEvents:function(){var e=this;this.throttle=new $["default"]({highlightDelay:125,unhighlightDelay:50,onMouseOver:function(n,t){e.legendMode!==ie&&e.handlePointMouseOver(n,t)},onMouseOut:function(n,t){e.legendMode!==ie?e.handlePointMouseOut(n,t):e.legend&&e.legend.resetLegend()}}),(0,h["default"])(this.seriesList).each(this.bindIndividualSeries,this)},bindIndividualSeries:function(e){var n=this;e.on("mouseover",function(e,t,i){n.throttle.mouseOverHappened(t,i)}),e.on("mouseout",function(e,t,i){n.throttle.mouseOutHappened(t,i)}),e.on("click",function(e,t,i){n.handlePointClick(e,t,i)})},handlePointClick:function(e,n,t){var i=this,r={},a=n.originalIndex,o=this.getSeriesPointInfo(t,n),s={type:"pointClick",modifierKey:e.modifierKey,name:o.xAxisName,name2:o.yAxisName,value2:o.yValue};if(o.xAxisIsTime){var l=this.dataSet.getSeries(o.xAxisName)[a];s.value=T["default"].getEpochTimeFromISO(l),r["row."+o.xAxisName]=s.value,this.hasBinnedTimeXAxis()?s._span=this.dataSet.getSeriesAsFloats("_span")[a]:s._span=.001}else s.value=o.xValue,r["row."+o.xAxisName]=o.xValue;(0,h["default"])(this.yFields).each(function(e){r["row."+e]=i.dataSet.getSeries(e)[a]}),s.rowContext=r,this.trigger(s)},handlePointMouseOver:function(e,n){(0,h["default"])(this.seriesList).each(function(t){t.matchesName(n.getName())?t.handlePointMouseOver(e):t.unHighlight()}),this.legend&&this.legend.selectField(n.getLegendKey())},handlePointMouseOut:function(e,n){(0,h["default"])(this.seriesList).each(function(t){t.matchesName(n.getName())?t.handlePointMouseOut(e):t.highlight()}),this.legend&&this.legend.unSelectField(n.getLegendKey())},handleLegendClick:function(e,n){var t={type:"legendClick",modifierKey:e.modifierKey,name2:n};this.trigger(t)},handleLegendMouseOver:function(e){(0,h["default"])(this.seriesList).each(function(n){n.matchesName(e)?n.handleLegendMouseOver(e):n.unHighlight()})},handleLegendMouseOut:function(e){(0,h["default"])(this.seriesList).each(function(n){n.matchesName(e)?n.handleLegendMouseOut(e):n.highlight()})},applyColorPalette:function(){var e=this;if(!this.isEmpty()){var n={};(0,h["default"])(this.getFieldList()).each(function(t,i,r){n[t]=e.computeFieldColor(t,i,r)}),(0,h["default"])(this.seriesList).invoke("applyColorMapping",n)}},getConfig:function(){var e=this,n=s["default"].extend(!0,{chart:{animation:this.enableAnimation},plotOptions:{series:{animation:this.enableAnimation}},tooltip:{animation:this.enableAnimation,followTouchMove:!this.isZoomable()}},this.BASE_CONFIG,{chart:this.getChartConfig(),series:this.getSeriesConfigList(),xAxis:this.getXAxisConfig(),yAxis:this.getYAxisConfig(),legend:this.getLegendConfig(),tooltip:this.getTooltipConfig(),plotOptions:this.getPlotOptionsConfig(),pointerDragStartPreHook:(0,h["default"])(this.pointerDragStartPreHook).bind(this),pointerDragOverride:(0,h["default"])(this.pointerDragOverride).bind(this),pointerDropPreHook:(0,h["default"])(this.pointerDropPreHook).bind(this),pointerDropPostHook:(0,h["default"])(this.pointerDropPostHook).bind(this),pointerPinchOverride:(0,h["default"])(this.pointerPinchOverride).bind(this)});return this.exportMode&&(this.seriesIsTimeBased(this.xFields)&&(0,h["default"])(n.xAxis).each(function(n){var t=void 0;if(e.axesAreInverted)t=-50;else{var i=e.dataSet.getSeriesAsFloats("_span"),r=i&&i.length>0?parseInt(i[0],10):1,a=86400,o=365*a;t=r>=o?15:r>=a?25:35}n.title.margin=t}),s["default"].extend(!0,n,{plotOptions:{series:{enableMouseTracking:!1,shadow:!1}}})),n},getSeriesConfigList:function(){return(0,h["default"])(this.seriesList).chain().invoke("getConfig").flatten(!0).value()},getXAxisConfig:function(){return this.hasXAxis?(0,h["default"])(this.xAxisList).map(function(e,n){var t=e.getConfig();return n>0&&(t.offset=40),t},this):[]},getYAxisConfig:function(){return this.hasYAxis?(0,h["default"])(this.yAxisList).map(function(e){return e.getConfig()}):[]},getLegendConfig:function(){return this.hasLegend&&this.legend?this.legend.getConfig():{}},getTooltipConfig:function(){return this.tooltip?s["default"].extend(this.tooltip.getConfig(),{formatter:function(){return!1}}):{}},formatTooltip:function(e,n){var t=this.getSeriesPointInfo(e,n);return this.legendMode===ie?t.xValueDisplay:e.getTooltipHtml(t,this.hcChart)},getChartConfig:function(){var e=this,n={type:this.type,renderTo:this.container,backgroundColor:this.backgroundColor,borderColor:this.backgroundColor,events:{redraw:function(){var n=this;e.onChartRedraw(n),e.onChartLoadOrRedraw(n)},endResize:this.onChartResize.bind(this),tooltipRefresh:this.onTooltipRefresh.bind(this)}};if(this.hasXAxis&&(n.events.selection=this.onChartSelection.bind(this)),this.exportMode?(n.width=this.width||this.EXPORT_WIDTH,n.height=this.height||this.EXPORT_HEIGHT):this.$container.is(":visible")||(n.width=this.FALLBACK_WIDTH,n.height=this.FALLBACK_HEIGHT),this.isZoomable()&&"off"!==this.zoomType&&(n.zoomType=this.zoomType||"x"),this.yAxisList&&this.yAxisList.length>1){var t=h["default"].find(this.yAxisList,function(e){return e.hasExplicitMin||e.hasExplicitMax}),i=h["default"].any(this.yAxisList,function(e){return e.isLogScale()});(t||i)&&(n.alignTicks=!1)}return n},getDataLabelConfig:function(){if("none"===this.showLabels||"undefined"==typeof this.dataLabels)return{enabled:!1};var e=this,n=s["default"].extend(!0,{},this.dataLabels.getConfig(),{formatter:function(){for(var n=0;n<e.seriesList.length;n++){var t=this.series.options.id,i=e.seriesList[n].id;if(t===i){var r=e.getSeriesPointInfo(e.seriesList[n],this.point);if(r)return r.yValueDisplay}}}});return n},getPlotOptionsConfig:function(){var e="default"!==this.stackMode&&!P.isRangeSeriesDataSet(this.dataSet);return s["default"].extend(!0,{},this.BASE_PLOT_OPTIONS_CONFIG,{series:{cursor:this.chartClickEnabled?"pointer":"default",dataLabels:this.getDataLabelConfig()},area:{trackByArea:e}})},isAnnotationSupported:function(){return h["default"].indexOf(["area","line","column"],this.type)>=0},isZoomable:function(){return"area"===this.type||"line"===this.type||"column"===this.type},isStackable:function(){return"line"!==this.type},enableTooltip:function(e){var n=this;e.tooltip.options.formatter=function(){var e=this.points&&this.points.length?this.points[0]:this,t=e.series.splSeries;return n.formatTooltip(t,e.point)}},onTooltipRefresh:function(){var e=this;if(this.legend&&this.legendMode===ie){var n=this.hcChart.hoverPoints.map(function(n){var t=e.getSeriesByName(n.series.name),i=e.getSeriesPointInfo(t,n);return{seriesIndex:n.series.index,value:i.yValue,formattedValue:i.yValueDisplay}});this.legend.updateLegend(n)}},onChartLoad:function(e){this.legend&&this.legend.onChartLoad(e),this.dataLabels&&this.dataLabels.onChartLoad(e),(0,h["default"])(this.xAxisList).invoke("onChartLoad",e),(0,h["default"])(this.yAxisList).invoke("onChartLoad",e),(0,h["default"])(this.seriesList).invoke("onChartLoad",e),this.isZoomable()&&this.triggerRangeSelectionEvent()},onChartRedraw:function(e){var n=this;if(this.selectionWindow)this.selectionWindow.onChartRedraw(e);else if(this.isZoomable()&&!this.isiOS){var t=this.xAxisList[0];t&&t.isZoomed?(this.resetZoomButton||(this.resetZoomButton=new q["default"](this.hcChart)),this.panButtons?this.panButtons.onChartRedraw(e):(this.panButtons=new U["default"](this.hcChart,this.panDistanceResolver.bind(this)),this.panButtons.on("pan",function(){n.triggerRangeSelectionEvent()}))):(this.resetZoomButton&&(this.resetZoomButton.destroy(),this.resetZoomButton=null),this.panButtons&&(this.panButtons.destroy(),this.panButtons=null))}if(this.isZoomable()&&!this.selectionTriggeredBeforeRedraw){var i=!this.selectionWindow||this.updateHasRebinned;this.triggerRangeSelectionEvent(null,{skipNormalization:i})}this.selectionTriggeredBeforeRedraw=!1},onChartLoadOrRedraw:function(e){this.legend&&this.legend.onChartLoadOrRedraw(e),this.dataLabels&&this.dataLabels.onChartLoadOrRedraw(e),(0,h["default"])(this.xAxisList).invoke("onChartLoadOrRedraw",e),(0,h["default"])(this.yAxisList).invoke("onChartLoadOrRedraw",e),(0,h["default"])(this.seriesList).invoke("onChartLoadOrRedraw",e)},onChartDestroy:function(){this.legend&&this.legend.destroy(),this.dataLabels&&this.dataLabels.destroy(),(0,h["default"])(this.xAxisList).invoke("destroy"),(0,h["default"])(this.yAxisList).invoke("destroy"),(0,h["default"])(this.seriesList).invoke("destroy"),this.selectionWindow&&(this.selectionWindow.destroy(),this.selectionWindow=null),this.panButtons&&(this.panButtons.destroy(),this.panButtons=void 0)},onChartSelection:function(e){var n=this.xAxisList[0];if(!e.resetSelection){var t=e.xAxis[0],i=this.getNormalizedAxisExtremes(t.min,t.max);t.min=i.min,t.max=i.max,this.hasTimeXAxis()||(t.max+=n.hasTickmarksBetween()?0:1);var r=this.triggerRangeSelectionEvent(i);if(r.isDefaultPrevented()){if(e.preventDefault(),this.hasPendingRangeResetEvent=!1,n.getZoomed(t.min,t.max)){this.selectionWindow=new V["default"](this.hcChart,this.xAxisValueSnapper.bind(this));var a=this;this.selectionWindow.on("rangeSelect",function(){a.triggerRangeSelectionEvent()})}}else this.selectionTriggeredBeforeRedraw=!0}},onChartResize:function(e){this.panButtons&&this.panButtons.onChartResize(e)},panDistanceResolver:function(e,n){if(!this.hasTimeXAxis())return{min:1,max:1};if(!this.hasBinnedTimeXAxis()){var t=e.normalizeTimeTickInterval(e.tickInterval,e.options.units).unitRange;return{min:t,max:t}}var i=e.getExtremes(),r=this.dataSet.getSeriesAsEpochTimes(this.xFields[0]),a=this.dataSet.getSeriesAsFloats("_span"),o=this.findNearestTimeBinIndex(i.min,r),s=this.findNearestTimeBinIndex(i.max,r);return"left"===n?0===o?{min:0,max:0}:{min:1e3*a[o-1],max:1e3*a[s-1]}:"right"===n?s>=a.length?{min:0,max:0}:{min:1e3*a[o],max:1e3*a[s]}:void 0},xAxisValueSnapper:function(e,n){if(n=n||"round",!this.hasTimeXAxis())return Math[n](e);if(!this.hasBinnedTimeXAxis())return e;var t=this.dataSet.getSeriesAsEpochTimes(this.xFields[0]),i=this.findNearestTimeBinIndex(e,t),r=t[i];return"floor"===n&&e<r&&i>0?i--:"ceil"===n&&e>r&&i++,i===t.length?t[i-1]+1e3*this.dataSet.getSeriesAsFloats("_span")[i-1]:t[i]},getNormalizedAxisExtremes:function(e,n){var t=this.hcChart.xAxis[0],i=t.dataMax,r=t.dataMin,a=function(e){return e>i&&(e=i),e<r&&(e=r),e};return e=a(e),n=a(n),this.hasTimeXAxis()?this.getNormalizedTimeAxisExtremes(e,n):this.getNormalizedCategoryAxisExtremes(e,n)},getNormalizedTimeAxisExtremes:function(e,n){if(!this.hasBinnedTimeXAxis())return{min:e,max:n};var t=this.xAxisList[0],i=this.dataSet.getSeriesAsEpochTimes(this.xFields[0]),r=this.dataSet.getSeriesAsFloats("_span"),a=this.findNearestTimeBinIndex(e,i),o=this.findNearestTimeBinIndex(n,i);return{min:i[a],max:i[o]+(t.hasTickmarksBetween()?0:1e3*r[o])}},getNormalizedCategoryAxisExtremes:function(e,n){var t=this.xAxisList[0],i=this.hcChart.xAxis[0],r=i.dataMax,a=Math.round(e),o=Math.round(n),s=this.isiOS&&this.hcChart.pointer.selectionMarker,l=s&&this.hcChart.pointer.selectionMarker.width===this.hcChart.plotWidth,h=s&&this.hcChart.pointer.selectionMarker.width!==this.hcChart.plotWidth;return l&&o>a&&o!==r&&(o-=t.hasTickmarksBetween()?0:1),h&&n-e<1&&!t.hasTickmarksBetween()&&(o=a),{min:a,max:o}},findNearestTimeBinIndex:function(e,n){var t=h["default"].sortedIndex(n,e);if(0===t)return 0;var i=e-n[t-1],r=n[t]-e;return i<r?t-1:t},calculatePostUpdateExtremes:function(e){var n=this.xAxisList[0];if(!this.hasTimeXAxis()){var t=n.getCategories();return t.length>e.max?e:{min:null,max:null}}if(!this.hasBinnedTimeXAxis())return e;var i=this.dataSet.getSeriesAsEpochTimes(this.xFields[0]),r=this.dataSet.getSeriesAsFloats("_span"),a={min:i[0],max:h["default"].last(i)+1e3*h["default"].last(r)};if(a.max<e.max||a.min>e.min)return{min:null,max:null};var o=i[this.findNearestTimeBinIndex(e.min,i)],s=i[this.findNearestTimeBinIndex(e.max,i)];return i.indexOf(e.min)!==-1&&i.indexOf(e.max)!==-1||(this.updateHasRebinned=!0),{min:o,max:s}},triggerRangeSelectionEvent:function(e,n){var t=void 0,i=this.xAxisList[0],r=!e&&!this.selectionWindow&&!i.isZoomed;if(e||(this.selectionWindow?(e=this.selectionWindow.getExtremes(),e.min+=i.hasTickmarksBetween()?1:0):(e=this.hcChart.xAxis[0].getExtremes(),i.isZoomed&&(e.max-=i.hasTickmarksBetween()?0:1)),n&&n.skipNormalization||(e=this.getNormalizedAxisExtremes(e.min,e.max))),this.hasTimeXAxis()){var a=this.dataSet.getSeriesAsEpochTimes(this.xFields[0]),o=0,l=h["default"].sortedIndex(a,e.max);if(this.hasBinnedTimeXAxis()&&i.hasTickmarksBetween()&&!this.selectionWindow){var d=this.dataSet.getSeriesAsFloats("_span");o=d[l]}else!this.hasBinnedTimeXAxis()||i.hasTickmarksBetween()&&!this.selectionWindow||l--;t=s["default"].Event("chartRangeSelect",{startXIndex:h["default"].sortedIndex(a,e.min),endXIndex:l,startXValue:e.min/1e3,endXValue:e.max/1e3+o,isReset:!!r})}else{var c=this.dataSet.getSeries(this.xFields[0]);t=s["default"].Event("chartRangeSelect",{startXIndex:e.min,endXIndex:e.max,startXValue:c[e.min],endXValue:c[e.max],isReset:!!r})}return this.trigger(t),t},pointerDragStartPreHook:function(e,n){if(this.selectionWindow){var t=this.selectionWindow.handleDragStartEvent(n);t||this.destroySelectionWindow()}},pointerPinchOverride:function(e,n,t){if(this.selectionWindow)if("touchstart"===n.type){this.hcChart.xAxis[0].zoomEnabled=!1,t.call(e,n);var i=this.selectionWindow.handleDragStartEvent(n);i||this.destroySelectionWindow(),this.hcChart.xAxis[0].zoomEnabled=!0}else"touchmove"===n.type?this.selectionWindow.handleDragEvent(n):"touchend"===n.type&&this.selectionWindow.handleDropEvent(n);else t.call(e,n)},destroySelectionWindow:function(){this.selectionWindow&&(this.selectionWindow.destroy(),this.selectionWindow=null,this.hasPendingRangeResetEvent=!0)},pointerDragOverride:function(e,n,t){this.selectionWindow?this.selectionWindow.handleDragEvent(n):(t.call(e,n),this.hcChart.pointer.selectionMarker&&this.hcChart.pointer.selectionMarker.attr({"stroke-width":2,stroke:this.foregroundColorSofter}))},pointerDropPreHook:function(e,n){this.selectionWindow&&this.selectionWindow.handleDropEvent(n)},pointerDropPostHook:function(){this.hasPendingRangeResetEvent&&(this.triggerRangeSelectionEvent(),this.hasPendingRangeResetEvent=!1)},getSeriesByName:function(e){return(0,h["default"])(this.seriesList).find(function(n){return n.hcSeries.name===e})},getSeriesXInfo:function(e){var n=e.getXAxisIndex();return{axis:this.xAxisList[n],fieldName:this.xFields[n]}},getSeriesYInfo:function(e){return{axis:this.yAxisList[e.getYAxisIndex()],fieldName:e.getName()}},getSeriesPointInfo:function(e,n){var t=h["default"].has(n,"originalIndex")?n.originalIndex:n.index,i=this.getSeriesXInfo(e),r=this.getSeriesYInfo(e),a=this.dataSet.getSeries(i.fieldName),o=this.dataSet.getSeries(r.fieldName);return{xAxisIsTime:i.axis instanceof E["default"],xAxisName:i.fieldName,xValue:a[t],xValueDisplay:i.axis.formatValue(a[t],n),yAxisName:r.fieldName,yValue:o[t],yValueDisplay:r.axis.formatValue(o[t],n)}},getDashStyle:function(){var e=this.properties.lineDashStyle;if(e)return v.capitalize(e)},seriesIsTimeBased:function(e){return/^_time/.test(e)},formatNumericAxisData:function(e,n){return this.dataSet.hasField(n)?this.dataSet.getSeriesAsFloats(n,{scale:e.isLogScale()?"log":"linear",nullValueMode:this.properties["chart.nullValueMode"]}):[]},formatTimeAxisData:function(e,n){return this.dataSet.hasField(n)?this.dataSet.getSeriesAsEpochTimes(n):[]},computeFieldColor:function(e,n,t){if(this.internalFieldColors.hasOwnProperty(e))return k.colorFromHex(this.internalFieldColors[e]);var i=!this.seriesColors&&!(0,h["default"])(this.externalPaletteMapping).isEmpty(),r=i?this.externalPaletteMapping[e]:n,a=i?this.externalPaletteSize:t.length;return this.colorPalette.getColorAsRgb(e,r,a)},BASE_CONFIG:{chart:{showAxes:!0,reflow:!1,selectionMarkerFill:"rgba(0,0,0,0)",spacingTop:16,style:{fontFamily:te.FONT_FAMILY,fontSize:te.FONT_SIZE}},credits:{enabled:!1},legend:{enabled:!1},plotOptions:{series:{states:{hover:{enabled:!1}},events:{legendItemClick:function(){return!1}},borderWidth:0,shadow:!1,turboThreshold:0}},title:{text:null},tooltip:{enabled:!1,useHTML:!0}},BASE_PLOT_OPTIONS_CONFIG:{line:{stickyTracking:!0,states:{hover:{marker:{enabled:!0,radius:6}}},marker:{enabled:!1,radius:2,symbol:"circle"}},area:{stickyTracking:!0,lineWidth:1,states:{hover:{marker:{enabled:!0,radius:6}}},marker:{symbol:"circle",radius:2,enabled:!1}},column:{markers:{enabled:!1},stickyTracking:!1,fillOpacity:1,trackByArea:!0},bar:{markers:{enabled:!1},stickyTracking:!1,fillOpacity:1,trackByArea:!0}}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){e=e||{},this.highlightDelay=e.highlightDelay||200,this.unhighlightDelay=e.unhighlightDelay||100,this.timer=null,this.timer2=null,this.mouseStatus="over",this.isSelected=!1,this.onMouseOver=e.onMouseOver,this.onMouseOut=e.onMouseOut}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a);o["default"].extend(r.prototype,{setMouseStatus:function(e){this.mouseStatus=e},getMouseStatus:function(){return this.mouseStatus},mouseOverHappened:function(){for(var e=this,n=arguments.length,t=Array(n),i=0;i<n;i++)t[i]=arguments[i];return r._synchronousBehavior?void this.onMouseOver.apply(null,t):(this.mouseOverFn=function(){e.onMouseOver.apply(null,t)},clearTimeout(this.timer),clearTimeout(this.timer2),this.setMouseStatus("over"),void this.timeOutManager())},mouseOutHappened:function(){for(var e=this,n=arguments.length,t=Array(n),i=0;i<n;i++)t[i]=arguments[i];return r._synchronousBehavior?void this.onMouseOut.apply(null,t):(this.mouseOutFn=function(){e.onMouseOut.apply(null,t)},this.setMouseStatus("out"),void this.timeOutManager())},timeOutManager:function(){var e=this;clearTimeout(this.timer),this.isSelected?"over"===this.getMouseStatus()?this.mouseEventManager():this.timer2=setTimeout(function(){e.setMouseStatus("out"),e.mouseEventManager()},e.unhighlightDelay):this.timer=setTimeout(function(){e.isSelected=!0,e.mouseEventManager()},e.highlightDelay)},mouseEventManager:function(){"over"===this.getMouseStatus()?(this.mouseOverFn(),this.isSelected=!0,this.setMouseStatus("out")):(this.mouseOutFn(),this.isSelected=!1,this.setMouseStatus("over"))}}),o["default"].extend(r,{_synchronousBehavior:!1,useSynchronousBehavior:function(){r._synchronousBehavior=!0},restoreDefaultBehavior:function(){r._synchronousBehavior=!1}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){this.index=e.index,this.originalIndex=h["default"].has(e,"originalIndex")?e.originalIndex:this.index,this.seriesName=e.series.name,this.name=e.name,this.y=e.y}function a(e){this.properties=this.normalizeProperties(e||{}),this.processProperties(),this.id=h["default"].uniqueId("series_"),this.data=[],this._isDirty=!1,this._dataIsDirty=!1,this.UNHIGHLIGHTED_COLOR=(0,p.addAlphaToColor)(this.UNHIGHLIGHTED_BASE_COLOR,this.UNHIGHLIGHTED_OPACITY),this.UNHIGHLIGHTED_BORDER_COLOR=(0,p.addAlphaToColor)(this.UNHIGHLIGHTED_BORDER_BASE_COLOR,this.UNHIGHLIGHTED_OPACITY)}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=i(o),l=t(1),h=i(l),d=t(10),c=i(d),p=t(7),u=t(3),f=t(9),m=i(f),g=t(5);a.prototype=s["default"].extend({},m["default"],{STACK_MODE_MAP:{"default":null,stacked:"normal",stacked100:"percent"},CHART_PROPERTY_PREFIX_REGEX:/^chart\./,UNHIGHLIGHTED_OPACITY:.3,UNHIGHLIGHTED_BASE_COLOR:"rgb(150, 150, 150)",UNHIGHLIGHTED_BORDER_BASE_COLOR:"rgb(200, 200, 200)",DEFAULT_STACK_MODE:null,CHARTING_PROPERTY_WHITELIST:[],normalizeProperties:function(e){var n=this,t=s["default"].extend(!0,{},e);return(0,h["default"])(t).each(function(e,i){if(n.CHART_PROPERTY_PREFIX_REGEX.test(i)){delete t[i];var r=i.replace(n.CHART_PROPERTY_PREFIX_REGEX,"");(0,h["default"])(n.CHARTING_PROPERTY_WHITELIST).contains(r)&&(t[r]=e)}}),t},processProperties:function(){},redraw:function(e){this.hcSeries&&(this.isDirty()?this.hcSeries.update(this.getConfig(),e):this.dataIsDirty()&&this.hcSeries.setData(this.hasPrettyData?this.prettyData:this.data,e))},update:function(e){var n=this.properties;this.properties=this.normalizeProperties(e),h["default"].isEqual(this.properties,n)||(this.processProperties(),this._isDirty=!0)},setData:function(e,n){n=n||{};var t=this.data;h["default"].isArray(e.y)&&0!==e.y.length?(0,h["default"])(e.x).isUndefined()?this.data=e.y:n.sortXValues?this.data=(0,h["default"])(e.x).chain().map(function(n,t){return{x:n,y:e.y[t],originalIndex:t}}).sortBy(function(e){return e.x}).value():this.data=(0,h["default"])(e.x).map(function(n,t){return[n,e.y[t]]}):this.data=[],h["default"].isEqual(this.data,t)||(this._dataIsDirty=!0)},getData:function(){return this.data},isDirty:function(){return this._isDirty},dataIsDirty:function(){return this._dataIsDirty},getXAxisIndex:function(){return this.properties.xAxis||0},getYAxisIndex:function(){return this.properties.yAxis||0},getName:function(){return this.properties.name},getLegendKey:function(){return this.properties.legendKey||this.getName()},getFieldList:function(){return[this.getName()]},matchesName:function(e){return e===this.getName()},applyColorMapping:function(e){var n=this.color;this.color=e[this.getName()],this.color!==n&&(this._isDirty=!0)},getColor:function(){return this.color},getStackMode:function(){return this.STACK_MODE_MAP[this.properties.stacking]||this.DEFAULT_STACK_MODE},getType:function(){return this.type},getConfig:function(){return{type:this.type,id:this.id,name:this.getName(),color:this.color,data:this.hasPrettyData?this.prettyData:this.data,xAxis:this.getXAxisIndex(),yAxis:this.getYAxisIndex(),stacking:this.getStackMode()}},onChartLoad:function(){},onChartLoadOrRedraw:function(e){this.hcSeries=e.get(this.id),this.hcSeries.splSeries=this,this._isDirty=!1,this._dataIsDirty=!1,this.hcSeries.options.states.hover.enabled=!0,this.addEventHandlers(this.hcSeries)},addEventHandlers:function(e){e.options.point.events=e.options.point.events||{};var n=this,t=e.options.point.events;t.mouseOver=function(){var e=this,t=new r(e);n.trigger("mouseover",[t,n])},t.mouseOut=function(){var e=this,t=new r(e);n.trigger("mouseout",[t,n])},(0,u.normalizeBoolean)(this.properties.clickEnabled)&&(t.click=function(e){var t=this,i=new r(t),a={type:"click",modifierKey:e.ctrlKey||e.metaKey};n.trigger(a,[i,n])})},destroy:function(){this.off(),this.hcSeries&&this.hcSeries.splSeries&&(this.hcSeries.splSeries=null),this.hcSeries=null},handlePointMouseOver:function(){this.bringToFront()},handleLegendMouseOver:function(){this.bringToFront(),this.highlight()},bringToFront:function(){this.hcSeries.group&&this.hcSeries.group.toFront(),this.hcSeries.trackerGroup&&this.hcSeries.trackerGroup.toFront()},estimateMaxColumnWidths:function(e,n,t){var i=new c["default"](e.renderer),r=e.options.tooltip.style.fontSize.replace("px",""),a=-(1/0),o=-(1/0);return h["default"].each(n,function(e){var n=i.predictTextWidth(e,r);n>a&&(a=n)}),h["default"].each(t,function(e){var n=i.predictTextWidth(e,r);n>o&&(o=n)}),i.destroy(),{maxLeftColWidth:a,maxRightColWidth:o}},getTooltipRows:function(e){var n=[];return e.xAxisIsTime?n.push([e.xValueDisplay]):n.push([e.xAxisName,e.xValueDisplay]),n.push([{color:e.seriesColor,text:e.seriesName},e.yValueDisplay]),n},getTooltipHtml:function(e,n){e.seriesName=this.getName(),e.seriesColor=this.getColor();var t=function(e){return(0,h["default"])(e).isString()?e:e.text},i=function(e){return(0,h["default"])(e).isString()?null:e.color},r=this.getTooltipRows(e),a=n.chartWidth-50,o=(0,h["default"])(r).map(function(e){return t(e[0]||"")}),l=(0,h["default"])(r).map(function(e){return t(e[1]||"")}),d=this.estimateMaxColumnWidths(n,o,l),c=d.maxLeftColWidth/(d.maxLeftColWidth+d.maxRightColWidth);return c>.9?c=.9:c<.1&&(c=.1),e.scaledMaxLeftColWidth=c*a+"px",e.scaledMaxRightColWidth=(1-c)*a+"px",e.willWrap=d.maxLeftColWidth+d.maxRightColWidth>a,(0,h["default"])(this.tooltipTemplate).template(s["default"].extend(e,{rows:r,normalizeToText:t,normalizeToColor:i,getThemeProperty:g.getThemeProperty}))},handlePointMouseOut:function(){},handleLegendMouseOut:function(){},highlight:function(){},unHighlight:function(){},tooltipTemplate:'\n        <table class="highcharts-tooltip"\n            <% if(willWrap) { %>\n                style="word-wrap: break-word; white-space: normal;"\n            <% } %>>\n            <% _(rows).each(function(row) { %>\n                <tr>\n                    <% if(row.length === 1) { %>\n                        <td style="text-align: left; color: <%= normalizeToColor(row[0]) || getThemeProperty(\'TOOLTIP_FONT_COLOR\') %>;" colpsan="2"><%- normalizeToText(row[0]) %></td>\n                    <% } else { %>\n                        <td style="text-align: left; color: <%= normalizeToColor(row[0]) || getThemeProperty(\'TOOLTIP_FONT_COLOR_SOFT\') %>; max-width: <%= scaledMaxLeftColWidth %>;"><%- normalizeToText(row[0]) %>:&nbsp;&nbsp;</td>\n                        <td style="text-align: right; color: <%= normalizeToColor(row[1]) || getThemeProperty(\'TOOLTIP_FONT_COLOR\') %>; max-width: <%= scaledMaxRightColWidth %>;"><%- normalizeToText(row[1]) %></td>\n                    <% } %>\n                </tr>\n            <% }); %>\n        </table>\n    '}),a.Point=r,n["default"]=a,e.exports=n["default"]},function(e,n,t){var i=t(13),r=t(16),a=t(54),o=t(17),s="prototype",l=function(e,n,t){var h,d,c,p=e&l.F,u=e&l.G,f=e&l.S,m=e&l.P,g=e&l.B,x=e&l.W,b=u?r:r[n]||(r[n]={}),y=b[s],v=u?i:f?i[n]:(i[n]||{})[s];u&&(t=n);for(h in t)d=!p&&v&&void 0!==v[h],d&&h in b||(c=d?v[h]:t[h],b[h]=u&&"function"!=typeof v[h]?t[h]:g&&d?a(c,i):x&&v[h]==c?function(e){var n=function(n,t,i){if(this instanceof e){switch(arguments.length){case 0:return new e;case 1:return new e(n);case 2:return new e(n,t)}return new e(n,t,i)}return e.apply(this,arguments)};return n[s]=e[s],n}(c):m&&"function"==typeof c?a(Function.call,c):c,m&&((b.virtual||(b.virtual={}))[h]=c,e&l.R&&y&&!y[h]&&o(y,h,c)))};l.F=1,l.G=2,l.S=4,l.P=8,l.B=16,l.W=32,l.U=64,l.R=128,e.exports=l},function(e,n){e.exports=function(e){return"object"==typeof e?null!==e:"function"==typeof e}},function(e,n){e.exports=function(e){try{return!!e()}catch(n){return!0}}},function(e,n){e.exports=function(e,n){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:n}}},function(e,n){e.exports=function(e){if(void 0==e)throw TypeError("Can't call method on  "+e);return e}},function(e,n){var t=Math.ceil,i=Math.floor;e.exports=function(e){return isNaN(e=+e)?0:(e>0?i:t)(e)}},function(e,n,t){var i=t(61)("keys"),r=t(62);e.exports=function(e){return i[e]||(i[e]=r(e))}},function(e,n,t){var i=t(34);e.exports=function(e){return Object(i(e))}},function(e,n){function t(e,n,t){switch(t.length){case 0:return e.call(n);case 1:return e.call(n,t[0]);case 2:return e.call(n,t[0],t[1]);case 3:return e.call(n,t[0],t[1],t[2])}return e.apply(n,t)}e.exports=t},function(e,n,t){var i=t(14),r=Object.create,a=function(){function e(){}return function(n){if(!i(n))return{};if(r)return r(n);e.prototype=n;var t=new e;return e.prototype=void 0,t}}();e.exports=a},function(e,n,t){function i(e){this.__wrapped__=e,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=o,this.__views__=[]}var r=t(39),a=t(41),o=4294967295;i.prototype=r(a.prototype),i.prototype.constructor=i,e.exports=i},function(e,n){function t(){}e.exports=t},function(e,n){var t=Array.isArray;e.exports=t},function(e,n){function t(e){var n=e;return n.placeholder}e.exports=t},function(e,n){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e,n){this.setColors(e),this.useInterpolation=o.normalizeBoolean(n,!1)}Object.defineProperty(n,"__esModule",{value:!0});var a=t(3),o=i(a),s=t(7),l=i(s),h=["#1e93c6","#f2b827","#d6563c","#6a5c9e","#31a35f"].map(l.hexFromColor);r.prototype={setColors:function(e){this.colors=e||h},getColor:function(e,n,t){var i=void 0,r=this.colors.length;if(0===r)return 0;if(n<0&&(n=0),!this.useInterpolation)return this.colors[n%r];t<1&&(t=1),n>t&&(n=t),i=1===t?0:(r-1)*(n/(t-1));var a=Math.floor(i),o=Math.min(a+1,r-1);return i-=a,l.interpolateColors(this.colors[a],this.colors[o],i)},getColorAsRgb:function(e,n,t){var i=this.getColor(e,n,t);return l.colorFromHex(i)}},r.setBaseColors=function(e){h=e.map(l.hexFromColor)},n["default"]=r,e.exports=n["default"]},function(e,n){e.exports=t(580)},function(e,n){e.exports=t(582)},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){this.properties=e||{},this.id=h["default"].uniqueId("axis_"),this.isVertical="vertical"===this.properties["axis.orientation"],this.isZoomed=!1,this._titleIsDirty=!1,this.labelRotation||(this.labelRotation=this.isVertical?0:u.getRotation(this.properties["axisLabels.majorLabelStyle.rotation"]))}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(10),c=r(d),p=t(3),u=i(p),f=t(91),m=i(f),g=t(22);a.prototype={getZoomed:function(e,n){var t=this.hcAxis;return t.hasData()?void 0!==e&&e>t.dataMin||void 0!==n&&n<("between"===t.options.tickmarkPlacement?t.dataMax:t.dataMax+1):t.categories&&t.categories.length>0?void 0!==e&&e>0||void 0!==n&&n<t.categories.length-1:void 0},clone:function(){return new this.constructor(s["default"].extend(!0,{},this.properties))},getConfig:function(){var e=null,n=this;return this.properties.isEmpty||"collapsed"===this.properties["axisTitle.visibility"]||!this.properties["axisTitle.text"]||/^\s+$/.test(this.properties["axisTitle.text"])||(e=u.escapeSVG(this.properties["axisTitle.text"])),s["default"].extend(!0,this.getOrientationDependentConfig(),{id:this.id,labels:{enabled:"hide"!==this.properties["axisLabels.majorLabelVisibility"],formatter:function(){var e=this;return n.formatLabel(e)},style:{color:this.properties["axis.fontColor"]||g.COLORS.DEFAULT_FONT_COLOR,textOverflow:"none"}},title:{style:{color:this.properties["axis.fontColor"]||g.COLORS.DEFAULT_FONT_COLOR,fontSize:"12px",HcTextStroke:!0},text:e},opposite:this.properties.opposite,lineColor:this.properties["axis.foregroundColorSoft"]||g.COLORS.DEFAULT_LINE_COLOR_SOFT,lineWidth:"hide"===this.properties["axisLabels.axisVisibility"]?0:1,gridLineColor:this.properties["axis.foregroundColorSofter"]||g.COLORS.DEFAULT_LINE_COLOR_SOFTER,gridLineWidth:u.normalizeBoolean(this.properties["gridLines.showMajorLines"])?1:0,tickLength:parseInt(this.properties["axisLabels.majorTickSize"],10)||6,tickColor:this.properties["axis.foregroundColorSoft"]||g.COLORS.DEFAULT_LINE_COLOR_SOFT,
tickWidth:"hide"===this.properties["axisLabels.majorTickVisibility"]?0:1,tickRenderPostHook:(0,h["default"])(this.tickRenderPostHook).bind(this),getOffsetPreHook:(0,h["default"])(this.getOffsetPreHook).bind(this),zoomPostHook:(0,h["default"])(this.zoomPostHook).bind(this),getLabelSizeOverride:(0,h["default"])(this.getLabelSizeOverride).bind(this)})},zoomPostHook:function(e,n,t){this.isZoomed=this.getZoomed(n,t),e.displayBtn=!1},getOrientationDependentConfig:function(){return this.isVertical?s["default"].extend(!0,{},this.BASE_VERT_CONFIG,this.getVerticalConfig()):s["default"].extend(!0,{},this.BASE_HORIZ_CONFIG,this.getHorizontalConfig())},onChartLoad:function(){},redraw:function(e){if(!this.hcAxis)throw new Error("cannot redraw an axis that has not been drawn yet");this.titleIsDirty()&&this.hcAxis.setTitle({text:this.properties["axisTitle.text"]},e)},titleIsDirty:function(){return this._titleIsDirty},setTitle:function(e){this.previousAxisTitle=this.properties["axisTitle.text"],this.properties["axisTitle.text"]=e,h["default"].isEqual(this.properties["axisTitle.text"],this.previousAxisTitle)||(this._titleIsDirty=!0)},onChartLoadOrRedraw:function(e){this.hcAxis=e.get(this.id),this.initializeTicks(),this._titleIsDirty=!1},initializeTicks:function(){var e=void 0,n=this.hcAxis.ticks,t=[];for(e in n)n.hasOwnProperty(e)&&t.push(n[e]);t.sort(function(e,n){return e.pos-n.pos}),this.ticks=t},tickRenderPostHook:function(e){var n=e.axis;if(e.label){if(e.isFirst&&e.isLast||!e.isFirst&&!e.isLast||e.isFirst&&(n.horiz||n.reversed)||e.isLast&&!n.horiz&&!n.reversed)return void m.showTickLabel(e);var t=1,i=!1;if(n.horiz&&n.reversed){var r=n.left-t,a=this.getTickLabelExtremesX(e).left;i=r>a}else if(n.horiz&&!n.reversed){var o=n.left+n.len+t,s=this.getTickLabelExtremesX(e).right;i=s>o}else{var l=n.top+n.len+t,h=this.getTickLabelExtremesY(e).bottom;i=h>l}return i?void m.hideTickLabel(e):void m.showTickLabel(e)}},getOffsetPreHook:function(e){if(e.userOptions.title.text){var n=e.chart,t=new c["default"](n.renderer),i=e.userOptions.title.text,r=12,a=void 0;a=e.horiz?t.ellipsize(i,n.chartWidth-100,r,{fontWeight:"bold"}):t.ellipsize(i,n.chartHeight-100,r,{fontWeight:"bold"}),e.options.title.text=a,e.axisTitle&&e.axisTitle.attr({text:a}),t.destroy()}},hasTickmarksBetween:function(){return"between"===this.properties["axisLabels.tickmarkPlacement"]},getTickLabelExtremesX:function(e){var n=e.label.getBBox(),t=e.axis.labelAlign,i=e.label.xy.x,r=n.width,a=void 0;return a="left"===t?i:"center"===t?i-.5*r:i-r,{left:a,right:a+r}},getTickLabelExtremesY:function(e){var n=e.label.xy.y;return{top:n-e.label.getBBox().height,bottom:n}},getLabelSizeOverride:function(e){if(!e.label)return 0;var n="horizontal"===this.properties["axis.orientation"];return e.labelBBox=e.label.getBBox(),n&&"on"===this.properties["axisLabels.tickmarkPlacement"]&&e.isLast&&!e.isFirst?0:e.labelBBox[n?"height":"width"]},destroy:function(){this.hcAxis=null},getVerticalConfig:function(){return{}},getHorizontalConfig:function(){return{labels:{rotation:this.labelRotation}}},BASE_HORIZ_CONFIG:{title:{margin:6},labels:{y:15}},BASE_VERT_CONFIG:{title:{margin:6}},CROSSHAIR_CONFIG:{snap:!1,color:"#cccccc",width:1,zIndex:1e4}},n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){O["default"].call(this,e),this.includeZero=this.determineIncludeZero(),this.hasExplicitMin=this.validateNumericProperty("axis.minimumNumber"),this.hasExplicitMax=this.validateNumericProperty("axis.maximumNumber"),this.hasExplicitMajorUnit=this.validateNumericProperty("axisLabels.majorUnit"),this.extendAxisRange=!!h["default"].isUndefined(this.properties["axisLabels.extendsAxisRange"])||m.normalizeBoolean(this.properties["axisLabels.extendsAxisRange"],!0),this.startOnTick=!this.hasExplicitMin&&this.extendAxisRange,this.endOnTick=!this.hasExplicitMax&&this.extendAxisRange,e&&(this.sharedMin=e.sharedMin,this.sharedMax=e.sharedMax,this.abbreviation=e["axis.abbreviation"])}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(12),c=r(d),p=t(10),u=r(p),f=t(3),m=i(f),g=t(2),x=i(g),b=t(4),y=i(b),v=t(191),w=i(v),k=t(8),S=r(k),T=t(48),O=r(T);x.inherit(a,O["default"]),s["default"].extend(a.prototype,{getConfig:function(){var e=O["default"].prototype.getConfig.call(this),n="show"===this.properties["axisLabels.minorTickVisibility"],t=m.normalizeBoolean(this.properties["gridLines.showMinorLines"]);return s["default"].extend(!0,e,{tickInterval:this.properties.isEmpty&&"log"===this.properties["axis.scale"]?10:this.properties.isEmpty?10:parseFloat(this.properties["axisLabels.majorUnit"])||null,endOnTick:this.endOnTick,startOnTick:this.startOnTick,tickWidth:"show"===this.properties["axisLabels.majorTickVisibility"]?1:0,allowDecimals:!m.normalizeBoolean(this.properties["axisLabels.integerUnits"]),minorTickColor:this.properties["axis.foregroundColorSoft"],minorTickLength:parseInt(this.properties["axisLabels.minorTickSize"],10)||10,minorTickInterval:n||t?"auto":null,minorTickWidth:n?1:0,minorGridLineWidth:t?1:0,min:this.properties.isEmpty?0:null,max:this.properties.isEmpty&&"log"===this.properties["axis.scale"]?2:this.properties.isEmpty?100:null,gridLineWidth:m.normalizeBoolean(this.properties["gridLines.showMajorLines"],!0)?1:0,setTickIntervalPreHook:(0,h["default"])(this.setTickIntervalPreHook).bind(this),labels:{maxStaggerLines:1},lineWidth:"show"===this.properties["axisLabels.axisVisibility"]?1:0}),this.addMinAndMaxToConfig(e),e},validateNumericProperty:function(e){var n=this.properties[e];return 0===n||!!n&&!h["default"].isNaN(parseFloat(n))},addMinAndMaxToConfig:function(e){var n=this.hasExplicitMin?parseFloat(this.properties["axis.minimumNumber"]):h["default"].isUndefined(this.sharedMin)?-(1/0):this.sharedMin,t=this.hasExplicitMax?parseFloat(this.properties["axis.maximumNumber"]):h["default"].isUndefined(this.sharedMax)?1/0:this.sharedMax;if(n>t){var i=n;n=t,t=i}n>-(1/0)&&this.addMinToConfig(e,n,this.includeZero),t<1/0&&this.addMaxToConfig(e,t,this.includeZero)},addMinToConfig:function(e,n,t){t&&n>0?n=0:this.isLogScale()&&(n=y.absLogBaseTen(n)),e.min=n,e.minPadding=0,e.startOnTick=this.startOnTick},addMaxToConfig:function(e,n,t){t&&n<0?n=0:this.isLogScale()&&(n=y.absLogBaseTen(n)),e.max=n,e.maxPadding=0,e.endOnTick=this.endOnTick},getVerticalConfig:function(){var e=O["default"].prototype.getVerticalConfig.call(this),n=parseInt(this.properties["axisLabels.majorTickSize"],10)||0,t=n+6;return s["default"].extend(!0,e,{labels:{x:this.properties.opposite===!0?t:-t,y:4}})},getHorizontalConfig:function(){var e=O["default"].prototype.getHorizontalConfig.call(this),n=parseInt(this.properties["axisLabels.majorTickSize"],10)||0,t=null,i=null,r=void 0;return this.labelRotation===-45?(r="right",t=5,i=10):this.labelRotation===-90?(r="right",t=4,i=6):45===this.labelRotation?(r="left",t=0,i=10):90===this.labelRotation?(r="left",t=-4,i=6):(r="center",i=14),s["default"].extend(!0,e,{labels:{align:r,x:t,y:this.properties.opposite===!0?-6-n:i+n}})},formatLabel:function(e){if(this.isLogScale()&&"stacked100"!==this.properties.stackMode)return"auto"===this.abbreviation?w.abbreviateNumber(y.absPowerTen(e.value)):a.formatNumber(y.absPowerTen(e.value));var n=Math.max(e.axis.max,Math.abs(e.axis.min));if("auto"===this.abbreviation&&n>=1e3){var t=1===e.axis.tickPositions.length?0:this.calculateDecimal(n,e.axis.tickInterval.toString()),i=w.getSIUnit(n);return w.abbreviateByUnit(e.value,i,t)}return a.formatNumber(e.value)},calculateDecimal:function(e,n){if(!e||!n)return 0;var t=n.length-n.replace(/0+$/,"").length,i=w.getSIPower(e),r=i-t;return r<0?0:r},formatValue:function(e){var n=a.formatNumber(e);return"NaN"!==n?n:c["default"].format_decimal("0")},isLogScale:function(){return"log"===this.properties["axis.scale"]},getExtremes:function(e){var n=e.options,t=S["default"].pick(e.userMin,n.min),i=S["default"].pick(e.userMax,n.max),r=e.softThreshold,a=e.threshold,o=void 0,s=void 0;!r&&S["default"].defined(a)&&(e.dataMin>=a?o=a:e.dataMax<=a&&(s=a));var l={dataMin:e.dataMin,dataMax:e.dataMax,min:S["default"].pick(n.min,t,o,e.dataMin),max:S["default"].pick(n.max,i,s,e.dataMax)};return l},setTickIntervalPreHook:function(e){var n=e.options,t=this.getExtremes(e),i=e.chart;if(this.properties.isEmpty)this.handleNoData(n);else{var r=new u["default"](i.renderer),a=void 0,o=Math.abs(t.max-t.min);a=this.isVertical?n.tickInterval||n.tickPixelInterval/i.plotHeight*o:n.tickInterval||n.tickPixelInterval/i.plotWidth*o,this.isLogScale()?h["default"].isNumber(t.min)&&h["default"].isNumber(t.max)&&t.min>=0&&t.max<1?n.tickPositions=[0,y.absLogBaseTen(.01),y.absLogBaseTen(.1),y.absLogBaseTen(1)]:n.tickInterval=1:this.checkMajorUnitFit(a,t,n,r,i),this.includeZero?this.enforceIncludeZero(n,t):this.adjustAxisRange(n,t,a),n.allowDecimals!==!1&&this.enforceIntegerMajorUnit(n,t),r.destroy()}},checkMajorUnitFit:function(e,n,t,i,r){var a=Math.abs(n.max-n.min),o=this.isVertical?r.plotHeight:r.plotWidth,s=e*o/a,l=Math.max(Math.abs(n.min),Math.abs(n.max)),h=this.isVertical?5:15,d=parseInt(t.labels.style.fontSize.split("px")[0],10),c=function(e){return e*a/o};if(this.isVertical){var p=i.predictTextHeight(this.formatValue(l),d);s<p+2*h&&(t.tickInterval=Math.ceil(c(p+2*h)))}else{var u=i.predictTextWidth(this.formatValue(l),d)+2*h;if(s<u||s>2*u){var f=c(u),m=Math.pow(10,Math.floor(Math.log(f)/Math.LN10));t.tickInterval=this.fitTickIntervalToWidth(f,null,m,t.allowDecimals)}}},determineIncludeZero:function(){if(m.normalizeBoolean(this.properties["axis.includeZero"]))return!0;if(this.isLogScale()){var e=parseFloat(this.properties["axis.minimumNumber"]),n=parseFloat(this.properties["axis.maximumNumber"]);if((h["default"].isNaN(e)||e<=0)&&(h["default"].isNaN(n)||n>=0))return!0}return!1},enforceIncludeZero:function(e,n){return n.min||n.max?void(n.min>=0?(e.min=0,e.minPadding=0):n.max<=0&&(e.max=0,e.maxPadding=0)):void this.handleNoData(e)},adjustAxisRange:function(e,n,t){return!this.hasExplicitMin&&h["default"].isUndefined(this.sharedMin)&&delete e.min,!this.hasExplicitMax&&h["default"].isUndefined(this.sharedMax)&&delete e.max,n.dataMin||n.dataMax||this.hasExplicitMax||this.hasExplicitMin?n.min>n.dataMax&&n.min>0&&!this.hasExplicitMax?void(e.max=this.isLogScale()?n.min+2:2*n.min):n.max<n.dataMin&&n.max<0&&!this.hasExplicitMin?void(e.min=this.isLogScale()?n.max-2:2*n.max):(n.dataMin>=0&&n.dataMin<=t&&(this.hasExplicitMin||(e.min=0),e.minPadding=0),void(n.dataMax<=0&&n.dataMax>=-1*t&&(this.hasExplicitMax||(e.max=0),e.maxPadding=0))):void this.handleNoData(e)},handleNoData:function(e){var n=this.isLogScale();e.min=h["default"].isUndefined(this.sharedMin)?0:this.sharedMin,e.max=h["default"].isUndefined(this.sharedMax)?n?2:100:this.sharedMax,n&&(e.tickInterval=1)},enforceIntegerMajorUnit:function(e,n){var t=n.max-n.min;t>=10&&(e.allowDecimals=!1)},fitTickIntervalToWidth:function(e,n,t,i){var r=e/t;if(n||(n=[1,2,2.5,5,10,20],i===!1&&(1===t?n=[1,2,5,10]:t<=.1&&(n=[1/t]))),1===n.length)e=n[0];else for(var a=0;a<n.length-1;a++)if(e=n[a],r<=(n[a]+(n[a+1]||n[a]))/2){e=n[a+1];break}return e*=t,this.hasExplicitMajorUnit?Math.max(y.parseFloat(this.properties["axisLabels.majorUnit"]),e):e}}),s["default"].extend(a,{formatNumber:function(e){e=y.parseFloat(e);var n=Math.abs(e);if(n>0&&n<1e-6)return c["default"].format_scientific(e,"#.###E0");var t=y.getDecimalPrecision(e),i="#,##0.";return(0,h["default"])(t).times(function(){i+="#"}),e+=Math.pow(10,-1*t-1),c["default"].format_decimal(e,i)}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){var i=t(195);"string"==typeof i&&(i=[[e.i,i,""]]);var r,a={};a.transform=r;t(196)(i,a);i.locals&&(e.exports=i.locals)},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){u["default"].call(this,e)}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(8),d=i(h),c=t(2),p=t(29),u=i(p);(0,c.inherit)(r,u["default"]),o["default"].extend(r.prototype,{CHARTING_PROPERTY_WHITELIST:l["default"].union(["seriesSpacing"],u["default"].prototype.CHARTING_PROPERTY_WHITELIST),DEFAULT_COLUMN_SPACING:.01,DEFAULT_COLUMN_GROUP_SPACING:.05,DEFAULT_BAR_SPACING:.02,DEFAULT_BAR_GROUP_SPACING:.05,getConfig:function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];return o["default"].extend(!0,{},u["default"].prototype.getConfig.apply(this,n),{lineWidth:0,states:{hover:{lineWidthPlus:0}},drawGraphOverride:(0,l["default"])(this.drawGraphOverride).bind(this),drawTrackerOverride:(0,l["default"])(this.drawTrackerOverride).bind(this),drawPointsOverride:(0,l["default"])(this.drawPointsOverride).bind(this),getGraphPathOverride:(0,l["default"])(this.getGraphPathOverride).bind(this),getValidPointsOverride:(0,l["default"])(this.getValidPointsOverride).bind(this)})},drawGraphOverride:function(e){e.directTouch=!1,e.fillGraph=!0,d["default"].Series.prototype.drawGraph.call(e)},getValidPointsOverride:function(e,n){return d["default"].Series.prototype.getValidPoints.call(e,n,!1)},drawPointsOverride:function(){},drawTrackerOverride:function(e){e.areaPath=e.graphPath,d["default"].seriesTypes.area.prototype.drawTracker.call(e)},getGraphPathOverride:function(e){var n=[];return(0,l["default"])(e.points).each(function(e){var t=e.shapeArgs,i=t.x||0,r=t.y||0,a=t.width||0,o=t.height||0;n.push("M",i,r,"L",i+a,r,"L",i+a,r+o,"L",i,r+o,"Z")}),e.graphPath=n,n},destroy:function(){this.unSelectPoint(),u["default"].prototype.destroy.call(this)},handlePointMouseOver:function(e){u["default"].prototype.handlePointMouseOver.call(this,e),this.unHighlight(),this.selectPoint(e)},handlePointMouseOut:function(e){u["default"].prototype.handlePointMouseOut.call(this,e),this.highlight(),this.unSelectPoint()},highlight:function(){if(u["default"].prototype.highlight.call(this),this.hcSeries&&this.hcSeries.graph){var e=this.getColor();this.hcSeries.graph.attr({fill:e,"stroke-width":0})}},unHighlight:function(){u["default"].prototype.unHighlight.call(this),this.unSelectPoint(),this.hcSeries.graph&&this.hcSeries.graph.attr({fill:this.UNHIGHLIGHTED_COLOR,stroke:this.UNHIGHLIGHTED_BORDER_COLOR,"stroke-width":1})},selectPoint:function(e){var n=this.hcSeries.data[e.index],t=n.shapeArgs,i=this.hcSeries.chart.renderer,r=this.hcSeries.group;this.selectedPointGraphic=i.rect(t.x,t.y,t.width,t.height).attr({fill:this.getColor(),zIndex:1}).add(r)},unSelectPoint:function(){this.selectedPointGraphic&&(this.selectedPointGraphic.destroy(),this.selectedPointGraphic=null)},computeColumnSpacing:function(e){var n=parseFloat(e);return(0,l["default"])(n).isNaN()?this.DEFAULT_COLUMN_SPACING:n*this.DEFAULT_COLUMN_SPACING},computeColumnGroupSpacing:function(e){var n=parseFloat(e);return(0,l["default"])(n).isNaN()?this.DEFAULT_COLUMN_GROUP_SPACING:this.DEFAULT_COLUMN_GROUP_SPACING*(1+n)},computeBarSpacing:function(e){var n=parseFloat(e);return(0,l["default"])(n).isNaN()?this.DEFAULT_BAR_SPACING:n*this.DEFAULT_BAR_SPACING},computeBarGroupSpacing:function(e){var n=parseFloat(e);return(0,l["default"])(n).isNaN()?this.DEFAULT_BAR_GROUP_SPACING:this.DEFAULT_BAR_GROUP_SPACING*(1+n)}}),n["default"]=r,e.exports=n["default"]},function(e,n){e.exports={}},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,n){M["default"].call(this,e,n),this.$hcContainer=(0,s["default"])("<div />").addClass("highcharts-container").appendTo(this.container),this.elements={},this.hasRendered=!1,this.needsRedraw=!0}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(8),c=r(d),p=t(12),u=r(p),f=t(10),m=r(f),g=t(2),x=t(3),b=i(x),y=t(89),v=i(y),w=t(4),k=i(w),S=t(7),T=i(S),O=t(90),M=r(O),P=t(45),A=r(P),L=t(22);(0,g.inherit)(a,M["default"]),s["default"].extend(a.prototype,{WINDOW_RESIZE_DELAY:100,EXPORT_HEIGHT:400,EXPORT_WIDTH:600,MIN_GAUGE_HEIGHT:25,RESIZED_GAUGE_HEIGHT:200,DEFAULT_COLORS:[T.hexFromColor(L.COLORS.SEMANTIC_SUCCESS),T.hexFromColor(L.COLORS.SEMANTIC_WARNING),T.hexFromColor(L.COLORS.SEMANTIC_ERROR)],DEFAULT_RANGES:[0,30,70,100],MAX_TICKS_PER_RANGE:10,showValueByDefault:!0,showMinorTicksByDefault:!0,getFieldList:function(){return[]},getWidth:function(){var e=M["default"].prototype.getWidth.call(this);return this.exportMode?e||this.EXPORT_WIDTH:e},getHeight:function(){var e=M["default"].prototype.getHeight.call(this);return this.exportMode?e||this.EXPORT_HEIGHT:e=e<this.MIN_GAUGE_HEIGHT?this.RESIZED_GAUGE_HEIGHT:e},prepare:function(e,n){var t=s["default"].extend([],this.ranges);M["default"].prototype.prepare.call(this,e,n),b.arraysAreEquivalent(t,this.ranges)||(this.needsRedraw=!0)},handleDraw:function(e){this.needsRedraw?(this.teardownGauge(),this.renderer=new c["default"].Renderer(this.$hcContainer[0],this.getWidth(),this.getHeight()),this.renderer.setStyle({fontFamily:L.FONT_FAMILY,fontSize:L.FONT_SIZE}),this.formatter=new m["default"](this.renderer),this.$container.css("backgroundColor",this.backgroundColor),this.renderGauge(),this.hasRendered=!0,this.testMode&&(v.gaugeAddTestingMetadata(this,this.elements,this.getClassName(),this.value),v.createGlobalReference(this,this.getChartObject())),this.needsRedraw=!1,this.cacheDrawnDimensions()):this.updateValue(this.previousValue||0,this.value),e(this)},setSize:function(e,n){this.hasRendered&&(this.teardownGauge(),this.renderer=new c["default"].Renderer(this.$hcContainer[0],e,n),this.formatter=new m["default"](this.renderer),this.renderGauge(),this.testMode&&v.gaugeAddTestingMetadata(this,this.elements,this.getClassName(),this.value),this.hasRendered=!0,this.cacheDrawnDimensions())},destroy:function(){this.teardownGauge(),this.$hcContainer.remove()},teardownGauge:function(){var e=void 0;this.stopWobble(),this.$container.stop();for(e in this.elements)this.elements.hasOwnProperty(e)&&this.elements[e].destroy();this.renderer&&this.renderer.destroy(),this.formatter&&this.formatter.destroy(),this.elements={},this.$hcContainer.empty(),this.$container.css("backgroundColor",""),this.hasRendered=!1},getSVG:function(){return this.$container.find("svg").eq(0).parent().html()},processProperties:function(){M["default"].prototype.processProperties.call(this),this.colors=this.computeColors(),this.colorPalette=new A["default"](this.colors,(!0)),this.ranges=this.computeRanges(),this.previousValue=this.value,this.value=this.computeValue(),this.majorUnit=parseInt(this.properties["chart.majorUnit"],10)||null,this.showMajorTicks=b.normalizeBoolean(this.properties["chart.showMajorTicks"],!0),this.showMinorTicks=b.normalizeBoolean(this.properties["chart.showMinorTicks"],this.showMinorTicksByDefault),this.showLabels=b.normalizeBoolean(this.properties["chart.showLabels"],!0),this.showValue=b.normalizeBoolean(this.properties["chart.showValue"],this.showValueByDefault),this.showRangeBand=b.normalizeBoolean(this.properties["chart.showRangeBand"],!0),this.usePercentageRange=b.normalizeBoolean(this.properties["chart.usePercentageRange"]),this.usePercentageValue=b.normalizeBoolean(this.properties["chart.usePercentageValue"]),this.isShiny="minimal"!==this.properties["chart.style"]},computeColors:function(){var e=b.stringToHexArray(this.properties["chart.gaugeColors"]||this.properties.gaugeColors);return e&&e.length>0?e:this.DEFAULT_COLORS},computeRanges:function(){var e=this,n=void 0,t=b.stringToArray(this.properties["chart.rangeValues"]);if(t&&t.length>1)n=t;else{var i=this.dataSet.allDataFields();n=(0,h["default"])(i.slice(1)).map(function(n){return e.dataSet.getSeries(n)[0]})}var r=-(1/0),a=[];return(0,h["default"])(n).each(function(e){var n=k.parseFloat(e);!(0,h["default"])(n).isNaN()&&n>r&&(a.push(n),r=n)}),a.length>1?a:this.DEFAULT_RANGES},computeValue:function(){var e=this.dataSet.allDataFields();return e.length>0?k.parseFloat(this.dataSet.getSeries(e[0])[0])||0:0},updateValue:function(e,n){if(e!==n){if(this.shouldAnimateTransition(e,n)&&(this.stopWobble(),this.animateTransition(e,n,(0,h["default"])(this.drawIndicator).bind(this),(0,h["default"])(this.onAnimationFinished).bind(this))),this.showValue){var t=this.formatValue(n);this.updateValueDisplay(t)}this.testMode&&v.gaugeUpdate(this.$container,n)}},shouldAnimateTransition:function(e,n){return this.normalizedTranslateValue(e)!==this.normalizedTranslateValue(n)},drawTicks:function(){var e=void 0,n=void 0,t=void 0,i=this.calculateTickValues(this.ranges[0],this.ranges[this.ranges.length-1],this.MAX_TICKS_PER_RANGE);for(e=0;e<i.length;e++)n=this.translateValue(i[e]),this.showMajorTicks&&(this.elements["tickMark_"+i[e]]=this.drawMajorTick(n)),this.showLabels&&(t=this.formatTickLabel(i[e]),this.elements["tickLabel_"+i[e]]=this.drawMajorTickLabel(n,t));if(this.showLabels&&(i=this.removeTicksIfOverlap(i)),this.showMinorTicks){var r=i[1]-i[0],a=r/this.minorsPerMajor,o=this.usePercentageRange?this.ranges[0]:i[0]-Math.floor((i[0]-this.ranges[0])/a)*a;for(e=o;e<=this.ranges[this.ranges.length-1];e+=a)(!this.showMajorTicks||s["default"].inArray(e,i)<0)&&(n=this.translateValue(e),this.elements["minorTickMark_"+e]=this.drawMinorTick(n))}},removeTicksIfOverlap:function(e){for(;e.length>2&&this.tickLabelsOverlap(e);)e=this.removeEveryOtherTick(e);return e},tickLabelsOverlap:function(e){var n=void 0,t=void 0,i=void 0,r=3,a=1,o=this.renderer,s=function(e){return e.bBox?e.bBox:(o.cache={},e.getBBox())};for(n=0;n<e.length-1;n++)if(t=this.elements["tickLabel_"+e[n]],i=this.elements["tickLabel_"+e[n+1]],this.formatter.bBoxesOverlap(s(t),s(i),r,a))return!0;return!1},removeEveryOtherTick:function(e){var n=void 0,t=[];for(n=0;n<e.length;n++)n%2===0?t.push(e[n]):(this.elements["tickMark_"+e[n]]&&(this.elements["tickMark_"+e[n]].destroy(),delete this.elements["tickMark_"+e[n]]),this.elements["tickLabel_"+e[n]]&&(this.elements["tickLabel_"+e[n]].destroy(),delete this.elements["tickLabel_"+e[n]]));return t},animateTransition:function(e,n,t,i){var r=n-e,a=500,o={duration:a,step:function(n){t(e+n)}};i&&(o.complete=function(){i(n)}),this.$container.stop(!0,!0).css({"animation-progress":0}).animate({"animation-progress":r},o)},onAnimationFinished:function(e){this.checkOutOfRange(e)},checkOutOfRange:function(e){var n=void 0,t=void 0,i=void 0;e<this.ranges[0]?(n=this.ranges[this.ranges.length-1]-this.ranges[0],i=.005*n,t=this.ranges[0]+i,this.wobble(t,i,this.drawIndicator)):e>this.ranges[this.ranges.length-1]&&(n=this.ranges[this.ranges.length-1]-this.ranges[0],i=.005*n,t=this.ranges[this.ranges.length-1]-i,this.wobble(t,i,this.drawIndicator))},formatValue:function(e){return this.usePercentageValue?this.formatPercent((e-this.ranges[0])/(this.ranges[this.ranges.length-1]-this.ranges[0])):this.formatNumber(e)},formatTickLabel:function(e){return this.usePercentageRange?this.formatPercent((e-this.ranges[0])/(this.ranges[this.ranges.length-1]-this.ranges[0])):this.formatNumber(e)},formatNumber:function(e){var n=parseFloat(e),t=Math.abs(n);return t>=1e9||0!==t&&t<.001?u["default"].format_scientific(n,"#.###E0"):u["default"].format_decimal(n)},formatPercent:function(e){return u["default"].format_percent(e)},wobble:function(e,n,t){var i=this,r=0;this.wobbleInterval=setInterval(function(){var a=e+(r%3-1)*n;t.call(i,a),r=(r+1)%3},75)},stopWobble:function(){clearInterval(this.wobbleInterval)},predictTextWidth:function(e,n){return this.formatter.predictTextWidth(e,n)},calculateTickValues:function(e,n,t){var i=void 0,r=void 0,a=n-e,o=a/(t-1),s=k.nearestPowerOfTen(o),l=[];if(this.usePercentageRange)for(s=this.majorUnit&&!isNaN(this.majorUnit)?Math.abs(this.majorUnit):10,i=0;i<=100;i+=s)l.push(e+i/100*a);else for(this.majorUnit&&!isNaN(this.majorUnit)?s=Math.abs(this.majorUnit):(a/s>t&&(s*=2),a/s>t&&(s*=2.5),a/s>t&&(s*=2)),r=this.usePercentageRange?e:e>=0?0:e-e%s,i=r;i<=n;i+=s)i>=e&&l.push(parseFloat(i.toFixed(14)));return l},getColorByIndex:function(e){return T.colorFromHex(this.colorPalette.getColor(null,e,this.ranges.length-1))},getChartObject:function(){return{series:[{data:[{y:this.value,onMouseOver:function(){}}]}]}},renderGauge:function(){this.updateDimensions()},translateValue:function(){},normalizedTranslateValue:function(){}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){var i=t(109);e.exports=function(e,n,t){if(i(e),void 0===n)return e;switch(t){case 1:return function(t){return e.call(n,t)};case 2:return function(t,i){return e.call(n,t,i)};case 3:return function(t,i,r){return e.call(n,t,i,r)}}return function(){return e.apply(n,arguments)}}},function(e,n,t){var i=t(31),r=t(13).document,a=i(r)&&i(r.createElement);e.exports=function(e){return a?r.createElement(e):{}}},function(e,n,t){var i=t(113),r=t(63);e.exports=Object.keys||function(e){return i(e,r)}},function(e,n,t){var i=t(58),r=t(34);e.exports=function(e){return i(r(e))}},function(e,n,t){var i=t(59);e.exports=Object("z").propertyIsEnumerable(0)?Object:function(e){return"String"==i(e)?e.split(""):Object(e)}},function(e,n){var t={}.toString;e.exports=function(e){return t.call(e).slice(8,-1)}},function(e,n,t){var i=t(35),r=Math.min;e.exports=function(e){return e>0?r(i(e),9007199254740991):0}},function(e,n,t){var i=t(13),r="__core-js_shared__",a=i[r]||(i[r]={});e.exports=function(e){return a[e]||(a[e]={})}},function(e,n){var t=0,i=Math.random();e.exports=function(e){return"Symbol(".concat(void 0===e?"":e,")_",(++t+i).toString(36))}},function(e,n){e.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(e,n){e.exports=t(584)},function(e,n,t){function i(e){return"function"==typeof e?e:r}var r=t(23);e.exports=i},function(e,n,t){var i=t(127),r=t(71),a=r(i);e.exports=a},function(e,n,t){function i(e,n){var t=a(e,n);return r(t)?t:void 0}var r=t(130),a=t(137);e.exports=i},function(e,n,t){function i(e){if(!a(e))return!1;var n=r(e);return n==s||n==l||n==o||n==h}var r=t(24),a=t(14),o="[object AsyncFunction]",s="[object Function]",l="[object GeneratorFunction]",h="[object Proxy]";e.exports=i},function(e,n,t){var i=t(6),r=i.Symbol;e.exports=r},function(e,n,t){(function(n){var t="object"==typeof n&&n&&n.Object===Object&&n;e.exports=t}).call(n,t(131))},function(e,n){function t(e){var n=0,t=0;return function(){var o=a(),s=r-(o-t);if(t=o,s>0){if(++n>=i)return arguments[0]}else n=0;return e.apply(void 0,arguments)}}var i=800,r=16,a=Date.now;e.exports=t},function(e,n,t){var i=t(23),r=t(73),a=r?function(e,n){return r.set(e,n),e}:i;e.exports=a},function(e,n,t){var i=t(139),r=i&&new i;e.exports=r},function(e,n,t){function i(e,n,t,y,v,w,k,S,T,O){function M(){for(var u=arguments.length,f=Array(u),m=u;m--;)f[m]=arguments[m];if(_)var g=h(M),x=o(f,g);if(y&&(f=r(f,y,v,_)),w&&(f=a(f,w,k,_)),u-=x,_&&u<O){var b=c(f,g);return l(e,n,i,M.placeholder,t,f,b,S,T,O-u)}var I=A?t:this,D=L?I[e]:e;return u=f.length,S?f=d(f,S):C&&u>1&&f.reverse(),P&&T<u&&(f.length=T),this&&this!==p&&this instanceof M&&(D=H||s(D)),D.apply(I,f)}var P=n&x,A=n&u,L=n&f,_=n&(m|g),C=n&b,H=L?void 0:s(e);return M}var r=t(75),a=t(76),o=t(142),s=t(25),l=t(77),h=t(43),d=t(157),c=t(26),p=t(6),u=1,f=2,m=8,g=16,x=128,b=512;e.exports=i},function(e,n){function t(e,n,t,r){for(var a=-1,o=e.length,s=t.length,l=-1,h=n.length,d=i(o-s,0),c=Array(h+d),p=!r;++l<h;)c[l]=n[l];for(;++a<s;)(p||a<o)&&(c[t[a]]=e[a]);for(;d--;)c[l++]=e[a++];return c}var i=Math.max;e.exports=t},function(e,n){function t(e,n,t,r){for(var a=-1,o=e.length,s=-1,l=t.length,h=-1,d=n.length,c=i(o-l,0),p=Array(c+d),u=!r;++a<c;)p[a]=e[a];for(var f=a;++h<d;)p[f+h]=n[h];for(;++s<l;)(u||a<o)&&(p[f+t[s]]=e[a++]);return p}var i=Math.max;e.exports=t},function(e,n,t){function i(e,n,t,i,u,f,m,g,x,b){var y=n&d,v=y?m:void 0,w=y?void 0:m,k=y?f:void 0,S=y?void 0:f;n|=y?c:p,n&=~(y?p:c),n&h||(n&=~(s|l));var T=[e,n,u,k,v,S,w,g,x,b],O=t.apply(void 0,T);return r(e)&&a(O,T),O.placeholder=i,o(O,e,n)}var r=t(143),a=t(81),o=t(82),s=1,l=2,h=4,d=8,c=32,p=64;e.exports=i},function(e,n,t){var i=t(73),r=t(144),a=i?function(e){return i.get(e)}:r;e.exports=a},function(e,n,t){function i(e,n){this.__wrapped__=e,this.__actions__=[],this.__chain__=!!n,this.__index__=0,this.__values__=void 0}var r=t(39),a=t(41);i.prototype=r(a.prototype),i.prototype.constructor=i,e.exports=i},function(e,n){function t(e,n){var t=-1,i=e.length;for(n||(n=Array(i));++t<i;)n[t]=e[t];return n}e.exports=t},function(e,n,t){var i=t(72),r=t(71),a=r(i);e.exports=a},function(e,n,t){function i(e,n,t){var i=n+"";return o(e,a(i,s(r(i),t)))}var r=t(149),a=t(150),o=t(66),s=t(151);e.exports=i},function(e,n){function t(e,n){for(var t=-1,i=null==e?0:e.length;++t<i&&n(e[t],t,e)!==!1;);return e}e.exports=t},function(e,n){function t(e,n){return n=null==n?i:n,!!n&&("number"==typeof e||r.test(e))&&e>-1&&e%1==0&&e<n}var i=9007199254740991,r=/^(?:0|[1-9]\d*)$/;e.exports=t},function(e,n){function t(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=i}var i=9007199254740991;e.exports=t},function(e,n,t){function i(e){return null!=e&&a(e.length)&&!r(e)}var r=t(68),a=t(85);e.exports=i},function(e,n){e.exports=t(583)},function(e,n){e.exports=t(585)},function(e,n){e.exports=t(586)},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e,n){this.container=e,this.$container=(0,o["default"])(e),this.properties=o["default"].extend(!0,{},n),this.id=l["default"].uniqueId("viz_"),this._isDirty=!1,this.updateDimensions(),this.lastDrawnWidth=null,this.lastDrawnHeight=null,this.benchmarks=[]}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(7),d=t(3),c=t(9),p=i(c),u=t(5);r.prototype=o["default"].extend({},p["default"],{requiresExternalColors:!1,getWidth:function(){return this.$container.width()},getHeight:function(){return this.$container.height()},getCurrentDisplayProperties:function(){return this.properties},isDirty:function(){return this._isDirty},updateDimensions:function(){this.width=this.getWidth(),this.height=this.getHeight()},cacheDrawnDimensions:function(){this.lastDrawnWidth=this.width,this.lastDrawnHeight=this.height},getClassName:function(){return this.type+"-chart"},prepare:function(e,n){var t=o["default"].extend(!0,{},this.properties);n&&(o["default"].extend(!0,this.properties,n),l["default"].isEqual(this.properties,t)||(this._isDirty=!0)),this.dataSet=e,this.updateDimensions(),this.processProperties()},draw:function(e){var n=this,t=o["default"].Deferred();return this.handleDraw(function(){n._isDirty=!1,e&&e.apply(void 0,arguments),t.resolve.apply(t,arguments)}),t},prepareAndDraw:function(e,n,t){return this.prepare(e,n),this.draw(t)},requiresExternalColorPalette:function(){return this.requiresExternalColors},processProperties:function(){this.type=this.properties.chart||"column",this.backgroundColor=this.properties["chart.backgroundColor"]||this.properties.backgroundColor||(0,u.getThemeProperty)("DEFAULT_BACKGROUND_COLOR"),this.foregroundColor=this.properties["chart.foregroundColor"]||this.properties.foregroundColor||(0,u.getThemeProperty)("DEFAULT_FOREGROUND_COLOR"),this.fontColor=this.properties["chart.fontColor"]||this.properties.fontColor||(0,u.getThemeProperty)("DEFAULT_FONT_COLOR"),this.foregroundColorSoft=(0,h.addAlphaToColor)(this.foregroundColor,.25),this.foregroundColorSofter=(0,h.addAlphaToColor)(this.foregroundColor,.15),this.properties["chart.foregroundColor"]||this.properties.foregroundColor?(this.axisColorSoft=this.foregroundColorSoft,this.axisColorSofter=this.foregroundColorSofter):(this.axisColorSoft=(0,u.getThemeProperty)("DEFAULT_LINE_COLOR_SOFT"),this.axisColorSofter=(0,u.getThemeProperty)("DEFAULT_LINE_COLOR_SOFTER")),this.testMode=(0,d.normalizeBoolean)(this.properties["chart.testMode"])||(0,d.normalizeBoolean)(this.properties.testMode),this.exportMode=(0,d.normalizeBoolean)(this.properties["chart.exportMode"])||(0,d.normalizeBoolean)(this.properties.exportMode)},resize:function(){this.updateDimensions(),this.width&&this.height&&(this.width!==this.lastDrawnWidth||this.height!==this.lastDrawnHeight)&&this.setSize(this.width,this.height);
},handleDraw:function(){},destroy:function(){},getSVG:function(){},benchmark:function(e){if(this.testMode)if(0===this.benchmarks.length)this.benchmarks.push([e,(new Date).getTime()]);else{var n=(0,l["default"])(this.benchmarks).reduce(function(e,n){return e+n[1]},0);this.benchmarks.push([e,(new Date).getTime()-n])}}}),n["default"]=r,e.exports=n["default"]},function(e,n){e.exports=t(587)},function(e,n){e.exports='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1500 1500" width="10px" height="9px"><path d="M 750 0 c 203 0 397 82 532 218 136 135 218 329 218 532 0 210 -82 393 -218 529 -135 135 -329 221 -532 221 -210 0 -393 -86 -529 -221 C 86 1143 0 960 0 750 c 0 -203 86 -397 221 -532 C 357 82 540 0 750 0 z m 567 896 V 604 H 184 v 292 h 1133 z" fill="currentColor"></path></svg>'},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){return this.properties=e||{},this}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(9),l=i(s);r.prototype=o["default"].extend({},l["default"],{getConfig:function(){return{enabled:!0}}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){f["default"].call(this,e)}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(2),c=t(3),p=i(c),u=t(95),f=r(u);(0,d.inherit)(a,f["default"]),s["default"].extend(a.prototype,{CHARTING_PROPERTY_WHITELIST:h["default"].union(["showMarkers"],f["default"].prototype.CHARTING_PROPERTY_WHITELIST),type:"line",highlight:function(){if(f["default"].prototype.highlight.call(this),this.hcSeries.graph){var e=this.getColor();this.hcSeries.graph.attr({stroke:e,"stroke-opacity":this.HIGHLIGHTED_OPACITY})}(0,h["default"])(this.hcSeries.data).each(this.highlightPoint,this)},unHighlight:function(){f["default"].prototype.unHighlight.call(this),this.hcSeries.graph&&this.hcSeries.graph.attr("stroke",this.UNHIGHLIGHTED_COLOR),(0,h["default"])(this.hcSeries.data).each(this.unHighlightPoint,this)},highlightPoint:function(e){var n=this.getColor();e.graphic&&e.graphic.attr("fill",n)},unHighlightPoint:function(e){e.graphic&&e.graphic.attr("fill",this.UNHIGHLIGHTED_COLOR)},translatePostHook:function(){if(this.hcSeries){var e=this.hcSeries.chart,n=this.hcSeries.xAxis,t=this.hcSeries.points;if(Math.round(n.min)===Math.round(n.max)&&"line"===this.hcSeries.options.type){var i=h["default"].any(e.series,function(e){return"column"===e.options.type});if(i){var r=Math.round(n.min);t[r-1]&&(t[r-1].plotX=t[r].plotX-n.width),t[r+1]&&(t[r+1].plotX=t[r].plotX+n.width)}}}},getConfig:function(){var e=this.getName(),n=p.stringToObject(this.properties.fieldDashStyles||"{}"),t=f["default"].prototype.getConfig.call(this);return s["default"].extend(t,{connectNulls:"connect"===this.properties.nullValueMode,marker:{enabled:p.normalizeBoolean(this.properties.showMarkers,!1)},stacking:this.STACK_MODE_MAP["default"],zIndex:2,translatePostHook:(0,h["default"])(this.translatePostHook).bind(this),dashStyle:n.hasOwnProperty(e)?n[e]:this.properties.dashStyle,lineWidth:parseFloat(this.properties.lineWidth)||2}),t}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){c["default"].call(this,e)}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(2),d=t(29),c=i(d);(0,h.inherit)(r,c["default"]),o["default"].extend(r.prototype,{CHARTING_PROPERTY_WHITELIST:l["default"].union(["lineStyle","nullValueMode"],c["default"].prototype.CHARTING_PROPERTY_WHITELIST),HIGHLIGHTED_OPACITY:1,getConfig:function(){var e=c["default"].prototype.getConfig.call(this);return e.dashStyle="dashed"===this.properties.lineStyle?"Dash":"Solid",e.pointPlacement=this.properties.pointPlacement,e.drawPointsPreHook=(0,l["default"])(this.drawPointsPreHook).bind(this),e},handlePointMouseOver:function(e){c["default"].prototype.handlePointMouseOver.call(this,e),this.highlight()},drawPointsPreHook:function(e){if(!("zero"===this.properties.nullValueMode||e.options.marker&&e.options.marker.enabled))if(e.options.connectNulls){var n=l["default"].filter(e.data,function(e){return!e.isNull});1===n.length&&n[0].update({marker:{enabled:!0,radius:4}},!1)}else e.data.forEach(function(n,t){if(!n.isNull){var i=e.data[t-1],r=e.data[t+1];i&&!i.isNull||r&&!r.isNull||n.update({marker:{enabled:!0,radius:4}},!1)}})}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){b["default"].call(this,e),this.UNHIGHLIGHTED_LINE_COLOR=p.addAlphaToColor(this.UNHIGHLIGHTED_BASE_COLOR,this.UNHIGHLIGHTED_LINE_OPACITY)}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(2),c=t(7),p=i(c),u=t(3),f=i(u),m=t(4),g=i(m),x=t(95),b=r(x);(0,d.inherit)(a,b["default"]),s["default"].extend(a.prototype,{HIGHLIGHTED_OPACITY:.75,UNHIGHLIGHTED_LINE_OPACITY:.4,CHARTING_PROPERTY_WHITELIST:h["default"].union(["showLines","areaFillOpacity"],b["default"].prototype.CHARTING_PROPERTY_WHITELIST),type:"area",processProperties:function(){var e=g.parseFloat(this.properties.areaFillOpacity);this.fillOpacity=e<=1&&e>=0?e:this.HIGHLIGHTED_OPACITY},getConfig:function(){var e=b["default"].prototype.getConfig.call(this);return e.fillOpacity=this.fillOpacity,e.connectNulls="connect"===this.properties.nullValueMode,e.lineWidth=f.normalizeBoolean(this.properties.showLines,!0)?1:0,e.getStackPointsPreHook=(0,h["default"])(this.getStackPointsPreHook).bind(this),e.setStackedPointsPostHook=(0,h["default"])(this.setStackedPointsPostHook).bind(this),e},onChartLoadOrRedraw:function(e){b["default"].prototype.onChartLoadOrRedraw.call(this,e),this.hasLines=this.hcSeries.options.lineWidth>0,this.hcSeries.area.attr("fill-opacity",this.fillOpacity)},highlight:function(){b["default"].prototype.highlight.call(this);var e=this.getColor();this.hcSeries.area.attr({fill:e,"fill-opacity":this.fillOpacity}),this.hcSeries.graph&&this.hasLines&&this.hcSeries.graph.attr({stroke:e,"stroke-opacity":1}),(0,h["default"])(this.hcSeries.data).each(this.highlightPoint,this)},unHighlight:function(){b["default"].prototype.unHighlight.call(this),this.hcSeries.area.attr({fill:this.UNHIGHLIGHTED_COLOR}),this.hcSeries.graph&&this.hasLines&&this.hcSeries.graph.attr("stroke",this.UNHIGHLIGHTED_LINE_COLOR),(0,h["default"])(this.hcSeries.data).each(this.unHighlightPoint,this)},highlightPoint:function(e){var n=this.getColor();e.graphic&&e.graphic.attr("fill",n)},unHighlightPoint:function(e){e.graphic&&e.graphic.attr("fill",this.UNHIGHLIGHTED_COLOR)},getStackPointsPreHook:function(e,n){return n=n||e.points,e.options.stacking&&n.forEach(function(e){e.leftNull=null,e.rightNull=null}),n},setStackedPointsPostHook:function(e){if(void 0!==e.yAxis&&void 0!==e.yAxis.stacks&&void 0!==e.yAxis.stacks.area){var n=e.yAxis.stacks.area,t=e.processedYData,i=[];if(t.forEach(function(e,n){null===e&&i.push(n)}),0!==i.length){var r=e.processedXData,a=void 0;i.forEach(function(t){var i=r[t];a=e.getStackIndicator(a,i,e.index);var o=n[i];o.points[a.key]=null,o.points[e.index]=null})}}}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){c["default"].call(this,e)}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(2),d=t(29),c=i(d);(0,h.inherit)(r,c["default"]),o["default"].extend(r.prototype,{CHARTING_PROPERTY_WHITELIST:l["default"].union(["seriesSpacing"],c["default"].prototype.CHARTING_PROPERTY_WHITELIST),destroy:function(){this.unSelectPoint(),c["default"].prototype.destroy.call(this)},handlePointMouseOver:function(e){c["default"].prototype.handlePointMouseOver.call(this,e),this.selectPoint(e)},handlePointMouseOut:function(e){c["default"].prototype.handlePointMouseOut.call(this,e),this.unSelectPoint(e)},selectPoint:function(e){var n=this.hcSeries.data[e.index];this.highlightPoint(n),(0,l["default"])(this.hcSeries.data).chain().without(n).each(this.unHighlightPoint,this)},unSelectPoint:function(e){if(e){var n=this.hcSeries.data[e.index];(0,l["default"])(this.hcSeries.data).chain().without(n).each(this.highlightPoint,this)}},highlight:function(){c["default"].prototype.highlight.call(this),(0,l["default"])(this.hcSeries.data).each(this.highlightPoint,this)},unHighlight:function(){c["default"].prototype.unHighlight.call(this),(0,l["default"])(this.hcSeries.data).each(this.unHighlightPoint,this)},highlightPoint:function(e){if(e.graphic){var n=this.getColor();e.graphic.attr({fill:n,"fill-opacity":this.HIGHLIGHTED_OPACITY,stroke:n})}},unHighlightPoint:function(e){e.graphic&&e.graphic.attr({fill:this.UNHIGHLIGHTED_COLOR,"stroke-width":1,stroke:this.UNHIGHLIGHTED_BORDER_COLOR})}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){m["default"].call(this,e)}Object.defineProperty(n,"__esModule",{value:!0});var a=t(99),o=i(a),s=t(0),l=i(s),h=t(1),d=i(h),c=t(8),p=i(c),u=t(2),f=t(51),m=i(f);(0,u.inherit)(r,m["default"]),l["default"].extend(r.prototype,{type:"scatter",getConfig:function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];var i=m["default"].prototype.getConfig.apply(this,n);return i.renderPostHook=(0,d["default"])(this.renderPostHook).bind(this),i},getGraphPathOverride:function(e){var n=e.chart,t=[];return(0,d["default"])(e.points).each(function(i){var r=Math.floor(i.plotX),a=i.plotY;if(!d["default"].isUndefined(a)&&!isNaN(a)&&null!==i.y){var s=i.marker||{},l=n.isInsidePlot(r,a,n.inverted),h=e.markerAttribs(i,i.selected?"select":void 0),c=h.width,u=p["default"].pick(s.symbol,e.symbol);if(l&&c>0){var f=n.renderer.symbols[u](r-c/2,a-c/2,c,c);t.push.apply(t,(0,o["default"])(f))}}}),e.graphPath=t,t},renderPostHook:function(e){e.group&&e.group.toFront()},selectPoint:function(e){var n=this.hcSeries.data[e.index],t=n.series;t.stateMarkerGraphic&&(this.selectedPointGraphic=t.stateMarkerGraphic,t.stateMarkerGraphic=null,(0,l["default"])(this.selectedPointGraphic.element).insertBefore(t.tracker.element))},getTooltipRows:function(e){var n=[];return e.isMultiSeries&&n.push([e.labelSeriesName,{text:e.seriesName,color:e.seriesColor}]),e.markName&&n.push([e.markName,e.markValue]),n.push([e.xAxisName,e.xValue],[e.yAxisName,e.yValue]),n}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}n.__esModule=!0;var r=t(207),a=i(r);n["default"]=function(e){if(Array.isArray(e)){for(var n=0,t=Array(e.length);n<e.length;n++)t[n]=e[n];return t}return(0,a["default"])(e)}},function(e,n,t){var i=t(18).f,r=t(21),a=t(11)("toStringTag");e.exports=function(e,n,t){e&&!r(e=t?e:e.prototype,a)&&i(e,a,{configurable:!0,value:n})}},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,n){f["default"].call(this,e,n),this.properties["chart.nullValueMode"]="zero"}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(2),c=t(3),p=i(c),u=t(27),f=r(u),m=t(49),g=r(m);(0,d.inherit)(a,f["default"]),s["default"].extend(a.prototype,{NUM_DIMENSION_FIELDS:2,TYPE:"scatter",initializeFields:function(){f["default"].prototype.initializeFields.call(this);var e=this.dataSet.allDataFields();this.dataSet.fieldIsGroupby(e[0])&&(this.markField=e[0],e=e.slice(1)),this.initializeNonMarkFields(e)},initializeNonMarkFields:function(e){e.length>this.NUM_DIMENSION_FIELDS?(this.isMultiSeries=!0,this.labelField=e[0],this.xField=e[1],this.yField=e[2],this.hasLegend="none"!==this.properties["legend.placement"]):(this.isMultiSeries=!1,this.xField=e[0],this.yField=e[1],this.hasLegend=!1)},initializeDataLabels:function(){},isEmpty:function(){return(0,h["default"])(this.xField).isUndefined()||(0,h["default"])(this.yField).isUndefined()},hasTimeXAxis:function(){return!1},initializeSeriesPropertiesList:function(){var e=this,n=void 0;if(this.isMultiSeries)n=(0,h["default"])(this.dataSet.getSeries(this.labelField)).chain().uniq().compact().map(function(n){return{name:n,type:e.TYPE,clickEnabled:e.chartClickEnabled}}).value();else{var t={name:h["default"].uniqueId(this.TYPE+"_field_"),type:this.TYPE,clickEnabled:this.chartClickEnabled};n=[t]}return n},initializeXAxisList:function(){var e=s["default"].extend(p.getXAxisProperties(this.properties),this.axisColorScheme,{"axis.orientation":"horizontal",isEmpty:this.isEmpty()});e["axisTitle.text"]=this._getComputedXAxisTitle(e,this.xField),e["gridLines.showMajorLines"]=!1,this.xAxisList=[new g["default"](e)]},initializeYAxisList:function(){var e=s["default"].extend(p.getYAxisProperties(this.properties),this.axisColorScheme,{"axis.orientation":"vertical",isEmpty:this.isEmpty()});e["axisTitle.text"]=this._getComputedYAxisTitle(e,null),this.yAxisList=[new g["default"](e)]},setAllSeriesData:function(){var e=this,n=this.formatNumericAxisData(this.xAxisList[0],this.xField),t=this.formatNumericAxisData(this.yAxisList[0],this.yField);this.isMultiSeries?(0,h["default"])(this.seriesList).each(function(i){var r=i.getName();i.setData({x:e.filterDataByNameMatch(n,r),y:e.filterDataByNameMatch(t,r)})}):this.seriesList[0].setData({x:n,y:t})},_getDefaultYAxisTitle:function(){return this.yField},_getDefaultXAxisTitleFromField:function(){return this.xField},getPlotOptionsConfig:function(){var e=parseInt(this.properties["chart.markerSize"],10);return{scatter:{stickyTracking:!1,fillOpacity:1,trackByArea:!0,marker:{radius:e?Math.ceil(6*e/4):6,symbol:"square"},tooltip:{followPointer:!1},cursor:this.chartClickEnabled?"pointer":"default"}}},handlePointClick:function(e,n,t){var i=n.originalIndex,r=t.getName(),a=this.dataSet.getSeries(this.xField),o=this.dataSet.getSeries(this.yField),s=this.isMultiSeries?this.filterDataByNameMatch(a,r)[i]:a[i],l=this.isMultiSeries?this.filterDataByNameMatch(o,r)[i]:o[i],h={},d=void 0;if(this.markField){var c=this.dataSet.getSeries(this.markField);d=this.isMultiSeries?this.filterDataByNameMatch(c,r)[i]:c[i],h["row."+this.markField]=d}var p={type:"pointClick",modifierKey:e.modifierKey,name:this.markField?this.markField:this.isMultiSeries?this.labelField:this.xField,value:this.markField?d:this.isMultiSeries?r:s,name2:this.markField&&this.isMultiSeries?this.labelField:this.yField,value2:this.markField&&this.isMultiSeries?r:l,rowContext:h};h["row."+this.xField]=s,h["row."+this.yField]=l,this.isMultiSeries&&(h["row."+this.labelField]=r),this.trigger(p)},handleLegendClick:function(e,n){var t={},i={type:"legendClick",modifierKey:e.modifierKey,name:this.labelField,value:n,rowContext:t};t["row."+this.labelField]=n,this.trigger(i)},getSeriesPointInfo:function(e,n){var t=n.index,i=this.xAxisList[0],r=this.yAxisList[0],a=e.getName(),o=this.dataSet.getSeries(this.xField),l=this.dataSet.getSeries(this.yField),h=this.isMultiSeries?this.filterDataByNameMatch(o,a)[t]:o[t],d=this.isMultiSeries?this.filterDataByNameMatch(l,a)[t]:l[t],c={isMultiSeries:this.isMultiSeries,xAxisName:this.xField,xValue:i.formatValue(h),yAxisName:this.yField,yValue:r.formatValue(d),markName:null,markValue:null};if(this.markField){var p=this.dataSet.getSeries(this.markField),u=this.isMultiSeries?this.filterMarkByNameMatch(a)[t]:p[t];s["default"].extend(c,{markName:this.markField,markValue:u})}return this.isMultiSeries&&s["default"].extend(c,{labelSeriesName:this.labelField}),c},filterDataByNameMatch:function(e,n){var t=this.dataSet.getSeries(this.labelField);return(0,h["default"])(e).filter(function(e,i){return t[i]===n})},filterMarkByNameMatch:function(e){var n=this.dataSet.getSeries(this.labelField),t=this.dataSet.getSeries(this.markField);return(0,h["default"])(t).filter(function(t,i){return n[i]===e})}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,n){u["default"].call(this,e,n),this.minorsPerMajor=5,this.minorTickWidth=1}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(2),h=t(4),d=t(7),c=i(d),p=t(53),u=r(p);(0,l.inherit)(a,u["default"]),s["default"].extend(a.prototype,{processProperties:function(){u["default"].prototype.processProperties.call(this)},onAnimationFinished:function(){},renderGauge:function(){u["default"].prototype.renderGauge.call(this),this.tickColor=this.foregroundColor,this.tickFontColor=this.fontColor,this.defaultValueColor=this.isShiny?"black":this.fontColor,this.drawBackground(),this.drawTicks(),this.drawIndicator(this.value)},updateValue:function(e,n){var t=(0,h.getDecimalPrecision)(e,3),i=(0,h.getDecimalPrecision)(n,3);this.valueAnimationPrecision=Math.max(t,i),u["default"].prototype.updateValue.call(this,e,n)},getDisplayValue:function(e){var n=Math.pow(10,this.valueAnimationPrecision);return e!==this.value?Math.round(e*n)/n:e},updateValueDisplay:function(){},shouldAnimateTransition:function(){return!0},getFillColor:function(e){var n=void 0;for(n=0;n<this.ranges.length-2&&!(e<=this.ranges[n+1]);n++);return this.getColorByIndex(n)},getValueColor:function(e){var n=c.hexFromColor(e),t=128,i="black",r="white",a=c.getLuminance(n);return a<t?r:i}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e,n){h["default"].call(this,e,n),this.bandCornerRad=0,this.tickLabelPaddingRight=10,this.minorsPerMajor=5,this.minorTickWidth=1,this.tickWidth=1}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(2),l=t(53),h=i(l);(0,s.inherit)(r,h["default"]),o["default"].extend(r.prototype,{showValueByDefault:!1,renderGauge:function(){h["default"].prototype.renderGauge.call(this),this.tickColor=this.isShiny?"black":this.foregroundColor,this.tickFontColor=this.isShiny?"black":this.fontColor,this.valueOffset=this.isShiny?this.markerSideWidth+10:this.valueFontSize,this.drawBackground(),this.showRangeBand&&this.drawBand(),this.drawTicks(),this.drawIndicator(this.value),this.checkOutOfRange(this.value)},updateValueDisplay:function(){}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0}),n.setLoggingConsole=n.setTheme=n.setTimezone=n.setColorPalette=n._enableVisualTestMode=n._disableVisualTestMode=n.useSplunkMoment=n.useSplunkI18nLibrary=n.createChart=n.extractChartReadyData=void 0;var r=t(5);Object.defineProperty(n,"setTheme",{enumerable:!0,get:function(){return r.setTheme}});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(8),d=i(h),c=t(118),p=i(c),u=t(119),f=i(u),m=t(120),g=i(m),x=t(121),b=i(x),y=t(3),v=t(64),w=t(122),k=i(w),S=t(45),T=i(S),O=t(187),M=i(O),P=t(27),A=i(P),L=t(229),_=i(L),C=t(230),H=i(C),I=t(101),D=i(I),E=t(232),R=i(E),z=t(233),N=i(z),W=t(234),j=i(W),F=t(235),B=i(F),G=t(236),Y=i(G),V=t(237),X=i(V);(0,p["default"])(d["default"]),k["default"].applyPatches(d["default"]),d["default"].splunkTimeAxisPlugin=(0,f["default"])(d["default"]),(0,g["default"])(d["default"]),(0,b["default"])(d["default"]);n.extractChartReadyData=function(e){if(!e||!e.fields||!e.columns)throw new Error("The data object passed to extractChartReadyData did not contain fields and columns");if(e.fields.length!==e.columns.length)throw new Error("The data object passed to extractChartReadyData must have the same number of fields and columns");return new M["default"](e)},n.createChart=function(e,n){if(e instanceof o["default"]&&(e=e[0]),!(0,l["default"])(e).isElement())throw new Error("Invalid first argument to createChart, container must be a valid DOM element or a jQuery object");n=n||{};var t=n.chart;return"pie"===t?new H["default"](e,n):"scatter"===t?new D["default"](e,n):"bubble"===t?new R["default"](e,n):"radialGauge"===t?new N["default"](e,n):"fillerGauge"===t?"x"===n["chart.orientation"]?new j["default"](e,n):new B["default"](e,n):"markerGauge"===t?"x"===n["chart.orientation"]?new Y["default"](e,n):new X["default"](e,n):(0,y.normalizeBoolean)(n["layout.splitSeries"])?new _["default"](e,n):new A["default"](e,n)},n.useSplunkI18nLibrary=d["default"].splunkTimeAxisPlugin.useSplunkI18nLibrary,n.useSplunkMoment=d["default"].splunkTimeAxisPlugin.useSplunkMoment,n._disableVisualTestMode=function(){},n._enableVisualTestMode=function(){},n.setColorPalette=T["default"].setBaseColors,n.setTimezone=d["default"].splunkTimeAxisPlugin.setTimezone;n.setLoggingConsole=v.setLoggingConsole},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}n.__esModule=!0;var r=t(106),a=i(r);n["default"]=a["default"]||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e}},function(e,n,t){e.exports={"default":t(107),__esModule:!0}},function(e,n,t){t(108),e.exports=t(16).Object.assign},function(e,n,t){var i=t(30);i(i.S+i.F,"Object",{assign:t(112)})},function(e,n){e.exports=function(e){if("function"!=typeof e)throw TypeError(e+" is not a function!");return e}},function(e,n,t){e.exports=!t(20)&&!t(32)(function(){return 7!=Object.defineProperty(t(55)("div"),"a",{get:function(){return 7}}).a})},function(e,n,t){var i=t(31);e.exports=function(e,n){if(!i(e))return e;var t,r;if(n&&"function"==typeof(t=e.toString)&&!i(r=t.call(e)))return r;if("function"==typeof(t=e.valueOf)&&!i(r=t.call(e)))return r;if(!n&&"function"==typeof(t=e.toString)&&!i(r=t.call(e)))return r;throw TypeError("Can't convert object to primitive value")}},function(e,n,t){"use strict";var i=t(56),r=t(116),a=t(117),o=t(37),s=t(58),l=Object.assign;e.exports=!l||t(32)(function(){var e={},n={},t=Symbol(),i="abcdefghijklmnopqrst";return e[t]=7,i.split("").forEach(function(e){n[e]=e}),7!=l({},e)[t]||Object.keys(l({},n)).join("")!=i})?function(e,n){for(var t=o(e),l=arguments.length,h=1,d=r.f,c=a.f;l>h;)for(var p,u=s(arguments[h++]),f=d?i(u).concat(d(u)):i(u),m=f.length,g=0;m>g;)c.call(u,p=f[g++])&&(t[p]=u[p]);return t}:l},function(e,n,t){var i=t(21),r=t(57),a=t(114)(!1),o=t(36)("IE_PROTO");e.exports=function(e,n){var t,s=r(e),l=0,h=[];for(t in s)t!=o&&i(s,t)&&h.push(t);for(;n.length>l;)i(s,t=n[l++])&&(~a(h,t)||h.push(t));return h}},function(e,n,t){var i=t(57),r=t(60),a=t(115);e.exports=function(e){return function(n,t,o){var s,l=i(n),h=r(l.length),d=a(o,h);if(e&&t!=t){for(;h>d;)if(s=l[d++],s!=s)return!0}else for(;h>d;d++)if((e||d in l)&&l[d]===t)return e||d||0;return!e&&-1}}},function(e,n,t){var i=t(35),r=Math.max,a=Math.min;e.exports=function(e,n){return e=i(e),e<0?r(e+n,0):a(e,n)}},function(e,n){n.f=Object.getOwnPropertySymbols},function(e,n){n.f={}.propertyIsEnumerable},function(e,n){e.exports=t(588)},function(e,n){e.exports=t(589)},function(e,n){e.exports=t(591)},function(e,n){e.exports=t(592)},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0});var r=t(123),a=i(r),o=t(164),s=i(o),l=t(165),h=i(l),d=function(e,n){var t=e.prototype;(0,h["default"])(n,function(e,n){t[n]=(0,a["default"])(t[n],e)})},c=function(e){for(var n=arguments.length,t=Array(n>1?n-1:0),i=1;i<n;i++)t[i-1]=arguments[i];"function"==typeof e&&e.apply(void 0,t)},p=function(e,n,t){for(var i=arguments.length,r=Array(i>3?i-3:0),a=3;a<i;a++)r[a-3]=arguments[a];return"function"==typeof e?e.apply(void 0,[t].concat(r)):n.apply(t,r)},u=function(e){d(e.Chart,{firstRender:function(e){p(this.options.firstRenderOverride,e,this)},render:function(e,n){p(this.options.renderOverride,e,this,n)}}),d(e.Tooltip,{getAnchor:function(e,n,t){var i=e.call(this,n,t);return c(this.options.getAnchorPostHook,n,t,i),i},refresh:function(e,n,t){e.call(this,n,t),this.chart.options.chart.events&&this.chart.options.chart.events.tooltipRefresh&&this.chart.options.chart.events.tooltipRefresh()}}),d(e.Legend,{render:function(e){c(this.options.renderPreHook,this),e.call(this),c(this.options.renderPostHook,this)},renderItem:function(e,n){var t=this.options,i=this.allItems;"function"==typeof t.renderItemsPreHook&&n===i[0]?(t.renderItemsPreHook(this),e.call(this,n)):"function"==typeof t.renderItemsPostHook&&n===(0,s["default"])(i)?(e.call(this,n),t.renderItemsPostHook(this)):e.call(this,n)}}),d(e.Series,{drawPoints:function(e){var n=this.options;c(n.drawPointsPreHook,this),e.call(this)},plotGroup:function(e,n,t,i,r,a){var o=e.call(this,n,t,i,r,a);return c(this.options.plotGroupPostHook,this,o),o},render:function(e){e.call(this),c(this.options.renderPostHook,this)},afterAnimate:function(e){e.call(this),c(this.options.afterAnimate,this)},destroy:function(e){c(this.options.destroyPreHook,this),e.call(this)},translate:function(e){e.call(this),c(this.options.translatePostHook,this)}});var n=e.seriesTypes;[n.column,n.scatter].forEach(function(e){d(e,{drawPoints:function(e){p(this.options.drawPointsOverride,e,this)},drawGraph:function(e){p(this.options.drawGraphOverride,e,this)},drawTracker:function(e){p(this.options.drawTrackerOverride,e,this)},getGraphPath:function(e){return p(this.options.getGraphPathOverride,e,this)},getValidPoints:function(e,n,t){return p(this.options.getValidPointsOverride,e,this,n,t)}})}),d(n.area,{getStackPoints:function(e,n){var t=c(this.options.getStackPointsPreHook,this,n);return e.call(this,t)},setStackedPoints:function(e){e.call(this),c(this.options.setStackedPointsPostHook,this)}}),d(n.pie,{translate:function(e){c(this.options.translatePreHook,this),e.call(this)},drawDataLabels:function(e){var n=this.options.dataLabels;c(n.drawDataLabelsPreHook,this),e.call(this),c(n.drawDataLabelsPostHook,this)},placeDataLabels:function(e){var n=this.options.dataLabels;c(n.placeDataLabelsPreHook,this),e.call(this)}}),d(e.Axis,{getOffset:function(e){c(this.options.getOffsetPreHook,this),e.call(this)},getSeriesExtremes:function(e){e.call(this),c(this.options.getSeriesExtremesPostHook,this)},setTickInterval:function(e,n){c(this.options.setTickIntervalPreHook,this,n),e.call(this,n)},setTickPositions:function(e){var n=this.options;c(n.setTickPositionsPreHook,this),e.call(this),c(n.setTickPositionsPostHook,this)},setAxisSize:function(e){c(this.options.setSizePreHook,this),e.call(this)},render:function(e){c(this.options.renderPreHook,this),e.call(this)},zoom:function(e,n,t){var i=e.call(this,n,t);return c(this.options.zoomPostHook,this,n,t),i}}),d(e.Tick,{render:function(e,n,t,i){e.call(this,n,t,i),c(this.axis.options.tickRenderPostHook,this,n,t,i)},getLabelSize:function(e){return p(this.axis.options.getLabelSizeOverride,e,this)}}),d(e.Pointer,{runPointActions:function(e,n,t){var i=this.chart.hoverSeries;i&&"function"==typeof i.options.pointActionsPreHook&&i.options.pointActionsPreHook(i,n,t),e.call(this,n,t)},dragStart:function(e,n){c(this.chart.options.pointerDragStartPreHook,this,n),e.call(this,n)},drag:function(e,n){return p(this.chart.options.pointerDragOverride,e,this,n,e)},drop:function(e,n){this.chart.hasOwnProperty("index")&&(c(this.chart.options.pointerDropPreHook,this,n),e.call(this,n),c(this.chart.options.pointerDropPostHook,this,n))},pinch:function(e,n){return p(this.chart.options.pointerPinchOverride,e,this,n,e)}})};n["default"]={applyPatches:u},e.exports=n["default"]},function(e,n,t){function i(e,n){return a(r(n),e)}var r=t(65),a=t(124);e.exports=i},function(e,n,t){var i=t(125),r=t(138),a=t(43),o=t(26),s=32,l=i(function(e,n){var t=o(n,a(l));return r(e,s,void 0,n,t)});l.placeholder={},e.exports=l},function(e,n,t){function i(e,n){return o(a(e,n,r),e+"")}var r=t(23),a=t(126),o=t(66);e.exports=i},function(e,n,t){function i(e,n,t){return n=a(void 0===n?e.length-1:n,0),function(){for(var i=arguments,o=-1,s=a(i.length-n,0),l=Array(s);++o<s;)l[o]=i[n+o];o=-1;for(var h=Array(n+1);++o<n;)h[o]=i[o];return h[n]=t(l),r(e,this,h)}}var r=t(38),a=Math.max;e.exports=i},function(e,n,t){var i=t(128),r=t(129),a=t(23),o=r?function(e,n){return r(e,"toString",{configurable:!0,enumerable:!1,value:i(n),writable:!0})}:a;e.exports=o},function(e,n){function t(e){return function(){return e}}e.exports=t},function(e,n,t){var i=t(67),r=function(){try{var e=i(Object,"defineProperty");return e({},"",{}),e}catch(n){}}();e.exports=r},function(e,n,t){function i(e){if(!o(e)||a(e))return!1;var n=r(e)?f:h;return n.test(s(e))}var r=t(68),a=t(134),o=t(14),s=t(136),l=/[\\^$.*+?()[\]{}|]/g,h=/^\[object .+?Constructor\]$/,d=Function.prototype,c=Object.prototype,p=d.toString,u=c.hasOwnProperty,f=RegExp("^"+p.call(u).replace(l,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");e.exports=i},function(e,n){var t;t=function(){return this}();try{t=t||Function("return this")()||(0,eval)("this")}catch(i){"object"==typeof window&&(t=window)}e.exports=t},function(e,n,t){function i(e){var n=o.call(e,l),t=e[l];try{e[l]=void 0;var i=!0}catch(r){}var a=s.call(e);return i&&(n?e[l]=t:delete e[l]),a}var r=t(69),a=Object.prototype,o=a.hasOwnProperty,s=a.toString,l=r?r.toStringTag:void 0;e.exports=i},function(e,n){function t(e){return r.call(e)}var i=Object.prototype,r=i.toString;e.exports=t},function(e,n,t){function i(e){return!!a&&a in e}var r=t(135),a=function(){var e=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}();e.exports=i},function(e,n,t){var i=t(6),r=i["__core-js_shared__"];e.exports=r},function(e,n){function t(e){if(null!=e){try{return r.call(e)}catch(n){}try{return e+""}catch(n){}}return""}var i=Function.prototype,r=i.toString;e.exports=t},function(e,n){function t(e,n){return null==e?void 0:e[n]}e.exports=t},function(e,n,t){function i(e,n,t,i,k,S,T,O){var M=n&g;if(!M&&"function"!=typeof e)throw new TypeError(f);var P=i?i.length:0;if(P||(n&=~(y|v),i=k=void 0),T=void 0===T?T:w(u(T),0),O=void 0===O?O:u(O),P-=k?k.length:0,n&v){var A=i,L=k;i=k=void 0}var _=M?void 0:h(e),C=[e,n,t,i,k,A,L,S,T,O];if(_&&d(C,_),e=C[0],n=C[1],t=C[2],i=C[3],k=C[4],O=C[9]=void 0===C[9]?M?0:e.length:w(C[9]-P,0),!O&&n&(x|b)&&(n&=~(x|b)),n&&n!=m)H=n==x||n==b?o(e,n,O):n!=y&&n!=(m|y)||k.length?s.apply(void 0,C):l(e,n,t,i);else var H=a(e,n,t);var I=_?r:c;return p(I(H,C),e,n)}var r=t(72),a=t(140),o=t(141),s=t(74),l=t(158),h=t(78),d=t(159),c=t(81),p=t(82),u=t(160),f="Expected a function",m=1,g=2,x=8,b=16,y=32,v=64,w=Math.max;e.exports=i},function(e,n,t){var i=t(67),r=t(6),a=i(r,"WeakMap");e.exports=a},function(e,n,t){function i(e,n,t){function i(){var n=this&&this!==a&&this instanceof i?l:e;return n.apply(s?t:this,arguments)}var s=n&o,l=r(e);return i}var r=t(25),a=t(6),o=1;e.exports=i},function(e,n,t){function i(e,n,t){function i(){for(var a=arguments.length,p=Array(a),u=a,f=l(i);u--;)p[u]=arguments[u];var m=a<3&&p[0]!==f&&p[a-1]!==f?[]:h(p,f);if(a-=m.length,a<t)return s(e,n,o,i.placeholder,void 0,p,m,void 0,void 0,t-a);var g=this&&this!==d&&this instanceof i?c:e;return r(g,this,p)}var c=a(e);return i}var r=t(38),a=t(25),o=t(74),s=t(77),l=t(43),h=t(26),d=t(6);e.exports=i},function(e,n){function t(e,n){for(var t=e.length,i=0;t--;)e[t]===n&&++i;return i}e.exports=t},function(e,n,t){function i(e){var n=o(e),t=s[n];if("function"!=typeof t||!(n in r.prototype))return!1;if(e===t)return!0;var i=a(t);return!!i&&e===i[0]}var r=t(40),a=t(78),o=t(145),s=t(147);e.exports=i},function(e,n){function t(){}e.exports=t},function(e,n,t){function i(e){for(var n=e.name+"",t=r[n],i=o.call(r,n)?t.length:0;i--;){var a=t[i],s=a.func;if(null==s||s==e)return a.name}return n}var r=t(146),a=Object.prototype,o=a.hasOwnProperty;e.exports=i},function(e,n){var t={};e.exports=t},function(e,n,t){function i(e){if(l(e)&&!s(e)&&!(e instanceof r)){if(e instanceof a)return e;if(c.call(e,"__wrapped__"))return h(e);
}return new a(e)}var r=t(40),a=t(79),o=t(41),s=t(42),l=t(15),h=t(148),d=Object.prototype,c=d.hasOwnProperty;i.prototype=o.prototype,i.prototype.constructor=i,e.exports=i},function(e,n,t){function i(e){if(e instanceof r)return e.clone();var n=new a(e.__wrapped__,e.__chain__);return n.__actions__=o(e.__actions__),n.__index__=e.__index__,n.__values__=e.__values__,n}var r=t(40),a=t(79),o=t(80);e.exports=i},function(e,n){function t(e){var n=e.match(i);return n?n[1].split(r):[]}var i=/\{\n\/\* \[wrapped with (.+)\] \*/,r=/,? & /;e.exports=t},function(e,n){function t(e,n){var t=n.length;if(!t)return e;var r=t-1;return n[r]=(t>1?"& ":"")+n[r],n=n.join(t>2?", ":" "),e.replace(i,"{\n/* [wrapped with "+n+"] */\n")}var i=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;e.exports=t},function(e,n,t){function i(e,n){return r(m,function(t){var i="_."+t[0];n&t[1]&&!a(e,i)&&e.push(i)}),e.sort()}var r=t(83),a=t(152),o=1,s=2,l=8,h=16,d=32,c=64,p=128,u=256,f=512,m=[["ary",p],["bind",o],["bindKey",s],["curry",l],["curryRight",h],["flip",f],["partial",d],["partialRight",c],["rearg",u]];e.exports=i},function(e,n,t){function i(e,n){var t=null==e?0:e.length;return!!t&&r(e,n,0)>-1}var r=t(153);e.exports=i},function(e,n,t){function i(e,n,t){return n===n?o(e,n,t):r(e,a,t)}var r=t(154),a=t(155),o=t(156);e.exports=i},function(e,n){function t(e,n,t,i){for(var r=e.length,a=t+(i?1:-1);i?a--:++a<r;)if(n(e[a],a,e))return a;return-1}e.exports=t},function(e,n){function t(e){return e!==e}e.exports=t},function(e,n){function t(e,n,t){for(var i=t-1,r=e.length;++i<r;)if(e[i]===n)return i;return-1}e.exports=t},function(e,n,t){function i(e,n){for(var t=e.length,i=o(n.length,t),s=r(e);i--;){var l=n[i];e[i]=a(l,t)?s[l]:void 0}return e}var r=t(80),a=t(84),o=Math.min;e.exports=i},function(e,n,t){function i(e,n,t,i){function l(){for(var n=-1,a=arguments.length,s=-1,c=i.length,p=Array(c+a),u=this&&this!==o&&this instanceof l?d:e;++s<c;)p[s]=i[s];for(;a--;)p[s++]=arguments[++n];return r(u,h?t:this,p)}var h=n&s,d=a(e);return l}var r=t(38),a=t(25),o=t(6),s=1;e.exports=i},function(e,n,t){function i(e,n){var t=e[1],i=n[1],m=t|i,g=m<(l|h|p),x=i==p&&t==c||i==p&&t==u&&e[7].length<=n[8]||i==(p|u)&&n[7].length<=n[8]&&t==c;if(!g&&!x)return e;i&l&&(e[2]=n[2],m|=t&l?0:d);var b=n[3];if(b){var y=e[3];e[3]=y?r(y,b,n[4]):b,e[4]=y?o(e[3],s):n[4]}return b=n[5],b&&(y=e[5],e[5]=y?a(y,b,n[6]):b,e[6]=y?o(e[5],s):n[6]),b=n[7],b&&(e[7]=b),i&p&&(e[8]=null==e[8]?n[8]:f(e[8],n[8])),null==e[9]&&(e[9]=n[9]),e[0]=n[0],e[1]=m,e}var r=t(75),a=t(76),o=t(26),s="__lodash_placeholder__",l=1,h=2,d=4,c=8,p=128,u=256,f=Math.min;e.exports=i},function(e,n,t){function i(e){var n=r(e),t=n%1;return n===n?t?n-t:n:0}var r=t(161);e.exports=i},function(e,n,t){function i(e){if(!e)return 0===e?e:0;if(e=r(e),e===a||e===-a){var n=e<0?-1:1;return n*o}return e===e?e:0}var r=t(162),a=1/0,o=1.7976931348623157e308;e.exports=i},function(e,n,t){function i(e){if("number"==typeof e)return e;if(a(e))return o;if(r(e)){var n="function"==typeof e.valueOf?e.valueOf():e;e=r(n)?n+"":n}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(s,"");var t=h.test(e);return t||d.test(e)?c(e.slice(2),t?2:8):l.test(e)?o:+e}var r=t(14),a=t(163),o=NaN,s=/^\s+|\s+$/g,l=/^[-+]0x[0-9a-f]+$/i,h=/^0b[01]+$/i,d=/^0o[0-7]+$/i,c=parseInt;e.exports=i},function(e,n,t){function i(e){return"symbol"==typeof e||a(e)&&r(e)==o}var r=t(24),a=t(15),o="[object Symbol]";e.exports=i},function(e,n){function t(e){var n=null==e?0:e.length;return n?e[n-1]:void 0}e.exports=t},function(e,n,t){e.exports=t(166)},function(e,n,t){function i(e,n){var t=s(e)?r:a;return t(e,o(n))}var r=t(83),a=t(167),o=t(65),s=t(42);e.exports=i},function(e,n,t){var i=t(168),r=t(186),a=r(i);e.exports=a},function(e,n,t){function i(e,n){return e&&r(e,n,a)}var r=t(169),a=t(171);e.exports=i},function(e,n,t){var i=t(170),r=i();e.exports=r},function(e,n){function t(e){return function(n,t,i){for(var r=-1,a=Object(n),o=i(n),s=o.length;s--;){var l=o[e?s:++r];if(t(a[l],l,a)===!1)break}return n}}e.exports=t},function(e,n,t){function i(e){return o(e)?r(e):a(e)}var r=t(172),a=t(182),o=t(86);e.exports=i},function(e,n,t){function i(e,n){var t=o(e),i=!t&&a(e),d=!t&&!i&&s(e),p=!t&&!i&&!d&&h(e),u=t||i||d||p,f=u?r(e.length,String):[],m=f.length;for(var g in e)!n&&!c.call(e,g)||u&&("length"==g||d&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||l(g,m))||f.push(g);return f}var r=t(173),a=t(174),o=t(42),s=t(176),l=t(84),h=t(178),d=Object.prototype,c=d.hasOwnProperty;e.exports=i},function(e,n){function t(e,n){for(var t=-1,i=Array(e);++t<e;)i[t]=n(t);return i}e.exports=t},function(e,n,t){var i=t(175),r=t(15),a=Object.prototype,o=a.hasOwnProperty,s=a.propertyIsEnumerable,l=i(function(){return arguments}())?i:function(e){return r(e)&&o.call(e,"callee")&&!s.call(e,"callee")};e.exports=l},function(e,n,t){function i(e){return a(e)&&r(e)==o}var r=t(24),a=t(15),o="[object Arguments]";e.exports=i},function(e,n,t){(function(e){var i=t(6),r=t(177),a="object"==typeof n&&n&&!n.nodeType&&n,o=a&&"object"==typeof e&&e&&!e.nodeType&&e,s=o&&o.exports===a,l=s?i.Buffer:void 0,h=l?l.isBuffer:void 0,d=h||r;e.exports=d}).call(n,t(44)(e))},function(e,n){function t(){return!1}e.exports=t},function(e,n,t){var i=t(179),r=t(180),a=t(181),o=a&&a.isTypedArray,s=o?r(o):i;e.exports=s},function(e,n,t){function i(e){return o(e)&&a(e.length)&&!!C[r(e)]}var r=t(24),a=t(85),o=t(15),s="[object Arguments]",l="[object Array]",h="[object Boolean]",d="[object Date]",c="[object Error]",p="[object Function]",u="[object Map]",f="[object Number]",m="[object Object]",g="[object RegExp]",x="[object Set]",b="[object String]",y="[object WeakMap]",v="[object ArrayBuffer]",w="[object DataView]",k="[object Float32Array]",S="[object Float64Array]",T="[object Int8Array]",O="[object Int16Array]",M="[object Int32Array]",P="[object Uint8Array]",A="[object Uint8ClampedArray]",L="[object Uint16Array]",_="[object Uint32Array]",C={};C[k]=C[S]=C[T]=C[O]=C[M]=C[P]=C[A]=C[L]=C[_]=!0,C[s]=C[l]=C[v]=C[h]=C[w]=C[d]=C[c]=C[p]=C[u]=C[f]=C[m]=C[g]=C[x]=C[b]=C[y]=!1,e.exports=i},function(e,n){function t(e){return function(n){return e(n)}}e.exports=t},function(e,n,t){(function(e){var i=t(70),r="object"==typeof n&&n&&!n.nodeType&&n,a=r&&"object"==typeof e&&e&&!e.nodeType&&e,o=a&&a.exports===r,s=o&&i.process,l=function(){try{return s&&s.binding&&s.binding("util")}catch(e){}}();e.exports=l}).call(n,t(44)(e))},function(e,n,t){function i(e){if(!r(e))return a(e);var n=[];for(var t in Object(e))s.call(e,t)&&"constructor"!=t&&n.push(t);return n}var r=t(183),a=t(184),o=Object.prototype,s=o.hasOwnProperty;e.exports=i},function(e,n){function t(e){var n=e&&e.constructor,t="function"==typeof n&&n.prototype||i;return e===t}var i=Object.prototype;e.exports=t},function(e,n,t){var i=t(185),r=i(Object.keys,Object);e.exports=r},function(e,n){function t(e,n){return function(t){return e(n(t))}}e.exports=t},function(e,n,t){function i(e,n){return function(t,i){if(null==t)return t;if(!r(t))return e(t,i);for(var a=t.length,o=n?a:-1,s=Object(t);(n?o--:++o<a)&&i(s[o],o,s)!==!1;);return t}}var r=t(86);e.exports=i},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){var n=this,t=e.fields||{},i=e.columns||{};this.fields=[],this.seriesList=[],this.fieldMetadata={},this.annotations=e.annotations||[],(0,h["default"])(t).each(function(e,t){var r=void 0;h["default"].isObject(e)?(r=e.name,n.fieldMetadata[r]=e):r=e,(n.ALLOWED_HIDDEN_FIELDS_REGEX.test(r)||n.isDataField(r))&&(n.fields.push(r),n.seriesList.push(s["default"].extend([],i[t])))}),this.length=this.fields.length,this.getSeriesAsFloats=h["default"].memoize(this.getSeriesAsFloats,this.seriesAsFloatsMemoizeHash),this.getSeriesAsEpochTimes=h["default"].memoize(this.getSeriesAsEpochTimes)}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(87),c=r(d),p=t(88),u=i(p),f=t(4),m=i(f);a.prototype={ALLOWED_HIDDEN_FIELDS_REGEX:/^(_span|_tc|_lower.*|_predicted.*|_upper.*)$/,DATA_FIELD_REGEX:/^[^_]|^_time$/,allFields:function(){return this.fields.slice()},allDataFields:function(){return(0,h["default"])(this.fields).filter(this.isDataField,this)},isDataField:function(e){return this.DATA_FIELD_REGEX.test(e)},isTotalValue:function(e){return"ALL"===e},hasField:function(e){return(0,h["default"])(this.fields).indexOf(e)>-1},fieldAt:function(e){return this.fields[e]},fieldIsGroupby:function(e){return this.fieldMetadata[e]&&this.fieldMetadata[e].hasOwnProperty("groupby_rank")},getFieldData:function(){var e=this.allDataFields(),n=[e[0]];if(u.isRangeSeriesDataSet(this)){var t=u.getRangeSeriesConfig(this);(0,h["default"])(t).each(function(n){e=(0,h["default"])(e).without(n.lower,n.upper)})}var i=(0,h["default"])(e).difference(n);return{xFields:n,yFields:i}},seriesAt:function(e){return this.seriesList[e]},getSeries:function(e){var n=(0,h["default"])(this.fields).indexOf(e);return n===-1?[]:(0,h["default"])(this.seriesList[n]).map(function(e){return null===e?"":e})},getSeriesAsFloats:function(e,n){n=n||{};for(var t=this.getSeries(e),i="zero"===n.nullValueMode,r="log"===n.scale,a=[],o=0;o<t.length;o++){var s=m.parseFloat(t[o]);h["default"].isNaN(s)?a.push(i?0:null):a.push(r?m.absLogBaseTen(s):s)}return a},getSeriesAsEpochTimes:function(e){return this.getSeries(e).map(function(e){if("ALL"===e||"OTHER"===e)return NaN;var n=(0,c["default"])(e);return n.isValid()?n.valueOf():NaN})},getSeriesAsTimestamps:function(e){var n=this.getSeries(e);return this.isTotalValue((0,h["default"])(n).last())?n.slice(0,-1):n},seriesAsFloatsMemoizeHash:function(e,n){return n=n||{},e+n.scale+n.nullValueMode},getAnnotations:function(){return this.annotations},toJSON:function(){return{fields:this.fields,columns:this.seriesList}}},n["default"]=a,e.exports=n["default"]},function(e,n){e.exports=t(593)},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){f["default"].call(this,e),this.tickLabelPadding=this.isVertical?2:3,this._annotationsAreDirty=!1}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(2),c=i(d),p=t(3),u=t(48),f=r(u);c.inherit(a,f["default"]),s["default"].extend(a.prototype,{getConfig:function(){var e=f["default"].prototype.getConfig.call(this),n=(0,p.normalizeBoolean)(this.properties.crosshair);return s["default"].extend(!0,e,{type:"datetime",showLastLabel:!0,crosshair:n&&f["default"].prototype.CROSSHAIR_CONFIG,tickmarkPlacement:this.hasTickmarksBetween()?"between":"on",max:this.properties["axis.maximumValue"],annotations:this.properties["axis.annotations"]}),delete e.labels.formatter,delete e.labels.y,e},formatValue:function(e,n){return this.hcAxis?this.hcAxis.options["splunk-tooltip"].formatter(n.x):null},setMaximumValue:function(e){this.hcAxis.options.max=e},setAnnotations:function(e){var n=this.properties["axis.annotations"];h["default"].isEqual(e,n)||(this.properties["axis.annotations"]=e,this.hcAxis.options.annotations=this.properties["axis.annotations"],this._annotationsAreDirty=!0)},isAnnotationDirty:function(){return this._annotationsAreDirty},redraw:function(e){for(var n,t=arguments.length,i=Array(t>1?t-1:0),r=1;r<t;r++)i[r-1]=arguments[r];(n=f["default"].prototype.redraw).call.apply(n,[this,e].concat(i)),this.hcAxis&&this.isAnnotationDirty()&&this.hcAxis.redraw(e)},onChartLoadOrRedraw:function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];f["default"].prototype.onChartLoadOrRedraw.apply(this,n),this._annotationsAreDirty=!1}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){y["default"].call(this,e),e=e||{},this.skipLabelsToAvoidCollisions=x.normalizeBoolean(e["axis.skipLabelsToAvoidCollisions"]),this.ellipsize="ellipsisMiddle"===e["axisLabels.majorLabelStyle.overflowMode"],this.properties["axis.categories"]=this.processCategories(e["axis.categories"]),this._categoriesAreDirty=!1,this.isiOS=!!c["default"].ios}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(46),c=r(d),p=t(10),u=r(p),f=t(2),m=i(f),g=t(3),x=i(g),b=t(48),y=r(b),v=5;m.inherit(a,y["default"]),s["default"].extend(a.prototype,{DEFAULT_FONT_SIZE:12,MIN_FONT_SIZE:9,getConfig:function(){for(var e=this,n=arguments.length,t=Array(n),i=0;i<n;i++)t[i]=arguments[i];var r=y["default"].prototype.getConfig.apply(this,t),a=x.normalizeBoolean(this.properties.crosshair),o=x.normalizeBoolean(this.properties["axisLabels.hideCategories"]);return s["default"].extend(!0,r,{categories:this.properties["axis.categories"].slice(0),labels:{formatter:function(){return e.formatLabel(this.value)},enabled:r.labels.enabled&&!o,maxStaggerLines:2,style:{whiteSpace:"nowrap",HcTextStroke:!0}},crosshair:a&&y["default"].prototype.CROSSHAIR_CONFIG,startOnTick:!this.hasTickmarksBetween(),showLastLabel:this.hasTickmarksBetween(),tickWidth:o?0:r.tickWidth,tickmarkPlacement:this.properties["axisLabels.tickmarkPlacement"],tickPositioner:function(n,t){return e.tickPositioner(this,n,t)},setTickPositionsPreHook:(0,h["default"])(this.setTickPositionsPreHook).bind(this),setTickPositionsPostHook:(0,h["default"])(this.setTickPositionsPostHook).bind(this),renderPreHook:(0,h["default"])(this.renderPreHook).bind(this)}),r},getVerticalConfig:function(){var e=y["default"].prototype.getVerticalConfig.call(this);return s["default"].extend(!0,e,{labels:{align:"right",x:-7}})},getHorizontalConfig:function(){var e=y["default"].prototype.getHorizontalConfig.call(this),n=void 0;return this.isiOS&&this.hasTickmarksBetween()&&this.originalCategories.length>1&&(n=1),s["default"].extend(!0,e,{labels:{align:"center"},endOnTick:!this.hasTickmarksBetween(),showLastLabel:!1,startOnTick:!0,minRange:n||-1})},processCategories:function(e){return this.originalCategories=e,e.slice(0)},getCategories:function(){return this.properties["axis.categories"]},getPreviousCategories:function(){return this.previousCategories||[]},categoriesAreDirty:function(){return this._categoriesAreDirty},setCategories:function(e){this.previousCategories=this.properties["axis.categories"],this.properties["axis.categories"]=this.processCategories(e),h["default"].isEqual(this.properties["axis.categories"],this.previousCategories)||(this._categoriesAreDirty=!0)},redraw:function(e){for(var n,t=arguments.length,i=Array(t>1?t-1:0),r=1;r<t;r++)i[r-1]=arguments[r];if((n=y["default"].prototype.redraw).call.apply(n,[this,e].concat(i)),this.categoriesAreDirty()&&this.hcAxis.setCategories(this.properties["axis.categories"].slice(0),e),this.isiOS&&this.hasTickmarksBetween()){var a=this.getConfig();this.hcAxis.minRange=a.minRange}},onChartLoadOrRedraw:function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];y["default"].prototype.onChartLoadOrRedraw.apply(this,n),this._categoriesAreDirty=!1},getOffsetPreHook:function(e){y["default"].prototype.getOffsetPreHook.call(this,e);var n=e.options,t=e.chart;if(n.labels.enabled){var i=void 0,r=void 0,a=void 0,o=void 0,s=void 0,l=new u["default"](t.renderer),h=this.getCurrentlyVisibleCategories(e),d=h.length,c=void 0,p=void 0;if(this.isVertical){i=Math.floor(t.chartWidth/6);var f=l.adjustLabels(h,i,this.MIN_FONT_SIZE,this.DEFAULT_FONT_SIZE,"middle");for(p=0;p<f.labels.length;p++)n.categories[p]=f.labels[p];n.labels.style["font-size"]=f.fontSize+"px",c=l.predictTextHeight("Test",f.fontSize);var m=t.plotHeight;r=m/(h.length||1),a=25,o=this.skipLabelsToAvoidCollisions?Math.ceil(a/r):1,n.labels.y=c/3,n.labels.x=-n.tickLength,n.labels.step=o}else{var g=void 0,x=100,b=t.plotWidth,w=l.getMaxWidthForFontRange(h,this.MIN_FONT_SIZE,this.DEFAULT_FONT_SIZE),k=0,S=0;r=b/(d||1);var T=this.findBestFontForSpacing(w,r-2*v);if(T>0&&0===this.labelRotation)g=T,o=1,s=r,i=s;else{a=Math.min(w[this.MIN_FONT_SIZE]+2*v,x),g=this.MIN_FONT_SIZE,o=this.skipLabelsToAvoidCollisions?Math.ceil(a/r):1,s=r*o;var O=2*Math.PI/360,M=this.labelRotation*O,P=Math.abs(Math.cos(M)),A=s-2*v,L=void 0,_=void 0;switch(this.labelRotation){case 0:break;case-45:for(i=[],L=t.chartHeight/2/Math.abs(Math.sin(M)),p=0;p<d;p++)_=r*(p+1)/P,0===p&&(_=Math.min(t.xAxis[0].left+r/2,_)),this.ellipsize?i[p]=Math.min(_,L,A):i[p]=Math.min(_,L);break;case 45:for(i=[],L=t.chartHeight/2/Math.abs(Math.sin(M)),p=0;p<d;p++)_=r*(p+1)/P,this.ellipsize?i[d-p-1]=Math.min(_,L,A):i[d-p-1]=Math.min(_,L);break;default:i=this.ellipsize?Math.min(t.chartHeight/2,A):t.chartHeight/2}}n.labels.style["font-size"]=g+"px",0!==this.labelRotation&&this.ellipsizeLabels(e,l,i,g),c=l.predictTextHeight("Test",g),this.labelRotation===-45?(n.labels.align="right",k=0,S=c/4+n.tickLength):45===this.labelRotation?(n.labels.align="left",k=0,S=c/4+n.tickLength):this.labelRotation===-90?(n.labels.align="right",k=c/4,S=n.tickLength):90===this.labelRotation?(n.labels.align="left",k=-c/4,S=n.tickLength):(n.labels.align="center",k=0,S=c/2+n.tickLength),this.hasTickmarksBetween()||(S+=6),n.labels.step=o,n.labels.x=k,n.labels.y=S}l.destroy()}},renderPreHook:function(e){var n=e.options;if(e.horiz&&0===this.labelRotation&&n.labels.enabled){var t=e.chart,i=t.plotWidth,r=new u["default"](e.chart.renderer),a=parseInt(n.labels.style["font-size"],10),o=this.getCurrentlyVisibleCategories(e),s=i/(o.length||1)-2*v;this.ellipsizeLabels(e,r,s,a),e.tickPositions.forEach(function(t){var i=e.ticks[t];i.label.css(n.labels.style),i.addLabel()}),r.destroy()}},findBestFontForSpacing:function(e,n){var t=0;return(0,h["default"])(e).each(function(e,i){e<=n&&(t=Math.max(t,parseInt(i,10)))}),t},ellipsizeLabels:function(e,n,t,i){var r=void 0,a=this.getCurrentlyVisibleCategories(e),o=Math.round(e.getExtremes().min),s=(0,h["default"])(a).map(function(e,r){return n.ellipsize(e,h["default"].isArray(t)?t[r]:t,i,{},"middle")});for(r=0;r<s.length;r++)a[r]=s[r];(0,h["default"])(a).each(function(n,t){e.options.categories[o+t]=n})},getCurrentlyVisibleCategories:function(e){var n=e.getExtremes(),t=Math.round(n.min),i=Math.round(n.max),r=i-t+(this.hasTickmarksBetween()?1:0);return this.originalCategories.slice(t,t+r)},setTickPositionsPreHook:function(e){this.hasTickmarksBetween()||(e.options.max=this.properties["axis.categories"].length)},tickPositioner:function(e,n,t){return this.shouldHideTicks(e)?[n,t]:null},setTickPositionsPostHook:function(e){this.shouldHideTicks(e)&&(e.tickPositions=[]),this.isiOS&&this.hasTickmarksBetween()&&this.originalCategories.length>1&&(e.min=Math.round(e.min),e.max=Math.round(e.max))},shouldHideTicks:function(e){var n=this.isVertical?15:20,t=e.getExtremes(),i=t.max-t.min+(this.hasTickmarksBetween()?1:0),r=e.len/i;return r<n},tickRenderPostHook:function(e,n,t,i){var r=e.axis.options;r.labels=r.labels||{},r.labels.enabled&&0!==r.tickWidth&&y["default"].prototype.tickRenderPostHook.call(this,e,n,t,i)},formatValue:function(e){return e},formatLabel:function(e){return x.escapeSVG(e)}}),n["default"]=a,e.exports=n["default"]},function(e,n){e.exports=t(594)},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){this.properties=e||{},this.id=h["default"].uniqueId("legend_"),this.clickEnabled=u.normalizeBoolean(this.properties.clickEnabled),this.ellipsisMode=this.OVERFLOW_TO_ELLIPSIS_MAP[this.properties["labelStyle.overflowMode"]]||this.DEFAULT_ELLIPSIS_MODE,this.UNHIGHLIGHTED_COLOR=m.addAlphaToColor(this.UNHIGHLIGHTED_BASE_COLOR,this.UNHIGHLIGHTED_OPACITY),this.isMultiSeries=e.isMultiSeries,this.isExportMode=e.isExportMode}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(10),c=r(d),p=t(3),u=i(p),f=t(7),m=i(f),g=t(91),x=i(g),b=t(9),y=r(b),v=t(28),w=r(v),k=t(5);a.prototype=s["default"].extend({},y["default"],{VALUE_LABEL_COLOR:"rgba(150, 150, 150, 0.6)",HIGHLIGHTED_OPACITY:1,HIGHLIGHTED_SYMBOL_OPACITY:1,UNHIGHLIGHTED_OPACITY:.3,UNHIGHLIGHTED_BASE_COLOR:"rgb(150, 150, 150)",DEFAULT_PLACEMENT:"right",DEFAULT_ELLIPSIS_MODE:"middle",POINT_VALUE_WIDTH:60,BASE_CONFIG:{borderWidth:0,symbolRadius:0,squareSymbol:!1},PLACEMENT_OPTIONS:{top:!0,left:!0,bottom:!0,right:!0,none:!0},PLACEMENT_TO_MARGIN_MAP:{top:12,left:15,bottom:2,right:2},OVERFLOW_TO_ELLIPSIS_MAP:{ellipsisStart:"start",ellipsisMiddle:"middle",ellipsisEnd:"end",ellipsisNone:"none","default":"start"},getConfig:function(){var e=!this.isMultiSeries&&this.PLACEMENT_OPTIONS.hasOwnProperty(this.properties.placement)?this.properties.placement:this.DEFAULT_PLACEMENT,n={left:!0,right:!0}.hasOwnProperty(e),t=this.clickEnabled?"pointer":"default";return s["default"].extend(!0,{},this.BASE_CONFIG,{enabled:!this.properties.isEmpty,align:n?e:"center",verticalAlign:n?"middle":e,layout:n?"vertical":"horizontal",itemWidth:this.isMultiSeries?150:null,margin:this.PLACEMENT_TO_MARGIN_MAP[e],navigation:{activeColor:(0,k.getThemeProperty)("LEGEND_OVERFLOW_ARROW_COLOR_ACTIVE"),inactiveColor:(0,k.getThemeProperty)("LEGEND_OVERFLOW_ARROW_COLOR_INACTIVE"),style:{color:(0,k.getThemeProperty)("LEGEND_OVERFLOW_FONT_COLOR")}},itemStyle:{cursor:t,color:this.properties.fontColor||(0,k.getThemeProperty)("DEFAULT_FONT_COLOR"),fontWeight:"normal",HcTextStroke:!0},itemHoverStyle:{cursor:t,color:this.properties.fontColor||(0,k.getThemeProperty)("DEFAULT_FONT_COLOR")},renderItemsPreHook:(0,h["default"])(this.renderItemsPreHook).bind(this),renderItemsPostHook:(0,h["default"])(this.renderItemsPostHook).bind(this),renderPreHook:(0,h["default"])(this.renderPreHook).bind(this),renderPostHook:(0,h["default"])(this.renderPostHook).bind(this)})},onChartLoad:function(e){this.hcSeriesList=(0,h["default"])(e.series).filter(function(e){return e.options.showInLegend!==!1}),this.setSymbolFillOpacity(this.hcSeriesList[0])},onChartLoadOrRedraw:function(e){this.hcSeriesList=(0,h["default"])(e.series).filter(function(e){return e.options.showInLegend!==!1}),this.removeEventHandlers(),this.addEventHandlers()},setSymbolFillOpacity:function(e){var n=e.legendSymbol||e.legendLine,t=m.getComputedOpacity(n);0===t?this.HIGHLIGHTED_SYMBOL_OPACITY=1:this.HIGHLIGHTED_SYMBOL_OPACITY=t},addEventHandlers:function(){var e=this,n={highlightDelay:125,unhighlightDelay:50,onMouseOver:function(n){e.selectField(n),e.trigger("mouseover",[n])},onMouseOut:function(n){e.unSelectField(n),e.trigger("mouseout",[n])}},t=new w["default"](n);(0,h["default"])(this.hcSeriesList).each(function(n){var i=n.name;(0,h["default"])(this.getSeriesLegendObjects(n)).each(function(n){(0,s["default"])(n.element).on("mouseover."+this.id,function(){t.mouseOverHappened(i)}),(0,s["default"])(n.element).on("mouseout."+this.id,function(){t.mouseOutHappened(i)}),this.clickEnabled&&(0,s["default"])(n.element).on("click."+this.id,function(n){var t={type:"click",modifierKey:n.ctrlKey||n.metaKey};e.trigger(t,[i])})},this)},this)},removeEventHandlers:function(){(0,h["default"])(this.hcSeriesList).each(function(e){(0,h["default"])(this.getSeriesLegendObjects(e)).each(function(e){(0,s["default"])(e.element).off("."+this.id)},this)},this)},selectField:function(e){(0,h["default"])(this.hcSeriesList).each(function(n){n.name!==e?this.unHighlightField(e,n):this.highlightField(e,n)},this)},unSelectField:function(e){(0,h["default"])(this.hcSeriesList).each(function(n){n.name!==e&&this.highlightField(e,n)},this)},highlightField:function(e,n){n=n||this.getSeriesByFieldName(e);var t=this.getSeriesLegendObjects(n),i=n.color;t.item&&t.item.attr("fill-opacity",this.HIGHLIGHTED_OPACITY),t.line&&t.line.attr("stroke",i),t.symbol&&t.symbol.attr({fill:i,stroke:i,"fill-opacity":this.HIGHLIGHTED_SYMBOL_OPACITY})},unHighlightField:function(e,n){n=n||this.getSeriesByFieldName(e);var t=this.getSeriesLegendObjects(n);t.item&&t.item.attr("fill-opacity",this.UNHIGHLIGHTED_OPACITY),t.line&&t.line.attr("stroke",this.UNHIGHLIGHTED_COLOR),t.symbol&&t.symbol.attr({fill:this.UNHIGHLIGHTED_COLOR,stroke:this.UNHIGHLIGHTED_COLOR,"fill-opacity":this.UNHIGHLIGHTED_OPACITY})},updateLegend:function(e){var n=this;n.hcSeriesList&&n.hcSeriesList.length&&e&&n.hcSeriesList.forEach(function(t,i){var r=e.filter(function(e){return e.seriesIndex===i});if(r.length){var a="<span>"+t.ellipsizedName+' </span><span style="color: '+n.VALUE_LABEL_COLOR+'">'+r[0].formattedValue+"</span>";x.setLegendItemText(t.legendItem,a)}else x.setLegendItemText(t.legendItem,t.ellipsizedName)})},resetLegend:function(){this.hcSeriesList&&this.hcSeriesList.forEach(function(e){x.setLegendItemText(e.legendItem,e.ellipsizedName)})},getSeriesByFieldName:function(e){return(0,h["default"])(this.hcSeriesList).find(function(n){return n.name===e})},getSeriesLegendObjects:function(e){var n={};return e.legendItem&&(n.item=e.legendItem),e.legendSymbol&&(n.symbol=e.legendSymbol),e.legendLine&&(n.line=e.legendLine),n},destroy:function(){this.off(),this.removeEventHandlers(),this.hcSeriesList=null},renderItemsPreHook:function(e){var n=void 0,t=void 0,i=void 0,r=e.options,a=e.itemStyle,o=e.allItems,s=e.chart,l=s.renderer,h=s.spacingBox,d="horizontal"===r.layout,p=12,f=10,m=e.symbolWidth,g=r.symbolPadding,b=e.padding||0,y=10,v=[],w=new c["default"](l);for(i=d?o.length>5?Math.floor(h.width/6):Math.floor(h.width/o.length)-(m+g+y):this.isMultiSeries&&!this.isExportMode?r.itemWidth-this.POINT_VALUE_WIDTH:Math.floor(h.width/6)-(m+g+b),r.originalFormatter||(r.originalFormatter=r.labelFormatter),n=0;n<o.length;n++)v.push(r.originalFormatter.call(o[n]));var k=w.adjustLabels(v,i,f,p,this.ellipsisMode);for(k.areEllipsized&&d&&o.length>5?(t=i+m+g+y,r.itemWidth=t):this.isMultiSeries&&!this.isExportMode||(r.itemWidth=void 0),n=0;n<o.length;n++)o[n].ellipsizedName=k.labels[n],o[n].legendItem&&(x.setLegendItemText(o[n].legendItem,u.escapeSVG(k.labels[n])),o[n].legendItem.css({"font-size":k.fontSize+"px"}));r.labelFormatter=function(){return u.escapeSVG(this.ellipsizedName)},a["font-size"]=k.fontSize+"px",e.itemMarginTop=p-k.fontSize,w.destroy()},renderItemsPostHook:function(e){var n=55,t=e.options,i=e.padding,r=e.lastItemY+e.lastLineHeight,a=e.chart.spacingBox.height-i;if(r>a)t.verticalAlign="top",t.y=-i,e.offsetWidth<n&&(t.width=n);else{var o=this.getConfig();s["default"].extend(t,{verticalAlign:o.verticalAlign,y:o.y,width:o.width})}},renderPreHook:function(e){var n=e.chart.renderer;this._rendererForExport=n.forExport,n.forExport=!0},renderPostHook:function(e){e.chart.renderer.forExport=this._rendererForExport}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){this.properties=e||{}}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(5),d={seriesCompare:{positioner:function(e,n,t){var i=this.chart.plotWidth,r=this.chart.plotHeight,a=this.chart.plotLeft+i-e,o=t.plotX+this.chart.plotLeft-e/2,s={x:Math.max(this.chart.plotLeft,Math.min(o,a)),y:r+n/2+1};return s},shape:"square",shared:!0}};r.prototype={BASE_CONFIG:{enabled:!0,backgroundColor:(0,h.getThemeProperty)("TOOLTIP_BACKGROUND_COLOR"),borderColor:(0,h.getThemeProperty)("TOOLTIP_BORDER_COLOR"),hideDelay:0,style:{color:(0,h.getThemeProperty)("TOOLTIP_FONT_COLOR_SOFT")},positioner:function(e,n,t){var i=this.getPosition(e,n,t),r=this.chart.plotWidth,a=this.chart.plotHeight,s=(0,o["default"])(this.chart.container).find('[name="reset-zoom"]');if(t.plotX>r&&(i.x=this.chart.plotLeft+r-e-8),t.plotX<0&&(i.x=this.chart.plotLeft+8),t.plotY<0&&(i.y=17),t.plotY>a&&(i.y=a-n+3),s.length>0){var l=s.position();if(l){var h=l.top,d=s.height(),c=h+d,p=i.y;p<c&&(i.y=t.plotY+17)}}return i},getAnchorPostHook:function(e,n,t){return e&&!l["default"].isArray(e)&&"column"===e.series.options.type&&(t[0]=e.barX),t}},getConfig:function(){var e=this.properties.mode;return o["default"].extend(!0,{},this.BASE_CONFIG,{backgroundColor:(0,h.getThemeProperty)("TOOLTIP_BACKGROUND_COLOR"),borderColor:(0,h.getThemeProperty)("TOOLTIP_BORDER_COLOR"),style:{color:(0,h.getThemeProperty)("TOOLTIP_FONT_COLOR_SOFT")}},{borderColor:this.properties.borderColor},d[e])},destroy:function(){}},n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(){return"dark"===(0,v.getCurrentTheme)()?x["default"].resetZoomButtonDark:x["default"].resetZoomButton}function a(e,n){this.id=h["default"].uniqueId("selection_window"),this.hcChart=e,this.renderer=e.renderer,this.axis=e.xAxis[0],this.axisHasTickmarksBetween="between"===this.axis.options.tickmarkPlacement,this.axisValueOffset=this.axis.tickmarkOffset,this.axisValueSnapper=n,this.isiOS=!!u["default"].ios;var t=void 0,i=void 0;this.pointer=e.pointer,this.pointer.selectionMarker.renderer?(this.zIndex=this.pointer.selectionMarker.attr("zIndex"),t=this.pointer.selectionMarker.attr("x"),i=this.pointer.selectionMarker.attr("width")):(this.zIndex=7,t=this.pointer.selectionMarker.x,i=this.pointer.selectionMarker.width);var r=t,a=this.snapXValue(r+i,this.axisHasTickmarksBetween?"ceil":"round","max");this.x=this.snapXValue(r,this.axisHasTickmarksBetween?"floor":"round","min"),this.width=a-this.x,this.createResizeHandles(),this.ownedElements=[this.resizeHandleLeft.element,this.resizeHandleRight.element],this.updateExtremesValues();var o=(0,s["default"])(this.hcChart.container);this.defaultContainerCursor=o.css("cursor"),o.on("mousemove."+this.id,(0,h["default"])(this.onContainerMouseMove).bind(this)),this.initialized=!0}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=i(o),l=t(1),h=i(l),d=t(12),c=i(d),p=t(46),u=i(p),f=t(9),m=i(f),g=t(50),x=i(g),b=t(92),y=i(b),v=t(5);a.prototype=s["default"].extend({},m["default"],{handleWidth:u["default"].ios?25:10,handleHeight:50,handleBorderColor:"rgb(255,255,255)",handleBgColor:"rgba(79,79,79,0.5)",handleBorderRadius:5,shadedAreaColor:"rgba(100,100,100,0.3)",handleDragStartEvent:function(e){var n=e.target,t=n===this.hcChart.chartBackground.element&&this.hcChart.isInsidePlot(e.chartX-this.hcChart.plotLeft,e.chartY-this.hcChart.plotTop);return!(!t&&!(0,h["default"])(this.ownedElements).contains(n))&&(this.originalTarget=n,this.mouseDownX=this.getCurrentX(),this.mouseDownWidth=this.getCurrentWidth(),this.isDragging=!0,!0)},handleDragEvent:function(e){this.originalTarget===this.hcChart.chartBackground.element&&this.dragSelectionMarker(e),this.originalTarget===this.resizeHandleLeft.element&&this.resizeSelectionLeft(e),this.originalTarget===this.resizeHandleRight.element&&this.resizeSelectionRight(e)},handleDropEvent:function(){this.isDragging&&(this.updateExtremesValues(),this.emitSelectionEvent(),this.isDragging=!1)},getExtremes:function(){return{min:this.startValue,max:this.endValue}},setExtremes:function(e){this.startValue=e.min,this.endValue=e.max},onContainerMouseMove:function(e){e=this.pointer.normalize(e),e.target===this.hcChart.chartBackground.element&&this.hcChart.isInsidePlot(e.chartX-this.hcChart.plotLeft,e.chartY-this.hcChart.plotTop)?(0,s["default"])(this.hcChart.container).css("cursor","move"):(0,s["default"])(this.hcChart.container).css("cursor",this.defaultContainerCursor)},onChartRedraw:function(){this.axisValueOffset=this.axis.tickmarkOffset,this.x=Math.round(this.axis.toPixels(this.startValue+this.axisValueOffset)),this.width=Math.round(this.axis.toPixels(this.endValue+this.axisValueOffset))-this.x,this.resizeHandleLeft.attr({y:this.hcChart.plotTop+this.hcChart.plotHeight/2-this.handleHeight/2}),this.resizeHandleRight.attr({y:this.hcChart.plotTop+this.hcChart.plotHeight/2-this.handleHeight/2}),this.shadedRegionLeft.attr({x:this.hcChart.plotLeft,y:this.hcChart.plotTop,height:this.hcChart.plotHeight}),this.shadedRegionRight.attr({y:this.hcChart.plotTop,
height:this.hcChart.plotHeight}),this.positionResizeHandles("both")},destroy:function(){this.initialized&&(this.resizeHandleLeft.destroy(),this.resizeHandleRight.destroy(),this.handleVerticalLineLeft.destroy(),this.handleVerticalLineRight.destroy(),this.shadedRegionRight.destroy(),this.shadedRegionLeft.destroy(),this.$resetButton.remove(),this.initialized=!1),(0,s["default"])(this.hcChart.container).off("mousemove."+this.id),this.off()},dragSelectionMarker:function(e){var n=this.getChartMouseDownX();this.x=this.snapXValue(this.mouseDownX+e.chartX-n,"round"),this.x=Math.max(this.x,this.hcChart.plotLeft),this.x=Math.min(this.x,this.hcChart.plotLeft+this.hcChart.plotWidth-this.getCurrentWidth()),this.positionResizeHandles("both")},resizeSelectionLeft:function(e){var n=this.getCurrentX(),t=this.getCurrentWidth(),i=this.getChartMouseDownX();this.x=this.snapXValue(this.mouseDownX+e.chartX-i,"round"),this.x=Math.max(this.x,this.hcChart.plotLeft);var r=n+t;this.x=Math.min(this.x,this.axis.toPixels(this.axis.toValue(r)-1)),this.width=t-this.x+n,this.positionResizeHandles("left")},resizeSelectionRight:function(e){this.x=this.getCurrentX();var n=this.getChartMouseDownX(),t=this.mouseDownWidth+e.chartX-n,i=this.snapXValue(this.x+t,"round");this.width=i-this.x,this.width=Math.min(this.width,this.hcChart.plotLeft+this.hcChart.plotWidth-this.x),this.width=Math.max(this.width,this.axis.toPixels(1)-this.axis.toPixels(0)),this.positionResizeHandles("right")},getChartMouseDownX:function(){return this.pointer.pinchDown[0]?this.pointer.pinchDown[0].chartX:this.pointer.mouseDownX},emitSelectionEvent:function(){var e=this.axis,n=e.toValue(this.x)+this.axisValueOffset,t=e.toValue(this.x+this.width)-this.axisValueOffset;this.trigger("rangeSelect",[n,t])},createResizeHandles:function(){var e={zIndex:this.zIndex+1,fill:{linearGradient:{x1:0,y1:.5,x2:1,y2:.5},stops:[[0,this.handleBgColor],[1/6,this.handleBorderColor],[2/6,this.handleBgColor],[.5,this.handleBorderColor],[4/6,this.handleBgColor],[5/6,this.handleBorderColor],[1,this.handleBgColor]]},"stroke-width":2,stroke:this.handleBgColor},n={"stroke-width":2,stroke:this.handleBgColor,zIndex:this.zIndex},t={zIndex:this.zIndex,fill:this.shadedAreaColor},i=this.hcChart.plotTop+this.hcChart.plotHeight/2-this.handleHeight/2;this.shadedRegionRight=this.renderer.rect(0,this.hcChart.plotTop,0,this.hcChart.plotHeight).attr(t).add(),this.handleVerticalLineRight=this.renderer.path().attr(n).add(),this.resizeHandleRight=this.renderer.rect(0,i,this.handleWidth,this.handleHeight,this.handleBorderRadius).attr(e).css({cursor:"ew-resize"}).add(),this.shadedRegionLeft=this.renderer.rect(this.hcChart.plotLeft,this.hcChart.plotTop,0,this.hcChart.plotHeight).attr(t).add(),this.handleVerticalLineLeft=this.renderer.path().attr(n).add(),this.resizeHandleLeft=this.renderer.rect(0,i,this.handleWidth,this.handleHeight,this.handleBorderRadius).attr(e).css({cursor:"ew-resize"}).add(),this.positionResizeHandles("both"),this.$resetButton=(0,s["default"])((0,h["default"])(this.resetButtonTemplate).template({i18n:c["default"],getThemedResetZoomButtonCls:r})),this.$resetButton.on("click",function(e){e.preventDefault()}),this.$resetButton.css({top:this.hcChart.yAxis[0].top+"px",right:this.hcChart.xAxis[0].right+"px",position:"absolute"}),this.$resetButton.appendTo(this.hcChart.container)},positionResizeHandles:function(e){var n=this.x,t=n+this.width,i=this.hcChart.plotTop,r=i+this.hcChart.plotHeight,a=this.hcChart.plotLeft,o=a+this.hcChart.plotWidth;"both"!==e&&"left"!==e||(this.shadedRegionLeft.attr({width:n-a}),this.handleVerticalLineLeft.attr({d:["M",n,i,"L",n,r]}),this.resizeHandleLeft.attr({x:n-this.handleWidth/2})),"both"!==e&&"right"!==e||(this.shadedRegionRight.attr({x:t,width:o-t}),this.handleVerticalLineRight.attr({d:["M",t,i,"L",t,r]}),this.resizeHandleRight.attr({x:t-this.handleWidth/2}))},getCurrentX:function(){return this.resizeHandleLeft.attr("x")+this.handleWidth/2},getCurrentWidth:function(){return this.resizeHandleRight.attr("x")+this.handleWidth/2-this.getCurrentX()},snapXValue:function(e,n){var t=this.axis,i=t.toValue(e);return t.toPixels(this.axisValueSnapper(i-this.axisValueOffset,n)+this.axisValueOffset)},updateExtremesValues:function(){this.startValue=Math.round(this.axis.toValue(this.x)-this.axisValueOffset),this.endValue=Math.round(this.axis.toValue(this.x+this.width)-this.axisValueOffset)},resetButtonTemplate:'<button class="<%= getThemedResetZoomButtonCls() %>" name="reset-zoom"><span class="'+x["default"].resetZoomIcon+'">'+y["default"]+'</span><%= i18n._("Reset") %></button>'}),n["default"]=a,e.exports=n["default"]},function(e,n,t){(function(e){function n(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}var t={lite:".button_button-styles__guid__7f3b26{-webkit-animation:none 0s ease 0s 1 normal none running;animation:none 0s ease 0s 1 normal none running;-webkit-backface-visibility:visible;backface-visibility:visible;background:transparent none repeat 0 0/auto auto padding-box border-box scroll;border:medium none currentColor;border-collapse:separate;-webkit-border-image:none;border-image:none;border-radius:0;border-spacing:0;bottom:auto;box-shadow:none;box-sizing:content-box;caption-side:top;clear:none;clip:auto;color:#000;-webkit-columns:auto;columns:auto;-webkit-column-count:auto;column-count:auto;-webkit-column-fill:balance;column-fill:balance;-webkit-column-gap:normal;column-gap:normal;-webkit-column-rule:medium none currentColor;column-rule:medium none currentColor;-webkit-column-span:1;column-span:1;-webkit-column-width:auto;column-width:auto;content:normal;counter-increment:none;counter-reset:none;cursor:auto;direction:ltr;display:inline;empty-cells:show;float:none;font-family:serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:400;font-stretch:normal;line-height:normal;height:auto;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;left:auto;letter-spacing:normal;list-style:disc outside none;margin:0;max-height:none;max-width:none;min-height:0;min-width:0;opacity:1;orphans:2;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;-webkit-perspective:none;perspective:none;-webkit-perspective-origin:50% 50%;perspective-origin:50% 50%;position:static;right:auto;-moz-tab-size:8;tab-size:8;table-layout:auto;text-align:left;text-align-last:auto;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;top:auto;-webkit-transform:none;transform:none;-webkit-transform-origin:50% 50% 0;transform-origin:50% 50% 0;-webkit-transform-style:flat;transform-style:flat;-webkit-transition:none 0s ease 0s;transition:none 0s ease 0s;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:2;width:auto;word-spacing:normal;z-index:auto;font-family:Splunk Platform Sans,Proxima Nova,Roboto,Droid,Helvetica Neue,Helvetica,Arial,sans-serif;font-size:14px;line-height:20px;color:#3c444d;box-sizing:border-box;display:inline-block;border-width:1px;visibility:inherit;outline:medium none #00a4fd;outline:medium none invert;background:rgba(60,68,77,.4);border-radius:3px;color:#fff;cursor:pointer;font-size:12px;line-height:27px;padding:0 10px;z-index:9999}.button_button-styles__guid__7f3b26::-moz-focus-inner{border:0;padding:0}.button_button-styles__guid__7f3b26:active,.button_button-styles__guid__7f3b26:hover{background:rgba(60,68,77,.35);color:#fff}.button_button-styles__guid__7f3b26:focus{border-color:rgba(0,164,253,.8);color:#00a4fd}.button_button-styles__guid__7f3b26[disabled]{background:transparent;color:#c3cbd4;cursor:default}.button_button-styles__guid__7f3b26[disabled]:hover{background:transparent;color:#c3cbd4;cursor:default}.button-dark-theme_button-styles__guid__7f3b26{background:#3c444d}.button-dark-theme_button-styles__guid__7f3b26:active,.button-dark-theme_button-styles__guid__7f3b26:hover{background:#5c6773;color:#fff}.button-dark-theme_button-styles__guid__7f3b26:focus{background:#2b3033;color:#006eaa}.panButton_button-styles__guid__7f3b26{border-radius:1px;line-height:10px;padding:4px 5px}.panButtonDark_button-styles__guid__7f3b26{border-radius:1px;line-height:10px;padding:4px 5px}.resetZoomButton_button-styles__guid__7f3b26{margin-top:5px;margin-right:10px}.resetZoomButtonDark_button-styles__guid__7f3b26{margin-top:5px;margin-right:10px}.resetZoomIcon_button-styles__guid__7f3b26{margin-right:3px}",enterprise:".button_button-styles__guid__7f3b26{-webkit-animation:none 0s ease 0s 1 normal none running;animation:none 0s ease 0s 1 normal none running;-webkit-backface-visibility:visible;backface-visibility:visible;background:transparent none repeat 0 0/auto auto padding-box border-box scroll;border:medium none currentColor;border-collapse:separate;-webkit-border-image:none;border-image:none;border-radius:0;border-spacing:0;bottom:auto;box-shadow:none;box-sizing:content-box;caption-side:top;clear:none;clip:auto;color:#000;-webkit-columns:auto;columns:auto;-webkit-column-count:auto;column-count:auto;-webkit-column-fill:balance;column-fill:balance;-webkit-column-gap:normal;column-gap:normal;-webkit-column-rule:medium none currentColor;column-rule:medium none currentColor;-webkit-column-span:1;column-span:1;-webkit-column-width:auto;column-width:auto;content:normal;counter-increment:none;counter-reset:none;cursor:auto;direction:ltr;display:inline;empty-cells:show;float:none;font-family:serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:400;font-stretch:normal;line-height:normal;height:auto;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none;left:auto;letter-spacing:normal;list-style:disc outside none;margin:0;max-height:none;max-width:none;min-height:0;min-width:0;opacity:1;orphans:2;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;-webkit-perspective:none;perspective:none;-webkit-perspective-origin:50% 50%;perspective-origin:50% 50%;position:static;right:auto;-moz-tab-size:8;tab-size:8;table-layout:auto;text-align:left;text-align-last:auto;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;top:auto;-webkit-transform:none;transform:none;-webkit-transform-origin:50% 50% 0;transform-origin:50% 50% 0;-webkit-transform-style:flat;transform-style:flat;-webkit-transition:none 0s ease 0s;transition:none 0s ease 0s;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:2;width:auto;word-spacing:normal;z-index:auto;font-family:Splunk Platform Sans,Proxima Nova,Roboto,Droid,Helvetica Neue,Helvetica,Arial,sans-serif;font-size:14px;line-height:20px;color:#3c444d;box-sizing:border-box;display:inline-block;border-width:1px;visibility:inherit;outline:medium none #00a4fd;outline:medium none invert;background:rgba(60,68,77,.4);border-radius:3px;color:#fff;cursor:pointer;font-size:12px;line-height:27px;padding:0 10px;z-index:9999}.button_button-styles__guid__7f3b26::-moz-focus-inner{border:0;padding:0}.button_button-styles__guid__7f3b26:active,.button_button-styles__guid__7f3b26:hover{background:rgba(60,68,77,.35);color:#fff}.button_button-styles__guid__7f3b26:focus{border-color:rgba(0,164,253,.8);color:#00a4fd}.button_button-styles__guid__7f3b26[disabled]{background:transparent;color:#c3cbd4;cursor:default}.button_button-styles__guid__7f3b26[disabled]:hover{background:transparent;color:#c3cbd4;cursor:default}.button-dark-theme_button-styles__guid__7f3b26{background:#3c444d}.button-dark-theme_button-styles__guid__7f3b26:active,.button-dark-theme_button-styles__guid__7f3b26:hover{background:#5c6773;color:#fff}.button-dark-theme_button-styles__guid__7f3b26:focus{background:#2b3033;color:#006eaa}.panButton_button-styles__guid__7f3b26{border-radius:1px;line-height:10px;padding:4px 5px}.panButtonDark_button-styles__guid__7f3b26{border-radius:1px;line-height:10px;padding:4px 5px}.resetZoomButton_button-styles__guid__7f3b26{margin-top:5px;margin-right:10px}.resetZoomButtonDark_button-styles__guid__7f3b26{margin-top:5px;margin-right:10px}.resetZoomIcon_button-styles__guid__7f3b26{margin-right:3px}"},i={lite:{button:"button_button-styles__guid__7f3b26","button-dark-theme":"button-dark-theme_button-styles__guid__7f3b26 button_button-styles__guid__7f3b26",panButton:"panButton_button-styles__guid__7f3b26 button_button-styles__guid__7f3b26",panButtonDark:"panButtonDark_button-styles__guid__7f3b26 button-dark-theme_button-styles__guid__7f3b26 button_button-styles__guid__7f3b26",resetZoomButton:"resetZoomButton_button-styles__guid__7f3b26 button_button-styles__guid__7f3b26",resetZoomButtonDark:"resetZoomButtonDark_button-styles__guid__7f3b26 button-dark-theme_button-styles__guid__7f3b26 button_button-styles__guid__7f3b26",resetZoomIcon:"resetZoomIcon_button-styles__guid__7f3b26"},enterprise:{button:"button_button-styles__guid__7f3b26","button-dark-theme":"button-dark-theme_button-styles__guid__7f3b26 button_button-styles__guid__7f3b26",panButton:"panButton_button-styles__guid__7f3b26 button_button-styles__guid__7f3b26",panButtonDark:"panButtonDark_button-styles__guid__7f3b26 button-dark-theme_button-styles__guid__7f3b26 button_button-styles__guid__7f3b26",resetZoomButton:"resetZoomButton_button-styles__guid__7f3b26 button_button-styles__guid__7f3b26",resetZoomButtonDark:"resetZoomButtonDark_button-styles__guid__7f3b26 button-dark-theme_button-styles__guid__7f3b26 button_button-styles__guid__7f3b26",resetZoomIcon:"resetZoomIcon_button-styles__guid__7f3b26"}},r=window.__splunkd_partials__&&window.__splunkd_partials__["/services/server/info"]&&window.__splunkd_partials__["/services/server/info"].entry[0].content.product_type,a=window.__splunk_ui_theme__,o=window.$C&&window.$C.SPLUNK_UI_THEME,s=a||o||r,l="lite"===s?"lite":"enterprise",h=e.guid||n()+n()+n()+n();Object.keys(i[l]).forEach(function(e){var n=i[l][e];i[l][e]=n.replace(/_guid_/g,h)}),t[l]=t[l].replace(/_guid_/g,h),e.exports=[[e.i,t[l],""]],e.exports.locals=i[l],e.guid=h}).call(n,t(44)(e))},function(e,n,t){function i(e,n){for(var t=0;t<e.length;t++){var i=e[t],r=f[i.id];if(r){r.refs++;for(var a=0;a<r.parts.length;a++)r.parts[a](i.parts[a]);for(;a<i.parts.length;a++)r.parts.push(d(i.parts[a],n))}else{for(var o=[],a=0;a<i.parts.length;a++)o.push(d(i.parts[a],n));f[i.id]={id:i.id,refs:1,parts:o}}}}function r(e,n){for(var t=[],i={},r=0;r<e.length;r++){var a=e[r],o=n.base?a[0]+n.base:a[0],s=a[1],l=a[2],h=a[3],d={css:s,media:l,sourceMap:h};i[o]?i[o].parts.push(d):t.push(i[o]={id:o,parts:[d]})}return t}function a(e,n){var t=x(e.insertInto);if(!t)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var i=v[v.length-1];if("top"===e.insertAt)i?i.nextSibling?t.insertBefore(n,i.nextSibling):t.appendChild(n):t.insertBefore(n,t.firstChild),v.push(n);else{if("bottom"!==e.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");t.appendChild(n)}}function o(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e);var n=v.indexOf(e);n>=0&&v.splice(n,1)}function s(e){var n=document.createElement("style");return e.attrs.type="text/css",h(n,e.attrs),a(e,n),n}function l(e){var n=document.createElement("link");return e.attrs.type="text/css",e.attrs.rel="stylesheet",h(n,e.attrs),a(e,n),n}function h(e,n){Object.keys(n).forEach(function(t){e.setAttribute(t,n[t])})}function d(e,n){var t,i,r,a;if(n.transform&&e.css){if(a=n.transform(e.css),!a)return function(){};e.css=a}if(n.singleton){var h=y++;t=b||(b=s(n)),i=c.bind(null,t,h,!1),r=c.bind(null,t,h,!0)}else e.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(t=l(n),i=u.bind(null,t,n),r=function(){o(t),t.href&&URL.revokeObjectURL(t.href)}):(t=s(n),i=p.bind(null,t),r=function(){o(t)});return i(e),function(n){if(n){if(n.css===e.css&&n.media===e.media&&n.sourceMap===e.sourceMap)return;i(e=n)}else r()}}function c(e,n,t,i){var r=t?"":i.css;if(e.styleSheet)e.styleSheet.cssText=k(n,r);else{var a=document.createTextNode(r),o=e.childNodes;o[n]&&e.removeChild(o[n]),o.length?e.insertBefore(a,o[n]):e.appendChild(a)}}function p(e,n){var t=n.css,i=n.media;if(i&&e.setAttribute("media",i),e.styleSheet)e.styleSheet.cssText=t;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(t))}}function u(e,n,t){var i=t.css,r=t.sourceMap,a=void 0===n.convertToAbsoluteUrls&&r;(n.convertToAbsoluteUrls||a)&&(i=w(i)),r&&(i+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */");var o=new Blob([i],{type:"text/css"}),s=e.href;e.href=URL.createObjectURL(o),s&&URL.revokeObjectURL(s)}var f={},m=function(e){var n;return function(){return"undefined"==typeof n&&(n=e.apply(this,arguments)),n}},g=m(function(){return window&&document&&document.all&&!window.atob}),x=function(e){var n={};return function(t){return"undefined"==typeof n[t]&&(n[t]=e.call(this,t)),n[t]}}(function(e){return document.querySelector(e)}),b=null,y=0,v=[],w=t(197);e.exports=function(e,n){n=n||{},n.attrs="object"==typeof n.attrs?n.attrs:{},n.singleton||(n.singleton=g()),n.insertInto||(n.insertInto="head"),n.insertAt||(n.insertAt="bottom");var t=r(e,n);return i(t,n),function(e){for(var a=[],o=0;o<t.length;o++){var s=t[o],l=f[s.id];l.refs--,a.push(l)}if(e){var h=r(e,n);i(h,n)}for(var o=0;o<a.length;o++){var l=a[o];if(0===l.refs){for(var d=0;d<l.parts.length;d++)l.parts[d]();delete f[l.id]}}}};var k=function(){var e=[];return function(n,t){return e[n]=t,e.filter(Boolean).join("\n")}}()},function(e,n){e.exports=function(e){var n="undefined"!=typeof window&&window.location;if(!n)throw new Error("fixUrls requires window.location");if(!e||"string"!=typeof e)return e;var t=n.protocol+"//"+n.host,i=t+n.pathname.replace(/\/[^\/]*$/,"/"),r=e.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(e,n){var r=n.trim().replace(/^"(.*)"$/,function(e,n){return n}).replace(/^'(.*)'$/,function(e,n){return n});if(/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(r))return e;var a;return a=0===r.indexOf("//")?r:0===r.indexOf("/")?t+r:i+r.replace(/^\.\//,""),"url("+JSON.stringify(a)+")"});return r}},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(){return"dark"===(0,v.getCurrentTheme)()?m["default"].panButtonDark:m["default"].panButton}function a(e,n){this.hcChart=e,this.distanceResolver=n,this.initialize()}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=i(o),l=t(1),h=i(l),d=t(12),c=i(d),p=t(9),u=i(p),f=t(50),m=i(f),g=t(199),x=i(g),b=t(200),y=i(b),v=t(5);a.prototype=s["default"].extend({},u["default"],{initialize:function(){var e=this.hcChart.xAxis[0],n=e.getExtremes(),t='<button class="'+r()+'" name="pan-left" title="'+c["default"]._("Pan Left")+'">'+x["default"]+"</button>",i='<button class="'+r()+'" name="pan-right" title="'+c["default"]._("Pan Right")+'">'+y["default"]+"</button>";this.panRightButton||(this.panRightButton=(0,s["default"])(i),("between"===this.hcChart.xAxis[0].options.tickmarkPlacement&&n.max>=n.dataMax||"on"===this.hcChart.xAxis[0].options.tickmarkPlacement&&n.max>n.dataMax)&&this.panRightButton.attr("disabled","disabled"),(0,s["default"])(this.hcChart.container).append(this.panRightButton)),this.panLeftButton||(this.panLeftButton=(0,s["default"])(t),n.min<=n.dataMin&&this.panLeftButton.attr("disabled","disabled"),(0,s["default"])(this.hcChart.container).append(this.panLeftButton));var a=this;this.debouncedPanLeft=h["default"].debounce(function(){a.handlePan("left"),a.positionButtons()}),this.debouncedPanRight=h["default"].debounce(function(){a.handlePan("right"),a.positionButtons()}),this.positionButtons(),this.bindPanListeners()},positionButtons:function(){var e=this.hcChart.legend.options,n=this.hcChart.plotHeight+this.hcChart.plotTop+4,t=this.hcChart.xAxis[0].left-20,i=this.hcChart.xAxis[0].right-("right"===e.align?20:0);this.panRightButton.css({position:"absolute",top:n+"px",right:i+"px"}),this.panLeftButton.css({position:"absolute",top:n+"px",left:t+"px"})},handlePan:function(e){var n=this.hcChart.xAxis[0],t=n.getExtremes(),i=Math.round(t.min),r=Math.round(t.max),a=this.distanceResolver(n,e),o=void 0,s=void 0,l=void 0,d=void 0,c=void 0;"left"===e?(d=t.dataMin,s=Math.max(d,i-a.min),l=r-a.max,s<i&&(s<=d&&this.panLeftButton.attr("disabled","disabled"),this.panRightButton.attr("disabled")&&this.panRightButton.removeAttr("disabled"),o=!0)):"right"===e&&(c=t.dataMax+("between"===this.hcChart.xAxis[0].options.tickmarkPlacement?0:1),h["default"].has(this.hcChart.xAxis[0].options,"max")&&(c=Math.max(c,this.hcChart.xAxis[0].options.max)),l=Math.min(c,r+a.max),s=i+a.min,l>r&&(l>=c&&this.panRightButton.attr("disabled","disabled"),this.panLeftButton.attr("disabled")&&this.panLeftButton.removeAttr("disabled"),o=!0)),n.setExtremes(s,l,!1,!1,{trigger:"pan"}),o&&this.hcChart.redraw(!1)},bindPanListeners:function(){var e=this,n=void 0,t=function(){n&&clearInterval(n)},i=this.hcChart.xAxis[0],r=void 0;this.panLeftButton&&(this.panLeftButton.on("click",function(n){n.preventDefault(),e.debouncedPanLeft()}),this.panLeftButton.on("mousedown",function(){t(),n=window.setInterval(function(){e.handlePan("left")},200)}),this.panLeftButton.on("mouseup",function(){t(),r=i.getExtremes(),e.trigger("pan",[r.min,r.max])})),this.panRightButton&&(this.panRightButton.on("click",function(n){n.preventDefault(),e.debouncedPanRight()}),this.panRightButton.on("mousedown",function(){t(),n=window.setInterval(function(){e.handlePan("right")},200)}),this.panRightButton.on("mouseup",function(){t(),r=i.getExtremes(),e.trigger("pan",[r.min,r.max])}))},onChartResize:function(){this.panLeftButton&&this.panRightButton&&this.positionButtons()},onChartRedraw:function(){this.panLeftButton&&this.panRightButton&&this.positionButtons()},destroy:function(){this.panLeftButton&&(this.panLeftButton.remove(),this.panLeftButton=void 0),this.panRightButton&&(this.panRightButton.remove(),this.panRightButton=void 0),this.off()}}),n["default"]=a,e.exports=n["default"]},function(e,n){e.exports='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 885 1500" width="6px" height="10px"><path d="M 751.027 1500 L 0 750 750 0 l 134.59 134.59 L 269.177 750 l 615.41 615.41" fill="currentColor"></path></svg>'},function(e,n){e.exports='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 885 1500" width="6px" height="10px"><path d="M134.59 0 l 750 750 -751.028 750 L 0 1365.41 615.41 750 0 134.59" fill="currentColor"></path></svg>'},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){this.hcChart=e,this.initialize(),this.debouncedZoomOut=l["default"].debounce(function(){e.zoomOut()})}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(12),d=i(h),c=t(9),p=i(c),u=t(50),f=i(u),m=t(92),g=i(m),x=t(5);r.prototype=o["default"].extend({},p["default"],{initialize:function(){var e=this.hcChart.xAxis[0];e.getExtremes();var n='<button class="'+("dark"===(0,x.getCurrentTheme)()?f["default"].resetZoomButtonDark:f["default"].resetZoomButton)+'" name="reset-zoom"><span class="'+f["default"].resetZoomIcon+'">'+g["default"]+"</span>"+d["default"]._("Reset Zoom")+"</button>";this.zoomOutBtn||(this.zoomOutBtn=(0,o["default"])(n),(0,o["default"])(this.hcChart.container).append(this.zoomOutBtn));var t=this.hcChart.yAxis[0].top,i=this.hcChart.xAxis[0].right;this.zoomOutBtn.css({position:"absolute",top:t+"px",right:i+"px"}),this.addEventHandlers()},addEventHandlers:function(){var e=this;this.zoomOutBtn&&this.zoomOutBtn.on("click",function(n){n.preventDefault(),e.debouncedZoomOut()})},destroy:function(){this.zoomOutBtn&&(this.zoomOutBtn.remove(),this.zoomOutBtn=void 0),this.off()}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){c["default"].call(this,e),this.showLabels=e.showLabels,this.splitSeries=e.splitSeries}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(2),d=t(93),c=i(d),p=t(5);(0,h.inherit)(r,c["default"]),r.prototype=o["default"].extend(r.prototype,{onChartLoadOrRedraw:function(e){"minmax"===this.showLabels&&this.displayMinMax(e.series),"all"===this.showLabels&&this.removeRepeatedZeroValues(e.series)},destroy:function(){this.off()},onChartLoad:function(){},displayMinMax:function(e){var n=l["default"].flatten(l["default"].pluck(e,"points"));l["default"].each(n,function(e){e.dataLabel&&e.dataLabel.element&&e.dataLabel.element.setAttribute("display","none")});var t=void 0,i=void 0,r=e.length,a=[],o=[];for(t=0;t<r;t++){var s=void 0,h=void 0,d=e[t].xAxis.getExtremes(),c=d.userMin||d.dataMin,p=d.userMax||d.dataMax;for(o=[],i=0;i<e[t].points.length;i++)s=e[t].points[i],h=s.x,h>=c&&h<=p&&o.push(s);a.push(o)}for(this.splitSeries||(a=[l["default"].flatten(a)]),t=0;t<a.length;t++){var u=l["default"].filter(a[t],function(e){return!l["default"].isNull(e.y)&&e.dataLabel}),f=l["default"].min(u,function(e){return e.y}),m=l["default"].max(u,function(e){return e.y});m.dataLabel&&m.dataLabel.element.removeAttribute("display"),f.dataLabel&&f.dataLabel.element.removeAttribute("display")}},getConfig:function(){return o["default"].extend(!0,c["default"].prototype.getConfig.call(this),{style:{color:(0,p.getThemeProperty)("DEFAULT_FONT_COLOR"),fontWeight:"normal",textOutline:"none"},allowOverlap:!0})},removeRepeatedZeroValues:function(e){var n=l["default"].flatten(l["default"].pluck(e,"points"));l["default"].each(n,function(e){e.dataLabel&&e.dataLabel.element&&e.dataLabel.element.removeAttribute("display")});var t=l["default"].min(l["default"].pluck(n,"y"));t>=0&&l["default"].each(n,function(e){0===e.y&&e.dataLabel&&e.dataLabel.element&&e.dataLabel.element.setAttribute("display","none")})}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0});var r=t(204),a=i(r),o=t(205),s=i(o),l=t(94),h=i(l),d=t(96),c=i(d),p=t(206),u=i(p),f=t(98),m=i(f),g=t(226),x=i(g),b=t(227),y=i(b);n["default"]={create:function(e){return"column"===e.type?new a["default"](e):"bar"===e.type?new s["default"](e):"line"===e.type?new h["default"](e):"area"===e.type?new c["default"](e):"pie"===e.type?new u["default"](e):"scatter"===e.type?new m["default"](e):"bubble"===e.type?new x["default"](e):"range"===e.type?new y["default"](e):new a["default"](e)}},e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){c["default"].call(this,e)}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(2),d=t(51),c=i(d);(0,h.inherit)(r,c["default"]),o["default"].extend(r.prototype,{CHARTING_PROPERTY_WHITELIST:l["default"].union(["columnSpacing"],c["default"].prototype.CHARTING_PROPERTY_WHITELIST),type:"column",getConfig:function(){var e=c["default"].prototype.getConfig.call(this);return e.pointPadding=this.computeColumnSpacing(this.properties.columnSpacing),e.groupPadding=this.computeColumnGroupSpacing(this.properties.seriesSpacing),e},bringToFront:function(){}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){c["default"].call(this,e)}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(2),d=t(51),c=i(d);(0,h.inherit)(r,c["default"]),o["default"].extend(r.prototype,{CHARTING_PROPERTY_WHITELIST:l["default"].union(["barSpacing"],c["default"].prototype.CHARTING_PROPERTY_WHITELIST),type:"bar",getConfig:function(){var e=c["default"].prototype.getConfig.call(this);return e.pointPadding=this.computeBarSpacing(this.properties.barSpacing),e.groupPadding=this.computeBarGroupSpacing(this.properties.seriesSpacing),e},bringToFront:function(){}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){g["default"].call(this,e)}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(2),c=t(3),p=i(c),u=t(47),f=i(u),m=t(97),g=r(m);(0,d.inherit)(a,g["default"]),s["default"].extend(a.prototype,{UNHIGHLIGHTED_OPACITY:1,UNHIGHLIGHTED_BASE_COLOR:"rgb(225, 225, 225)",CHARTING_PROPERTY_WHITELIST:h["default"].union(["sliceCollapsingThreshold","sliceCollapsingLabel","showPercent"],g["default"].prototype.CHARTING_PROPERTY_WHITELIST),type:"pie",hasPrettyData:!1,fieldList:[],processProperties:function(){if(this.collapseFieldName=this.properties.sliceCollapsingLabel||"other",this.collapsePercent=.01,this.properties.hasOwnProperty("sliceCollapsingThreshold")){var e=parseFloat(this.properties.sliceCollapsingThreshold);e>=0&&e<=1&&(this.collapsePercent=e)}},getConfig:function(){return s["default"].extend(g["default"].prototype.getConfig.call(this),{translatePreHook:(0,h["default"])(this.translatePreHook).bind(this)})},setData:function(e){var n=this,t=this.data;this.data=[],this.prettyData=[];var i=this,r=e.names,a=e.sizes,o=e.spans,s=e.isTimeBased,l=(0,h["default"])(a).reduce(function(e,n){return e+n},0),d=a.length,c=0,u=0,m=0,g=null,x=function(e){return e>0&&e/l>i.collapsePercent};if(s&&(g=f.determineLabelGranularity(r),this.hasPrettyData=!0),this.fieldList=(0,h["default"])(r).map(p.escapeSVG,p),(0,h["default"])(a).each(function(e,n){x(a[n])||m++},this),(0,h["default"])(r).each(function(e,t){var i=a[t];if(x(i)||1===m||d<=10)if(s){var r=f.extractBdTime(e),l=f.formatBdTimeAsAxisLabel(r,null,g).join(" "),p=o[t];n.data.push([e,i,p]),n.prettyData.push([l,i,p])}else n.data.push([e,i]);else c+=i,u++,n.fieldList=(0,h["default"])(n.fieldList).without(e)}),u>0){var b=this.collapseFieldName+" ("+u+")";this.data.push([b,c]),this.prettyData.push([b,c,null]),this.fieldList.push("__other")}h["default"].isEqual(this.data,t)||(this._dataIsDirty=!0)},getFieldList:function(){return this.fieldList},getData:function(){return this.data},getPrettyData:function(){return this.prettyData},highlightPoint:function(e){if(e.graphic){var n=e.color;e.graphic.attr({fill:n,"stroke-width":0,stroke:n})}},getTooltipRows:function(e){return[[e.sliceFieldName,e.sliceName],[{text:e.seriesName,color:e.sliceColor},e.yValue],[{text:e.seriesName+"%",color:e.sliceColor},e.yPercent]]},translatePreHook:function(e){var n=e.chart;e.options.dataLabels.enabled?e.options.size=Math.min(.75*n.plotHeight,n.plotWidth/3):e.options.size=Math.min(.75*n.plotHeight,.75*n.plotWidth)}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){e.exports={"default":t(208),__esModule:!0}},function(e,n,t){t(209),t(219),e.exports=t(16).Array.from},function(e,n,t){"use strict";var i=t(210)(!0);t(211)(String,"String",function(e){this._t=String(e),this._i=0},function(){var e,n=this._t,t=this._i;return t>=n.length?{value:void 0,done:!0}:(e=i(n,t),this._i+=e.length,{value:e,done:!1})})},function(e,n,t){var i=t(35),r=t(34);e.exports=function(e){return function(n,t){var a,o,s=String(r(n)),l=i(t),h=s.length;return l<0||l>=h?e?"":void 0:(a=s.charCodeAt(l),a<55296||a>56319||l+1===h||(o=s.charCodeAt(l+1))<56320||o>57343?e?s.charAt(l):a:e?s.slice(l,l+2):(a-55296<<10)+(o-56320)+65536)}}},function(e,n,t){"use strict";var i=t(212),r=t(30),a=t(213),o=t(17),s=t(21),l=t(52),h=t(214),d=t(100),c=t(218),p=t(11)("iterator"),u=!([].keys&&"next"in[].keys()),f="@@iterator",m="keys",g="values",x=function(){return this};e.exports=function(e,n,t,b,y,v,w){h(t,n,b);var k,S,T,O=function(e){if(!u&&e in L)return L[e];switch(e){case m:return function(){return new t(this,e)};case g:return function(){return new t(this,e)}}return function(){return new t(this,e)}},M=n+" Iterator",P=y==g,A=!1,L=e.prototype,_=L[p]||L[f]||y&&L[y],C=_||O(y),H=y?P?O("entries"):C:void 0,I="Array"==n?L.entries||_:_;if(I&&(T=c(I.call(new e)),
T!==Object.prototype&&T.next&&(d(T,M,!0),i||s(T,p)||o(T,p,x))),P&&_&&_.name!==g&&(A=!0,C=function(){return _.call(this)}),i&&!w||!u&&!A&&L[p]||o(L,p,C),l[n]=C,l[M]=x,y)if(k={values:P?C:O(g),keys:v?C:O(m),entries:H},w)for(S in k)S in L||a(L,S,k[S]);else r(r.P+r.F*(u||A),n,k);return k}},function(e,n){e.exports=!0},function(e,n,t){e.exports=t(17)},function(e,n,t){"use strict";var i=t(215),r=t(33),a=t(100),o={};t(17)(o,t(11)("iterator"),function(){return this}),e.exports=function(e,n,t){e.prototype=i(o,{next:r(1,t)}),a(e,n+" Iterator")}},function(e,n,t){var i=t(19),r=t(216),a=t(63),o=t(36)("IE_PROTO"),s=function(){},l="prototype",h=function(){var e,n=t(55)("iframe"),i=a.length,r="<",o=">";for(n.style.display="none",t(217).appendChild(n),n.src="javascript:",e=n.contentWindow.document,e.open(),e.write(r+"script"+o+"document.F=Object"+r+"/script"+o),e.close(),h=e.F;i--;)delete h[l][a[i]];return h()};e.exports=Object.create||function(e,n){var t;return null!==e?(s[l]=i(e),t=new s,s[l]=null,t[o]=e):t=h(),void 0===n?t:r(t,n)}},function(e,n,t){var i=t(18),r=t(19),a=t(56);e.exports=t(20)?Object.defineProperties:function(e,n){r(e);for(var t,o=a(n),s=o.length,l=0;s>l;)i.f(e,t=o[l++],n[t]);return e}},function(e,n,t){var i=t(13).document;e.exports=i&&i.documentElement},function(e,n,t){var i=t(21),r=t(37),a=t(36)("IE_PROTO"),o=Object.prototype;e.exports=Object.getPrototypeOf||function(e){return e=r(e),i(e,a)?e[a]:"function"==typeof e.constructor&&e instanceof e.constructor?e.constructor.prototype:e instanceof Object?o:null}},function(e,n,t){"use strict";var i=t(54),r=t(30),a=t(37),o=t(220),s=t(221),l=t(60),h=t(222),d=t(223);r(r.S+r.F*!t(225)(function(e){Array.from(e)}),"Array",{from:function(e){var n,t,r,c,p=a(e),u="function"==typeof this?this:Array,f=arguments.length,m=f>1?arguments[1]:void 0,g=void 0!==m,x=0,b=d(p);if(g&&(m=i(m,f>2?arguments[2]:void 0,2)),void 0==b||u==Array&&s(b))for(n=l(p.length),t=new u(n);n>x;x++)h(t,x,g?m(p[x],x):p[x]);else for(c=b.call(p),t=new u;!(r=c.next()).done;x++)h(t,x,g?o(c,m,[r.value,x],!0):r.value);return t.length=x,t}})},function(e,n,t){var i=t(19);e.exports=function(e,n,t,r){try{return r?n(i(t)[0],t[1]):n(t)}catch(a){var o=e["return"];throw void 0!==o&&i(o.call(e)),a}}},function(e,n,t){var i=t(52),r=t(11)("iterator"),a=Array.prototype;e.exports=function(e){return void 0!==e&&(i.Array===e||a[r]===e)}},function(e,n,t){"use strict";var i=t(18),r=t(33);e.exports=function(e,n,t){n in e?i.f(e,n,r(0,t)):e[n]=t}},function(e,n,t){var i=t(224),r=t(11)("iterator"),a=t(52);e.exports=t(16).getIteratorMethod=function(e){if(void 0!=e)return e[r]||e["@@iterator"]||a[i(e)]}},function(e,n,t){var i=t(59),r=t(11)("toStringTag"),a="Arguments"==i(function(){return arguments}()),o=function(e,n){try{return e[n]}catch(t){}};e.exports=function(e){var n,t,s;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(t=o(n=Object(e),r))?t:a?i(n):"Object"==(s=i(n))&&"function"==typeof n.callee?"Arguments":s}},function(e,n,t){var i=t(11)("iterator"),r=!1;try{var a=[7][i]();a["return"]=function(){r=!0},Array.from(a,function(){throw 2})}catch(o){}e.exports=function(e,n){if(!n&&!r)return!1;var t=!1;try{var a=[7],o=a[i]();o.next=function(){return{done:t=!0}},a[i]=function(){return o},e(a)}catch(s){}return t}},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e,n){c["default"].call(this,e,n)}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(2),d=t(97),c=i(d),p=t(98),u=i(p);(0,h.inherit)(r,c["default"]),o["default"].extend(r.prototype,{HIGHLIGHTED_OPACITY:.5,type:"bubble",setData:function(e){var n=this.data;this.data=(0,l["default"])(e.x).map(function(n,t){return[n,e.y[t],e.z[t]]}),l["default"].isEqual(this.data,n)||(this._dataIsDirty=!0)},getTooltipRows:function(e){for(var n,t=arguments.length,i=Array(t>1?t-1:0),r=1;r<t;r++)i[r-1]=arguments[r];var a=(n=u["default"].prototype.getTooltipRows).call.apply(n,[this,e].concat(i));return a.push([e.zAxisName,e.zValue]),a}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){this.threshold=0,u["default"].call(this,e)}function a(e){u["default"].call(this,e)}function o(e){x["default"].call(this,e),this.rangeStackId=d["default"].uniqueId("rangeStack_"),this.predictedSeries=new m["default"](this.getPredictedSeriesProperties()),this.lowerSeries=new r(this.getLowerSeriesProperties()),this.upperSeries=new a(this.getUpperSeriesProperties()),this.nestedSeriesList=[this.upperSeries,this.lowerSeries,this.predictedSeries],this.bindNestedSeries()}Object.defineProperty(n,"__esModule",{value:!0});var s=t(0),l=i(s),h=t(1),d=i(h),c=t(2),p=t(96),u=i(p),f=t(94),m=i(f),g=t(228),x=i(g);(0,c.inherit)(r,u["default"]),l["default"].extend(r.prototype,{HIGHLIGHTED_OPACITY:0,UNHIGHLIGHTED_OPACITY:0,UNHIGHLIGHTED_LINE_OPACITY:.25,normalizeProperties:function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];return l["default"].extend({},u["default"].prototype.normalizeProperties.apply(this,n),{lineStyle:"dashed",stacking:"stacked"})},setData:function(e){u["default"].prototype.setData.call(this,e);var n=(0,d["default"])(e.y).min(),t=this.threshold;this.threshold=Math.min(n,0),this.threshold!==t&&(this._isDirty=!0)},getConfig:function(){var e=u["default"].prototype.getConfig.call(this);return e.showInLegend=!1,e.threshold=this.threshold,e.stack=this.properties.stack,e}}),(0,c.inherit)(a,u["default"]),l["default"].extend(a.prototype,{HIGHLIGHTED_OPACITY:.25,UNHIGHLIGHTED_OPACITY:.1,UNHIGHLIGHTED_LINE_OPACITY:.25,normalizeProperties:function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];return l["default"].extend({},u["default"].prototype.normalizeProperties.apply(this,n),{lineStyle:"dashed",stacking:"stacked"})},getConfig:function(){var e=u["default"].prototype.getConfig.call(this);return e.showInLegend=!1,e.stack=this.properties.stack,e}}),(0,c.inherit)(o,x["default"]),l["default"].extend(o.prototype,{type:"range",update:function(e){this.properties=this.normalizeProperties(e),this.predictedSeries.update(this.getPredictedSeriesProperties()),this.lowerSeries.update(this.getLowerSeriesProperties()),this.upperSeries.update(this.getUpperSeriesProperties())},setData:function(e){this.predictedSeries.setData({y:e.predicted,x:e.x}),this.lowerSeries.setData({y:e.lower,x:e.x}),e.upper=(0,d["default"])(e.upper).map(function(n,t){if((0,d["default"])(n).isNull())return null;var i=n-e.lower[t];return Math.max(i,0)}),this.upperSeries.setData({y:e.upper,x:e.x})},getPredictedSeriesProperties:function(){return this.properties},getLowerSeriesProperties:function(){return l["default"].extend({},this.properties,{name:this.properties.names.lower,legendKey:this.predictedSeries.getLegendKey(),stack:this.rangeStackId})},getUpperSeriesProperties:function(){return l["default"].extend({},this.properties,{name:this.properties.names.upper,legendKey:this.predictedSeries.getLegendKey(),stack:this.rangeStackId})},getFieldList:function(){return this.predictedSeries.getFieldList()},applyColorMapping:function(e){this.predictedSeries.applyColorMapping(e);var n=this.predictedSeries.getColor(),t={},i={};t[this.lowerSeries.getName()]=n,this.lowerSeries.applyColorMapping(t),i[this.upperSeries.getName()]=n,this.upperSeries.applyColorMapping(i)},handlePointMouseOver:function(){this.bringToFront(),this.highlight()},handlePointMouseOut:function(){},handleLegendMouseOver:function(){this.bringToFront(),this.highlight()},handleLegendMouseOut:function(){}}),n["default"]=o,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){c["default"].call(this,e),this.nestedSeriesList=[]}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(2),d=t(29),c=i(d);(0,h.inherit)(r,c["default"]),o["default"].extend(r.prototype,{normalizeProperties:function(e){return e},isDirty:function(){return(0,l["default"])(this.nestedSeriesList).any(function(e){return e.isDirty()})},dataIsDirty:function(){return(0,l["default"])(this.nestedSeriesList).any(function(e){return e.dataIsDirty()})},getFieldList:function(){return(0,l["default"])(this.nestedSeriesList).invoke("getFieldList")},applyColorMapping:function(e){(0,l["default"])(this.nestedSeriesList).invoke("applyColorMapping",e)},matchesName:function(e){return(0,l["default"])(this.nestedSeriesList).any(function(n){return n.matchesName(e)})},getConfig:function(){return(0,l["default"])(this.nestedSeriesList).invoke("getConfig")},bindNestedSeries:function(){var e=this;(0,l["default"])(this.nestedSeriesList).each(function(n){n.on("mouseover",function(n,t,i){e.trigger(n,[t,i])}),n.on("mouseout",function(n,t,i){e.trigger(n,[t,i])}),n.on("click",function(n,t,i){e.trigger(n,[t,i])})})},handlePointMouseOver:function(e){var n=e.seriesName;(0,l["default"])(this.nestedSeriesList).each(function(t){t.matchesName(n)?t.handlePointMouseOver(e):t.unHighlight()})},handlePointMouseOut:function(e){var n=e.seriesName;(0,l["default"])(this.nestedSeriesList).each(function(t){t.matchesName(n)?t.handlePointMouseOut(e):t.highlight()})},handleLegendMouseOver:function(e){(0,l["default"])(this.nestedSeriesList).each(function(n){n.matchesName(e)?n.handleLegendMouseOver(e):n.unHighlight()})},handleLegendMouseOut:function(e){(0,l["default"])(this.nestedSeriesList).each(function(n){n.matchesName(e)?n.handleLegendMouseOut(e):n.highlight()})},onChartLoad:function(e){(0,l["default"])(this.nestedSeriesList).invoke("onChartLoad",e)},onChartLoadOrRedraw:function(e){(0,l["default"])(this.nestedSeriesList).invoke("onChartLoadOrRedraw",e)},redraw:function(e){(0,l["default"])(this.nestedSeriesList).invoke("redraw",e)},destroy:function(){this.off(),(0,l["default"])(this.nestedSeriesList).invoke("destroy")},bringToFront:function(){(0,l["default"])(this.nestedSeriesList).invoke("bringToFront")},highlight:function(){(0,l["default"])(this.nestedSeriesList).invoke("highlight")},unHighlight:function(){(0,l["default"])(this.nestedSeriesList).invoke("unHighlight")}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,n){g["default"].call(this,e,n)}Object.defineProperty(n,"__esModule",{value:!0});var o=t(99),s=r(o),l=t(0),h=r(l),d=t(1),c=r(d),p=t(2),u=t(3),f=i(u),m=t(27),g=r(m);(0,p.inherit)(a,g["default"]),h["default"].extend(a.prototype,{interAxisSpacing:10,shouldUpdateInPlace:function(){return!!this.selectionWindow&&(this.hcChart&&!this.isDirty())},processProperties:function(){g["default"].prototype.processProperties.call(this),this.allowIndependentYRanges=f.normalizeBoolean(this.properties["layout.splitSeries.allowIndependentYRanges"],!1)},initializeSeriesPropertiesList:function(){var e=g["default"].prototype.initializeSeriesPropertiesList.call(this);return(0,c["default"])(e).each(function(e,n){e.yAxis=n}),e},initializeYAxisProperties:function(e,n){var t=h["default"].extend(f.getYAxisProperties(this.properties,0),this.axisColorScheme,{"axis.orientation":this.axesAreInverted?"horizontal":"vertical",isEmpty:n,opposite:!1});return t},setAllSeriesData:function(){var e=this;g["default"].prototype.setAllSeriesData.call(this),this.globalMin=1/0,this.globalMax=-(1/0),(0,c["default"])(this.yFields).each(function(n,t){var i=e.yAxisList[t],r=e.formatNumericAxisData(i,n);e.globalMin=Math.min(e.globalMin,Math.min.apply(Math,(0,s["default"])(r))),e.globalMax=Math.max(e.globalMax,Math.max.apply(Math,(0,s["default"])(r)))})},getYAxisConfig:function(){var e=g["default"].prototype.getYAxisConfig.call(this);return(0,c["default"])(e).each(function(e,n){h["default"].extend(e,{opposite:!1,offset:0,setSizePreHook:(0,c["default"])(function(e){h["default"].extend(e.options,this.getAdjustedAxisPosition(e,n,this.yAxisList.length))}).bind(this)});var t=e.getSeriesExtremesPostHook;e.getSeriesExtremesPostHook=(0,c["default"])(function(e){this.allowIndependentYRanges||"stacked100"===this.stackMode||(e.dataMax=Math.max(e.dataMax,this.globalMax),e.dataMin=Math.min(e.dataMin,this.globalMin)),t&&t(e)}).bind(this)},this),e},getSeriesConfigList:function(){var e=this,n=g["default"].prototype.getSeriesConfigList.call(this);return(0,c["default"])(n).each(function(n){n.afterAnimatePostHook=(0,c["default"])(e.updateSeriesClipRect).bind(e),n.renderPostHook=(0,c["default"])(e.updateSeriesClipRect).bind(e),n.destroyPreHook=(0,c["default"])(e.destroySplitSeriesClipRect).bind(e)}),n},getAdjustedAxisPosition:function(e,n,t){var i=e.chart;if(i.inverted){var r=i.plotWidth,a=(r-this.interAxisSpacing*(t-1))/t;return{left:i.plotLeft+(a+this.interAxisSpacing)*n,width:a}}var o=i.plotHeight,s=(o-this.interAxisSpacing*(t-1))/t;return{top:i.plotTop+(s+this.interAxisSpacing)*n,height:s}},getTooltipConfig:function(){var e=g["default"].prototype.getTooltipConfig.call(this),n=this;return e.getAnchorPostHook=function(e,t,i){return n.axesAreInverted&&(i[0]=e.series.yAxis.left+(e.pointWidth||0)),i},e},updateSeriesClipRect:function(e){var n=e.chart,t=e.yAxis;this.destroySplitSeriesClipRect(e),n.inverted?e.splitSeriesClipRect=n.renderer.clipRect(0,-0,n.plotHeight,t.width):e.splitSeriesClipRect=n.renderer.clipRect(0,0,n.plotWidth,t.height),e.group.clip(e.splitSeriesClipRect)},destroySplitSeriesClipRect:function(e){e.hasOwnProperty("splitSeriesClipRect")&&(e.splitSeriesClipRect.destroy(),delete e.splitSeriesClipRect)}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,n){k["default"].call(this,e,n)}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(12),c=r(d),p=t(8),u=r(p),f=t(2),m=t(3),g=i(m),x=t(47),b=r(x),y=t(4),v=i(y),w=t(27),k=r(w),S=t(231),T=r(S),O=t(28),M=r(O);(0,f.inherit)(a,k["default"]),s["default"].extend(a.prototype,{SLICE_NAME_FIELD_INDEX:0,SLICE_SIZE_FIELD_INDEX:1,hasLegend:!1,hasXAxis:!1,hasYAxis:!1,shouldUpdateInPlace:function(){return!1},processProperties:function(){k["default"].prototype.processProperties.call(this),this.showLabels=!this.isEmpty()&&g.normalizeBoolean(this.properties["chart.showLabels"],!0)},prepare:function(e,n){k["default"].prototype.prepare.call(this,e,n),this.showLabels&&this.initializeDataLabels()},handleDraw:function(e){return this.destroyCustomRenderer(),this.isEmpty()?(this.benchmark("Draw Started"),this.drawEmptyPieChart(),this.benchmark("Draw Finished"),void e(this,this.benchmarks)):void k["default"].prototype.handleDraw.call(this,e)},initializeFields:function(){var e=this.dataSet.allDataFields();this.sliceNameField=e[this.SLICE_NAME_FIELD_INDEX],this.sliceSizeField=e[this.SLICE_SIZE_FIELD_INDEX]},isEmpty:function(){return!!this.dataSet&&(!this._sizeValuesAreNumeric()||this.dataSet.allDataFields().length<2)},hasTimeXAxis:function(){return!1},_sizeValuesAreNumeric:function(){return v.valuesAreNumeric(this.dataSet.seriesList[this.SLICE_SIZE_FIELD_INDEX])},_getInvalidDataMessage:function(){return!this.dataSet||this.dataSet.allDataFields().length<2?c["default"]._("No Results"):this._sizeValuesAreNumeric()?c["default"]._("Invalid Data"):c["default"]._("Numeric Data Required")},shouldProgressiveDraw:function(){return!1},initializeSeriesPropertiesList:function(){var e=s["default"].extend({},this.properties,{name:this.sliceSizeField,type:"pie",clickEnabled:this.chartClickEnabled});return[e]},setAllSeriesData:function(){var e=this.seriesIsTimeBased(this.sliceNameField),n=void 0;e&&(n=this.dataSet.getSeriesAsFloats("_span")),this.seriesList[0].setData({names:this.dataSet.getSeries(this.sliceNameField),sizes:this.dataSet.getSeriesAsFloats(this.sliceSizeField,{nullValueMode:"zero"}),spans:n,isTimeBased:e})},handlePointMouseOver:function(e){this.seriesList[0].handlePointMouseOver(e),this.dataLabels&&this.dataLabels.selectLabel(e)},handlePointMouseOut:function(e){this.seriesList[0].handlePointMouseOut(e),this.dataLabels&&this.dataLabels.unSelectLabel(e)},handlePointClick:function(e,n){var t=n.originalIndex,i=this.seriesList[0].getData()[t],r=i[0],a=i[1].toString(),o=new RegExp("^"+this.seriesList[0].collapseFieldName),s={},l={type:"pointClick",modifierKey:e.modifierKey,name:this.sliceNameField,name2:this.sliceSizeField,value2:a,rowContext:s};if(this.seriesIsTimeBased(this.sliceNameField)&&!o.test(i[0])){var h=i[0];l.value=b["default"].getEpochTimeFromISO(h),l._span=i[2],s["row."+this.sliceNameField]=l.value}else l.value=r,s["row."+this.sliceNameField]=r;s["row."+this.sliceSizeField]=a,this.trigger(l)},initializeDataLabels:function(){var e={fontColor:this.fontColor,foregroundColorSoft:this.foregroundColorSoft,clickEnabled:g.normalizeBoolean(this.properties["chart.clickEnabled"])||g.normalizeBoolean(this.properties.enableChartClick)};this.dataLabels&&this.dataLabels.destroy(),this.dataLabels=new T["default"](e);var n=this,t={highlightDelay:75,unhighlightDelay:50,onMouseOver:function(e){n.seriesList[0].selectPoint(e)},onMouseOut:function(e){n.seriesList[0].unSelectPoint(e)}},i=new M["default"](t);this.dataLabels.on("mouseover",function(e,n){i.mouseOverHappened(n)}),this.dataLabels.on("mouseout",function(e,n){i.mouseOutHappened(n)})},getPlotOptionsConfig:function(){var e=this;return{pie:{dataLabels:s["default"].extend(this.getDataLabelConfig(),{formatter:function(){var n=this;return g.escapeSVG(e.formatDataLabel(n))}}),borderWidth:0,stickyTracking:!1,cursor:this.chartClickEnabled?"pointer":"default",states:{hover:{brightness:0}},tooltip:{followPointer:!1}}}},getDataLabelConfig:function(){return this.showLabels?this.dataLabels.getConfig():{enabled:!1}},applyColorPalette:function(){this.BASE_CONFIG=s["default"].extend({},this.BASE_CONFIG,{colors:(0,h["default"])(this.getFieldList()).map(this.computeFieldColor,this)})},addPercentToName:function(e,n){return g.normalizeBoolean(this.properties["chart.showPercent"])?e+", "+c["default"].format_percent(n/100):e},formatDataLabel:function(e){return this.addPercentToName(e.point.name,e.percentage)},getSeriesPointInfo:function(e,n){var t=n.index,i=e.hasPrettyData?e.getPrettyData()[t]:e.getData()[t],r=this.addPercentToName(i[0],n.percentage),a=i[1];return{sliceFieldName:this.sliceNameField,sliceName:r,sliceColor:n.color,yValue:c["default"].format_decimal(a),yPercent:c["default"].format_percent(n.percentage/100)}},drawEmptyPieChart:function(){var e=this.$container.width(),n=this.$container.height(),t=Math.min(.75*n,e/3)/2;this.renderer=new u["default"].Renderer(this.container,e,n),this.renderer.circle(e/2,n/2,t).attr({fill:"rgba(150, 150, 150, 0.3)",stroke:"rgb(200, 200, 200)","stroke-width":1,title:c["default"]._("Invalid data: second column must be numeric for a pie chart")}).add(),this.renderer.text(this._getInvalidDataMessage(),e/2,n/2).attr({align:"center"}).css({fontSize:"20px",color:"rgb(200, 200, 200)"}).add()},setSize:function(e,n){this.isEmpty()?(this.destroyCustomRenderer(),this.drawEmptyPieChart()):k["default"].prototype.setSize.call(this,e,n)},destroy:function(){this.destroyCustomRenderer(),k["default"].prototype.destroy.call(this)},destroyCustomRenderer:function(){this.renderer&&(this.renderer.destroy(),this.renderer=null,this.$container.empty())}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){m["default"].call(this,e),this.id=l["default"].uniqueId("data_labels_")}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(10),d=i(h),c=t(2),p=t(28),u=i(p),f=t(93),m=i(f),g=t(5);(0,c.inherit)(r,m["default"]),r.prototype=o["default"].extend(r.prototype,{HIGHLIGHTED_OPACITY:1,UNHIGHLIGHTED_OPACITY:.3,getConfig:function(){return{color:this.properties.fontColor||(0,g.getThemeProperty)("DEFAULT_FONT_COLOR"),connectorColor:this.properties.foregroundColorSoft,connectorPadding:5,softConnector:!1,distance:20,style:{cursor:this.properties.clickEnabled?"pointer":"default",fontWeight:"normal",textOutline:"none",HcTextStroke:!0},x:.01,drawDataLabelsPreHook:(0,l["default"])(this.drawDataLabelsPreHook).bind(this),drawDataLabelsPostHook:(0,l["default"])(this.drawDataLabelsPostHook).bind(this),placeDataLabelsPreHook:(0,l["default"])(this.placeDataLabelsPreHook).bind(this)}},onChartLoad:function(){},onChartLoadOrRedraw:function(e){this.removeEventHandlers(),this.hcSeries=e.series[0],this.addEventHandlers()},addEventHandlers:function(){var e=this,n=this,t={highlightDelay:125,unhighlightDelay:50,onMouseOver:function(e){n.selectLabel(e),n.trigger("mouseover",[e])},onMouseOut:function(e){n.unSelectLabel(e),n.trigger("mouseout",[e])}},i=new u["default"](t);(0,l["default"])(this.hcSeries.data).each(function(t){var r=t.dataLabel.element;(0,o["default"])(r).on("mouseover."+e.id,function(){i.mouseOverHappened(t)}),(0,o["default"])(r).on("mouseout."+e.id,function(){i.mouseOutHappened(t)}),(0,o["default"])(r).on("click."+e.id,function(){n.trigger("click",[t])})})},removeEventHandlers:function(){var e=this;this.hcSeries&&(0,l["default"])(this.hcSeries.data).each(function(n){var t=n.dataLabel.element;(0,o["default"])(t).off("."+e.id)})},destroy:function(){this.off(),this.removeEventHandlers(),this.hcSeries=null},selectLabel:function(e){var n=this,t=this.hcSeries.data[e.index];t.dataLabel.attr("fill-opacity",this.HIGHLIGHTED_OPACITY),(0,l["default"])(this.hcSeries.data).chain().without(t).each(function(e){e.dataLabel.attr("fill-opacity",n.UNHIGHLIGHTED_OPACITY)})},unSelectLabel:function(e){var n=this,t=this.hcSeries.data[e.index];(0,l["default"])(this.hcSeries.data).chain().without(t).each(function(e){e.dataLabel.attr("fill-opacity",n.HIGHLIGHTED_OPACITY)})},drawDataLabelsPreHook:function(e){var n=e.chart,t=e.options.dataLabels.distance,i=e.center,r=i[2]/2;e.getX=function(e,a){return n.plotLeft+i[0]+(a?-r-t:r+t/2)},this.fitLabelsToPlotArea(e)},fitLabelsToPlotArea:function(e){var n=void 0,t=e.options,i=t.dataLabels.distance,r=t.size,a=e.chart,s=a.renderer,l=new d["default"](s),h=11,c=9,p=(a.plotWidth-(r+2*i))/2,u=[];for(n=0;n<e.data.length;n++)"undefined"!=typeof e.options.data[n][0]?u.push(e.options.data[n][0]):u.push(e.options.data[n].name);var f=l.adjustLabels(u,p,c,h,"middle");for(n=0;n<e.data.length;n++)e.data[n].name=f.labels[n],e.data[n].dataLabel&&e.data[n].dataLabel.css&&e.data[n].dataLabel.css({fontSize:f.fontSize+"px"});o["default"].extend(!0,t.dataLabels,{style:{fontSize:f.fontSize+"px"},y:Math.floor(f.fontSize/4)-3}),l.destroy()},placeDataLabelsPreHook:function(e){e.points.forEach(function(e){e.dataLabel.sideOverflow=!1})},drawDataLabelsPostHook:function(e){var n=this;(0,l["default"])(e.points).each(function(e){if(e.connector){var t=e.connector.attr("d").split(" ");e.connector.attr({d:n.updateConnectorPath(t)})}})},updateConnectorPath:function(e){var n={x:parseFloat(e[1]),y:parseFloat(e[2])},t={x:parseFloat(e[4]),y:parseFloat(e[5])},i={x:parseFloat(e[7]),y:parseFloat(e[8])},r=(i.y-t.y)/(i.x-t.x),a={x:i.x+(n.y-i.y)/r,y:n.y},o=!l["default"].isFinite(r),s=isNaN(a.x)||n.x>=a.x&&a.x<=i.x||n.x<=a.x&&a.x>=i.x,h=!o&&s?["M",n.x,n.y,"L",i.x,i.y]:["M",n.x,n.y,"L",a.x,a.y,"L",i.x,i.y];return h}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e,n){c["default"].call(this,e,n)}Object.defineProperty(n,"__esModule",{value:!0});var a=t(0),o=i(a),s=t(1),l=i(s),h=t(2),d=t(101),c=i(d),p=t(49),u=i(p);(0,h.inherit)(r,c["default"]),o["default"].extend(r.prototype,{NUM_DIMENSION_FIELDS:3,TYPE:"bubble",initializeNonMarkFields:function(e){c["default"].prototype.initializeNonMarkFields.call(this,e),e.length>this.NUM_DIMENSION_FIELDS?this.zField=e[3]:this.zField=e[2]},isEmpty:function(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];return c["default"].prototype.isEmpty.apply(this,n)||(0,l["default"])(this.zField).isUndefined()},processProperties:function(){c["default"].prototype.processProperties.call(this);var e={bubbleMaximumSize:50,bubbleMinimumSize:10,bubbleSizeBy:"area"};this.bubbleMaximumSize=this.properties["chart.bubbleMaximumSize"]&&parseInt(this.properties["chart.bubbleMaximumSize"],10),this.bubbleMinimumSize=this.properties["chart.bubbleMinimumSize"]&&parseInt(this.properties["chart.bubbleMinimumSize"],10),this.bubbleSizeBy=this.properties["chart.bubbleSizeBy"]||e.bubbleSizeBy,(isNaN(this.bubbleMaximumSize)||this.bubbleMaximumSize<=0)&&(this.bubbleMaximumSize=e.bubbleMaximumSize),(isNaN(this.bubbleMinimumSize)||this.bubbleMinimumSize<=0)&&(this.bubbleMinimumSize=e.bubbleMinimumSize),"diameter"===this.bubbleSizeBy?this.bubbleSizeBy="width":"area"!==this.bubbleSizeBy&&(this.bubbleSizeBy=e.bubbleSizeBy)},setAllSeriesData:function(){var e=this,n=this.formatNumericAxisData(this.xAxisList[0],this.xField),t=this.formatNumericAxisData(this.yAxisList[0],this.yField),i=this.formatNumericAxisData(this.yAxisList[0],this.zField);this.isMultiSeries?(0,l["default"])(this.seriesList).each(function(r){var a=r.getName();r.setData({x:e.filterDataByNameMatch(n,a),y:e.filterDataByNameMatch(t,a),z:e.filterDataByNameMatch(i,a)})}):this.seriesList[0].setData({x:n,y:t,z:i})},getPlotOptionsConfig:function(){var e=this.bubbleMinimumSize,n=this.bubbleMaximumSize,t=this.bubbleSizeBy;return{bubble:{stickyTracking:!1,minSize:e,maxSize:n,sizeBy:t,tooltip:{followPointer:!1},cursor:this.chartClickEnabled?"pointer":"default"}}},getSeriesPointInfo:function(e,n){for(var t,i=arguments.length,r=Array(i>2?i-2:0),a=2;a<i;a++)r[a-2]=arguments[a];var o=(t=c["default"].prototype.getSeriesPointInfo).call.apply(t,[this,e,n].concat(r)),s=n.index,l=e.getName(),h=this.dataSet.getSeries(this.zField),d=this.isMultiSeries?this.filterDataByNameMatch(h,l)[s]:h[s];return o.zAxisName=this.zField,o.zValue=u["default"].formatNumber(d),o}}),n["default"]=r,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,n){f["default"].call(this,e,n)}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(1),h=r(l),d=t(2),c=t(4),p=i(c),u=t(53),f=r(u);(0,d.inherit)(a,f["default"]),s["default"].extend(a.prototype,{showMinorTicksByDefault:!1,updateDimensions:function(){f["default"].prototype.updateDimensions.call(this),this.width<this.height&&this.width>=this.MIN_GAUGE_HEIGHT&&(this.$container.height(this.width),this.height=this.width)},processProperties:function(){f["default"].prototype.processProperties.call(this),this.verticalPadding=10,this.minorsPerMajor=10,this.tickWidth=1,this.startAngle=this.computeStartAngle(),this.arcAngle=this.computeArcAngle()},computeStartAngle:function(){var e=parseInt(this.properties["chart.rangeStartAngle"],10);return(0,h["default"])(e).isNaN()&&(e=45),p.degreeToRadian(e+90)},computeArcAngle:function(){var e=parseInt(this.properties["chart.rangeArcAngle"],10)||270;return p.degreeToRadian(e)},renderGauge:function(){f["default"].prototype.renderGauge.call(this),this.borderWidth=p.roundWithMin(this.height/60,3),this.tickOffset=p.roundWithMin(this.height/100,3),this.tickLabelOffset=this.borderWidth,this.tickFontSize=p.roundWithMin(this.height/25,10),this.valueFontSize=p.roundWithMin(this.height/15,15),this.isShiny?(this.needleTailLength=p.roundWithMin(this.height/15,10),this.needleTailWidth=p.roundWithMin(this.height/50,6),this.knobWidth=p.roundWithMin(this.height/30,7)):this.needleWidth=p.roundWithMin(this.height/60,3),this.isShiny?(this.bandOffset=this.borderWidth,this.bandThickness=p.roundWithMin(this.height/40,4)):(this.bandOffset=0,this.bandThickness=p.roundWithMin(this.height/30,7)),this.tickColor=this.isShiny?"silver":this.foregroundColor,this.tickFontColor=this.isShiny?"silver":this.fontColor,this.valueColor=this.isShiny?"#b8b167":this.fontColor,this.tickLength=p.roundWithMin(this.height/20,4),this.minorTickLength=this.tickLength/2,this.radius=(this.height-2*(this.verticalPadding+this.borderWidth))/2,this.valueHeight=this.height-(this.radius/4+this.verticalPadding+this.borderWidth),this.needleLength=this.isShiny?this.radius:this.radius-this.bandThickness/2,this.tickStart=this.radius-this.bandOffset-this.bandThickness-this.tickOffset,this.tickEnd=this.tickStart-this.tickLength,this.tickLabelPosition=this.tickEnd-this.tickLabelOffset,this.minorTickEnd=this.tickStart-this.minorTickLength,this.isShiny&&(this.elements.border=this.renderer.circle(this.width/2,this.height/2,this.radius+this.borderWidth).attr({fill:"#edede7",stroke:"silver","stroke-width":1}).add(),this.elements.background=this.renderer.circle(this.width/2,this.height/2,this.radius).attr({fill:"#000000"}).add()),this.showRangeBand&&this.drawColorBand(),this.drawTicks(),this.drawIndicator(this.value),this.showValue&&this.drawValueDisplay(),this.checkOutOfRange(this.value)},updateValueDisplay:function(e){this.elements.valueDisplay.attr({text:e})},drawColorBand:function(){var e=void 0,n=void 0,t=void 0,i=this.radius-this.bandOffset,r=i-this.bandThickness;for(e=0;e<this.ranges.length-1;e++)n=this.translateValue(this.ranges[e]),t=this.translateValue(this.ranges[e+1]),this.elements["colorBand"+e]=this.renderer.arc(this.width/2,this.height/2,i,r,n,t).attr({fill:this.getColorByIndex(e)}).add()},drawMajorTick:function(e){return this.renderer.path(["M",this.width/2+this.tickStart*Math.cos(e),this.height/2+this.tickStart*Math.sin(e),"L",this.width/2+this.tickEnd*Math.cos(e),this.height/2+this.tickEnd*Math.sin(e)]).attr({stroke:this.tickColor,"stroke-width":this.tickWidth}).add()},drawMajorTickLabel:function(e,n){var t=Math.sin(e),i=this.predictTextWidth(n,this.tickFontSize),r=e<1.5*Math.PI?"left":"right",a=e<1.5*Math.PI?-i/2*t*t:i/2*t*t,o=this.tickFontSize/4*t;return this.renderer.text(n,this.width/2+this.tickLabelPosition*Math.cos(e)+a,this.height/2+(this.tickLabelPosition-4)*t+this.tickFontSize/4-o).attr({align:r}).css({color:this.tickFontColor,fontSize:this.tickFontSize+"px"}).add()},drawMinorTick:function(e){return this.renderer.path(["M",this.width/2+this.tickStart*Math.cos(e),this.height/2+this.tickStart*Math.sin(e),"L",this.width/2+this.minorTickEnd*Math.cos(e),this.height/2+this.minorTickEnd*Math.sin(e)]).attr({stroke:this.tickColor,"stroke-width":this.tickWidth}).add()},drawIndicator:function(e){var n=void 0,t=void 0,i=void 0,r=void 0,a=void 0,o=void 0,s=this.normalizedTranslateValue(e),l=Math.cos(s),h=Math.sin(s);this.isShiny?(n=["M",this.width/2-this.needleTailLength*l,this.height/2-this.needleTailLength*h,"L",this.width/2-this.needleTailLength*l+this.needleTailWidth*h,this.height/2-this.needleTailLength*h-this.needleTailWidth*l,this.width/2+this.needleLength*l,this.height/2+this.needleLength*h,this.width/2-this.needleTailLength*l-this.needleTailWidth*h,this.height/2-this.needleTailLength*h+this.needleTailWidth*l,this.width/2-this.needleTailLength*l,this.height/2-this.needleTailLength*h],r={linearGradient:[this.width/2-this.needleTailLength*l,this.height/2-this.needleTailLength*h,this.width/2-this.needleTailLength*l-this.needleTailWidth*h,this.height/2-this.needleTailLength*h+this.needleTailWidth*l],stops:[[0,"#999999"],[.2,"#cccccc"]]},a=["M",this.width/2-(this.needleTailLength-2)*l,this.height/2-(this.needleTailLength-2)*h,"L",this.width/2+(this.needleLength-this.bandOffset/2)*l,this.height/2+(this.needleLength-this.bandOffset/2)*h],o={linearGradient:[this.width/2+this.knobWidth*h,this.height/2-this.knobWidth*l,this.width/2-this.knobWidth*h,this.height/2+this.knobWidth*l],stops:[[0,"silver"],[.5,"black"],[1,"silver"]]}):(n=["M",this.width/2,this.height/2,"L",this.width/2+l*this.needleLength,this.height/2+h*this.needleLength],t=this.foregroundColor,i=this.needleWidth),this.isShiny&&(this.elements.centerKnob&&this.elements.centerKnob.destroy(),
this.elements.centerKnob=this.renderer.circle(this.width/2,this.height/2,this.knobWidth).attr({fill:o}).add()),this.elements.needle&&this.elements.needle.destroy(),this.elements.needle=this.renderer.path(n).attr({fill:r||"",stroke:t||"","stroke-width":i||""}).add(),this.isShiny&&(this.elements.needleRidge&&this.elements.needleRidge.destroy(),this.elements.needleRidge=this.renderer.path(a).attr({stroke:"#cccccc","stroke-width":1}).add())},drawValueDisplay:function(){var e=this.formatValue(this.value);this.elements.valueDisplay=this.renderer.text(e,this.width/2,this.valueHeight).css({color:this.valueColor,fontSize:this.valueFontSize+"px",lineHeight:this.valueFontSize+"px",fontWeight:"bold"}).attr({align:"center"}).add()},getSVG:function(){return this.elements.centerKnob&&this.elements.centerKnob.attr({fill:"#999999"}),this.elements.needle.attr({fill:"#bbbbbb"}),this.elements.needleRidge&&this.elements.needleRidge.attr({stroke:"#999999"}),f["default"].prototype.getSVG.call(this)},normalizedTranslateValue:function(e){return e<this.ranges[0]?this.translateValue(this.ranges[0]):e>this.ranges[this.ranges.length-1]?this.translateValue(this.ranges[this.ranges.length-1]):this.translateValue(e)},translateValue:function(e){var n=this.ranges[this.ranges.length-1]-this.ranges[0],t=e-this.ranges[0];return this.startAngle+t/n*this.arcAngle}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,n){p["default"].call(this,e,n),this.horizontalPadding=20,this.tickOffset=5,this.tickLength=15,this.tickWidth=1,this.tickLabelOffset=5,this.minorTickLength=Math.floor(this.tickLength/2)}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(2),h=t(4),d=i(h),c=t(102),p=r(c);(0,l.inherit)(a,p["default"]),s["default"].extend(a.prototype,{renderGauge:function(){this.tickFontSize=d.roundWithMinMax(this.width/50,10,20),this.backgroundCornerRad=d.roundWithMinMax(this.width/120,3,5),this.valueFontSize=d.roundWithMinMax(this.width/40,15,25),this.backgroundHeight=3*this.valueFontSize,this.valueBottomPadding=d.roundWithMinMax(this.width/100,5,10),p["default"].prototype.renderGauge.call(this)},drawBackground:function(){var e=this.calculateTickValues(this.ranges[0],this.ranges[this.ranges.length-1],this.MAX_TICKS_PER_RANGE),n=e[e.length-1],t=this.predictTextWidth(this.formatValue(n),this.tickFontSize);this.horizontalPadding=Math.max(this.horizontalPadding,t),this.backgroundWidth=this.width-2*this.horizontalPadding,this.isShiny&&(this.elements.background=this.renderer.rect(this.horizontalPadding,(this.height-this.backgroundHeight)/2,this.backgroundWidth,this.backgroundHeight,this.backgroundCornerRad).attr({fill:"#edede7",stroke:"silver","stroke-width":1}).add()),this.tickStartY=(this.height+this.backgroundHeight)/2+this.tickOffset,this.tickEndY=this.tickStartY+this.tickLength,this.tickLabelStartY=this.tickEndY+this.tickLabelOffset},drawMajorTick:function(e){var n=this.horizontalPadding+e;return this.renderer.path(["M",n,this.tickStartY,"L",n,this.tickEndY]).attr({stroke:this.tickColor,"stroke-width":this.tickWidth}).add()},drawMajorTickLabel:function(e,n){var t=this.horizontalPadding+e;return this.renderer.text(n,t,this.tickLabelStartY+this.tickFontSize).attr({align:"center"}).css({color:this.tickFontColor,fontSize:this.tickFontSize+"px",lineHeight:this.tickFontSize+"px"}).add()},drawMinorTick:function(e){var n=this.horizontalPadding+e;return this.renderer.path(["M",n,this.tickStartY,"L",n,this.tickStartY+this.minorTickLength]).attr({stroke:this.tickColor,"stroke-width":this.minorTickWidth}).add()},drawIndicator:function(e){var n=this.getFillColor(e),t=this.normalizedTranslateValue(e),i=void 0,r=void 0;t>0?(t=Math.max(t,this.backgroundCornerRad),i=this.horizontalPadding+t,r=this.isShiny?["M",this.horizontalPadding+this.backgroundCornerRad,(this.height-this.backgroundHeight-2)/2,"C",this.horizontalPadding+this.backgroundCornerRad,(this.height-this.backgroundHeight-2)/2,this.horizontalPadding,(this.height-this.backgroundHeight-2)/2,this.horizontalPadding,(this.height-this.backgroundHeight-2)/2+this.backgroundCornerRad,"L",this.horizontalPadding,(this.height+this.backgroundHeight)/2-this.backgroundCornerRad,"C",this.horizontalPadding,(this.height+this.backgroundHeight)/2-this.backgroundCornerRad,this.horizontalPadding,(this.height+this.backgroundHeight)/2,this.horizontalPadding+this.backgroundCornerRad,(this.height+this.backgroundHeight)/2,"L",i,(this.height+this.backgroundHeight)/2,i,(this.height-this.backgroundHeight-2)/2,this.horizontalPadding+this.backgroundCornerRad,(this.height-this.backgroundHeight-2)/2]:["M",this.horizontalPadding,(this.height-this.backgroundHeight)/2,"L",i,(this.height-this.backgroundHeight)/2,i,(this.height+this.backgroundHeight)/2,this.horizontalPadding,(this.height+this.backgroundHeight)/2,this.horizontalPadding,(this.height-this.backgroundHeight)/2]):r=[],this.elements.fill&&this.elements.fill.destroy(),this.elements.fill=this.renderer.path(r).attr({fill:n}).add(),this.showValue&&this.drawValueDisplay(e,n,t)},drawValueDisplay:function(e,n,t){var i=this.getDisplayValue(e),r=this.horizontalPadding+t,a=this.getValueColor(n),o=void 0,s=this.formatValue(i),l=this.predictTextWidth(s,this.valueFontSize)+this.valueBottomPadding;t>=l?o=r-l:(o=r+this.valueBottomPadding,a=this.defaultValueColor),this.elements.valueDisplay?this.elements.valueDisplay.attr({text:s,x:o}).css({color:a,fontSize:this.valueFontSize+"px",fontWeight:"bold"}).toFront():this.elements.valueDisplay=this.renderer.text(s,o,this.height/2+this.valueFontSize/4).css({color:a,fontSize:this.valueFontSize+"px",lineHeight:this.valueFontSize+"px",fontWeight:"bold"}).attr({align:"left"}).add()},normalizedTranslateValue:function(e){return e<this.ranges[0]?0:e>this.ranges[this.ranges.length-1]?this.translateValue(this.ranges[this.ranges.length-1]):this.translateValue(e)},translateValue:function(e){var n=this.ranges[this.ranges.length-1]-this.ranges[0],t=e-this.ranges[0];return Math.round(t/n*this.backgroundWidth)}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,n){p["default"].call(this,e,n),this.tickWidth=1}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(2),h=t(4),d=i(h),c=t(102),p=r(c);(0,l.inherit)(a,p["default"]),s["default"].extend(a.prototype,{renderGauge:function(){this.tickOffset=d.roundWithMin(this.height/100,3),this.tickLength=d.roundWithMin(this.height/20,4),this.tickLabelOffset=d.roundWithMin(this.height/60,3),this.tickFontSize=d.roundWithMin(this.height/20,10),this.minorTickLength=this.tickLength/2,this.backgroundCornerRad=d.roundWithMin(this.height/60,3),this.valueBottomPadding=d.roundWithMin(this.height/30,5),this.valueFontSize=d.roundWithMin(this.height/20,12),p["default"].prototype.renderGauge.call(this)},drawBackground:function(){this.verticalPadding=10+this.tickFontSize/2,this.backgroundWidth=d.roundWithMin(this.height/4,50),this.backgroundHeight=this.height-2*this.verticalPadding;var e=this.determineMaxValueWidth(this.ranges,this.valueFontSize)+10;this.backgroundWidth=Math.max(this.backgroundWidth,e),this.isShiny&&(this.elements.background=this.renderer.rect((this.width-this.backgroundWidth)/2,this.verticalPadding,this.backgroundWidth,this.backgroundHeight,this.backgroundCornerRad).attr({fill:"#edede7",stroke:"silver","stroke-width":1}).add()),this.tickStartX=(this.width+this.backgroundWidth)/2+this.tickOffset,this.tickEndX=this.tickStartX+this.tickLength,this.tickLabelStartX=this.tickEndX+this.tickLabelOffset},determineMaxValueWidth:function(e,n){if(this.usePercentageValue)return this.predictTextWidth("100.00%",n);var t=void 0,i=void 0,r=0;for(t=0;t<e.length;t++)i=""+e[t],0!==t&&t!==e.length-1||(i+="0"),r=Math.max(r,this.predictTextWidth(i,n));return r},drawMajorTick:function(e){var n=this.verticalPadding+this.backgroundHeight-e;return this.renderer.path(["M",this.tickStartX,n,"L",this.tickEndX,n]).attr({stroke:this.tickColor,"stroke-width":this.tickWidth}).add()},drawMajorTickLabel:function(e,n){var t=this.verticalPadding+this.backgroundHeight-e;return this.renderer.text(n,this.tickLabelStartX,t+this.tickFontSize/4).attr({align:"left"}).css({color:this.tickFontColor,fontSize:this.tickFontSize+"px",lineHeight:this.tickFontSize+"px"}).add()},drawMinorTick:function(e){var n=this.verticalPadding+this.backgroundHeight-e;return this.renderer.path(["M",this.tickStartX,n,"L",this.tickStartX+this.minorTickLength,n]).attr({stroke:this.tickColor,"stroke-width":this.minorTickWidth}).add()},drawIndicator:function(e){var n=this.getFillColor(e),t=this.normalizedTranslateValue(e),i=void 0,r=void 0;t>0?(t=Math.max(t,this.backgroundCornerRad),i=this.verticalPadding+this.backgroundHeight-t,r=this.isShiny?["M",(this.width-this.backgroundWidth-2)/2,this.height-this.verticalPadding-this.backgroundCornerRad,"C",(this.width-this.backgroundWidth-2)/2,this.height-this.verticalPadding-this.backgroundCornerRad,(this.width-this.backgroundWidth-2)/2,this.height-this.verticalPadding,(this.width-this.backgroundWidth-2)/2+this.backgroundCornerRad,this.height-this.verticalPadding,"L",(this.width+this.backgroundWidth-2)/2-this.backgroundCornerRad,this.height-this.verticalPadding,"C",(this.width+this.backgroundWidth-2)/2-this.backgroundCornerRad,this.height-this.verticalPadding,(this.width+this.backgroundWidth-2)/2,this.height-this.verticalPadding,(this.width+this.backgroundWidth-2)/2,this.height-this.verticalPadding-this.backgroundCornerRad,"L",(this.width+this.backgroundWidth-2)/2,i,(this.width-this.backgroundWidth-2)/2,i,(this.width-this.backgroundWidth-2)/2,this.height-this.verticalPadding-this.backgroundCornerRad]:["M",(this.width-this.backgroundWidth)/2,this.height-this.verticalPadding,"L",(this.width+this.backgroundWidth)/2,this.height-this.verticalPadding,(this.width+this.backgroundWidth)/2,i,(this.width-this.backgroundWidth)/2,i,(this.width-this.backgroundWidth)/2,this.height-this.verticalPadding]):r=[],this.elements.fill&&this.elements.fill.destroy(),this.elements.fill=this.renderer.path(r).attr({fill:n}).add(),this.showValue&&this.drawValueDisplay(e,n)},drawValueDisplay:function(e,n){var t=this.getDisplayValue(e),i=this.normalizedTranslateValue(e),r=this.verticalPadding+this.backgroundHeight-i,a=this.valueFontSize+this.valueBottomPadding,o=this.getValueColor(n),s=void 0,l=this.formatValue(t);i>=a?s=r+a-this.valueBottomPadding:(s=r-this.valueBottomPadding,o=this.defaultValueColor),this.elements.valueDisplay?this.elements.valueDisplay.attr({text:l,y:s}).css({color:o,fontSize:this.valueFontSize+"px",fontWeight:"bold"}).toFront():this.elements.valueDisplay=this.renderer.text(l,this.width/2,s).css({color:o,fontSize:this.valueFontSize+"px",lineHeight:this.valueFontSize+"px",fontWeight:"bold"}).attr({align:"center"}).add()},normalizedTranslateValue:function(e){return e<this.ranges[0]?0:e>this.ranges[this.ranges.length-1]?this.translateValue(this.ranges[this.ranges.length-1])+5:this.translateValue(e)},translateValue:function(e){var n=this.ranges[this.ranges.length-1]-this.ranges[0],t=e-this.ranges[0];return Math.round(t/n*this.backgroundHeight)}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,n){p["default"].call(this,e,n),this.horizontalPadding=20,this.tickOffset=5,this.tickLength=15,this.tickWidth=1,this.tickLabelOffset=5,this.minorTickLength=Math.floor(this.tickLength/2),this.bandHeight=this.isShiny?15:35}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(2),h=t(4),d=i(h),c=t(103),p=r(c);(0,l.inherit)(a,p["default"]),s["default"].extend(a.prototype,{renderGauge:function(){this.markerWindowHeight=d.roundWithMinMax(this.width/30,30,80),this.markerSideWidth=this.markerWindowHeight/2,this.markerSideCornerRad=this.markerSideWidth/3,this.bandOffsetBottom=5+this.markerWindowHeight/2,this.bandOffsetTop=5+this.markerWindowHeight/2,this.tickFontSize=d.roundWithMinMax(this.width/50,10,20),this.backgroundCornerRad=d.roundWithMinMax(this.width/120,3,5),this.valueFontSize=d.roundWithMinMax(this.width/40,15,25),this.valueOffset=this.markerSideWidth+10,this.tickLabelPadding=this.tickFontSize/2,this.bandOffsetX=this.isShiny?this.tickLabelPadding:0,this.backgroundHeight=this.bandOffsetX+this.bandHeight+this.tickOffset+this.tickLength+this.tickLabelOffset+this.tickFontSize+this.tickLabelPadding,p["default"].prototype.renderGauge.call(this)},drawBackground:function(e){e=this.calculateTickValues(this.ranges[0],this.ranges[this.ranges.length-1],this.MAX_TICKS_PER_RANGE);var n=e[e.length-1],t=this.predictTextWidth(this.formatValue(n),this.tickFontSize);this.bandOffsetBottom=Math.max(this.bandOffsetBottom,t),this.bandOffsetTop=Math.max(this.bandOffsetTop,t),this.backgroundWidth=this.width-2*this.horizontalPadding,this.bandWidth=this.backgroundWidth-(this.bandOffsetBottom+this.bandOffsetTop),this.isShiny&&(this.elements.background=this.renderer.rect(this.horizontalPadding,(this.height-this.backgroundHeight)/2,this.backgroundWidth,this.backgroundHeight,this.backgroundCornerRad).attr({fill:"#edede7",stroke:"silver","stroke-width":1}).add())},drawBand:function(){var e=void 0,n=void 0,t=void 0,i=this.horizontalPadding+this.bandOffsetBottom,r=(this.height-this.backgroundHeight)/2+this.bandOffsetX;for(e=0;e<this.ranges.length-1;e++)n=this.translateValue(this.ranges[e]),t=this.translateValue(this.ranges[e+1]),this.elements["colorBand"+e]=this.renderer.rect(i+n,r,t-n,this.bandHeight,this.bandCornerRad).attr({fill:this.getColorByIndex(e)}).add();this.tickStartY=(this.height-this.backgroundHeight)/2+(this.bandOffsetX+this.bandHeight)+this.tickOffset,this.tickEndY=this.tickStartY+this.tickLength,this.tickLabelStartY=this.tickEndY+this.tickLabelOffset},drawMajorTick:function(e){var n=this.horizontalPadding+this.bandOffsetBottom+e;return this.renderer.path(["M",n,this.tickStartY,"L",n,this.tickEndY]).attr({stroke:this.tickColor,"stroke-width":this.tickWidth}).add()},drawMajorTickLabel:function(e,n){var t=this.horizontalPadding+this.bandOffsetBottom+e;return this.renderer.text(n,t,this.tickLabelStartY+this.tickFontSize).attr({align:"center"}).css({color:this.tickFontColor,fontSize:this.tickFontSize+"px",lineHeight:this.tickFontSize+"px"}).add()},drawMinorTick:function(e){var n=this.horizontalPadding+this.bandOffsetBottom+e;return this.renderer.path(["M",n,this.tickStartY,"L",n,this.tickStartY+this.minorTickLength]).attr({stroke:this.tickColor,"stroke-width":this.minorTickWidth}).add()},drawIndicator:function(e){var n=this.normalizedTranslateValue(e),t=this.isShiny?(this.height-this.backgroundHeight)/2:(this.height-this.backgroundHeight)/2-10,i=this.isShiny?t+this.backgroundHeight:t+this.bandHeight+20,r=this.horizontalPadding+this.bandOffsetBottom+n,a=3,o=this.foregroundColor,s=["M",r,t,"L",r,i];if(this.isShiny){var l=["M",r-this.markerWindowHeight/2,t,"L",r-this.markerWindowHeight/2,t-(this.markerSideWidth-this.markerSideCornerRad),"C",r-this.markerWindowHeight/2,t-(this.markerSideWidth-this.markerSideCornerRad),r-this.markerWindowHeight/2,t-this.markerSideWidth,r-this.markerWindowHeight/2+this.markerSideCornerRad,t-this.markerSideWidth,"L",r+this.markerWindowHeight/2-this.markerSideCornerRad,t-this.markerSideWidth,"C",r+this.markerWindowHeight/2-this.markerSideCornerRad,t-this.markerSideWidth,r+this.markerWindowHeight/2,t-this.markerSideWidth,r+this.markerWindowHeight/2,t-(this.markerSideWidth-this.markerSideCornerRad),"L",r+this.markerWindowHeight/2,t,r-this.markerWindowHeight,t],h=["M",r-this.markerWindowHeight/2,i,"L",r-this.markerWindowHeight/2,i+(this.markerSideWidth-this.markerSideCornerRad),"C",r-this.markerWindowHeight/2,i+(this.markerSideWidth-this.markerSideCornerRad),r-this.markerWindowHeight/2,i+this.markerSideWidth,r-this.markerWindowHeight/2+this.markerSideCornerRad,i+this.markerSideWidth,"L",r+this.markerWindowHeight/2-this.markerSideCornerRad,i+this.markerSideWidth,"C",r+this.markerWindowHeight/2-this.markerSideCornerRad,i+this.markerSideWidth,r+this.markerWindowHeight/2,i+this.markerSideWidth,r+this.markerWindowHeight/2,i+(this.markerSideWidth-this.markerSideCornerRad),"L",r+this.markerWindowHeight/2,i,r-this.markerWindowHeight,i],d=["M",r-this.markerWindowHeight/2,t,"L",r-this.markerWindowHeight/2,i,r+this.markerWindowHeight/2,i,r+this.markerWindowHeight/2,t,r-this.markerWindowHeight/2,t],c=["M",r-1,t,"L",r-1,i];o="red",a=1,this.elements.markerLHS&&this.elements.markerLHS.destroy(),this.elements.markerLHS=this.renderer.path(l).attr({fill:"#cccccc"}).add(),this.elements.markerRHS&&this.elements.markerRHS.destroy(),this.elements.markerRHS=this.renderer.path(h).attr({fill:"#cccccc"}).add(),this.elements.markerWindow&&this.elements.markerWindow.destroy(),this.elements.markerWindow=this.renderer.rect(r-this.markerWindowHeight/2,t,this.markerWindowHeight,this.backgroundHeight,0).attr({fill:"rgba(255, 255, 255, 0.3)"}).add(),this.elements.markerBorder&&this.elements.markerBorder.destroy(),this.elements.markerBorder=this.renderer.path(d).attr({stroke:"white","stroke-width":2}).add(),this.elements.markerUnderline&&this.elements.markerUnderline.destroy(),this.elements.markerUnderline=this.renderer.path(c).attr({stroke:"white","stroke-width":2}).add()}this.elements.markerLine&&this.elements.markerLine.destroy(),this.elements.markerLine=this.renderer.path(s).attr({stroke:o,"stroke-width":a}).add(),this.showValue&&this.drawValueDisplay(e)},drawValueDisplay:function(e){var n=this.formatValue(e),t=this.normalizedTranslateValue(e),i=this.horizontalPadding+this.bandOffsetBottom+t;this.elements.valueDisplay?this.elements.valueDisplay.attr({text:n,x:i}):this.elements.valueDisplay=this.renderer.text(n,i,(this.height-this.backgroundHeight)/2-this.valueOffset).css({color:"black",fontSize:this.valueFontSize+"px",lineHeight:this.valueFontSize+"px",fontWeight:"bold"}).attr({align:"center"}).add()},normalizedTranslateValue:function(e){return e<this.ranges[0]?0:e>this.ranges[this.ranges.length-1]?this.translateValue(this.ranges[this.ranges.length-1]):this.translateValue(e)},translateValue:function(e){var n=this.ranges[this.ranges.length-1]-this.ranges[0],t=e-this.ranges[0];return Math.round(t/n*this.bandWidth)}}),n["default"]=a,e.exports=n["default"]},function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e,n){p["default"].call(this,e,n),this.verticalPadding=10}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(2),h=t(4),d=i(h),c=t(103),p=r(c);(0,l.inherit)(a,p["default"]),s["default"].extend(a.prototype,{renderGauge:function(){this.markerWindowHeight=d.roundWithMin(this.height/7,20),this.markerSideWidth=this.markerWindowHeight/2,this.markerSideCornerRad=this.markerSideWidth/3,this.bandOffsetBottom=5+this.markerWindowHeight/2,this.bandOffsetTop=5+this.markerWindowHeight/2,this.tickOffset=d.roundWithMin(this.height/100,3),this.tickLength=d.roundWithMin(this.height/20,4),this.tickLabelOffset=d.roundWithMin(this.height/60,3),this.tickFontSize=d.roundWithMin(this.height/20,10),this.minorTickLength=this.tickLength/2,this.backgroundCornerRad=d.roundWithMin(this.height/60,3),this.valueFontSize=d.roundWithMin(this.height/15,15),this.bandOffsetX=this.isShiny?d.roundWithMin(this.height/60,3):0,p["default"].prototype.renderGauge.call(this)},drawBackground:function(){this.backgroundWidth=d.roundWithMin(this.height/4,50);var e=this.calculateTickValues(this.ranges[0],this.ranges[this.ranges.length-1],this.MAX_TICKS_PER_RANGE);this.backgroundHeight=this.height-2*this.verticalPadding,this.bandHeight=this.backgroundHeight-(this.bandOffsetBottom+this.bandOffsetTop),this.bandWidth=this.isShiny?10:30;var n=e[e.length-1],t=this.predictTextWidth(this.formatValue(n),this.tickFontSize),i=this.bandOffsetX+this.bandWidth+this.tickOffset+this.tickLength+this.tickLabelOffset+t+this.tickLabelPaddingRight;this.backgroundWidth=Math.max(this.backgroundWidth,i),this.isShiny&&(this.elements.background=this.renderer.rect((this.width-this.backgroundWidth)/2,this.verticalPadding,this.backgroundWidth,this.backgroundHeight,this.backgroundCornerRad).attr({fill:"#edede7",stroke:"silver","stroke-width":1}).add()),this.tickStartX=(this.width-this.backgroundWidth)/2+(this.bandOffsetX+this.bandWidth)+this.tickOffset,this.tickEndX=this.tickStartX+this.tickLength,this.tickLabelStartX=this.tickEndX+this.tickLabelOffset},drawBand:function(){var e=void 0,n=void 0,t=void 0,i=(this.width-this.backgroundWidth)/2+this.bandOffsetX,r=this.height-this.verticalPadding-this.bandOffsetBottom;for(e=0;e<this.ranges.length-1;e++)n=this.translateValue(this.ranges[e]),t=this.translateValue(this.ranges[e+1]),this.elements["colorBand"+e]=this.renderer.rect(i,r-t,this.bandWidth,t-n,this.bandCornerRad).attr({fill:this.getColorByIndex(e)}).add()},drawMajorTick:function(e){var n=this.verticalPadding+this.backgroundHeight-(this.bandOffsetBottom+e);return this.renderer.path(["M",this.tickStartX,n,"L",this.tickEndX,n]).attr({stroke:this.tickColor,"stroke-width":this.tickWidth}).add()},drawMajorTickLabel:function(e,n){var t=this.verticalPadding+this.backgroundHeight-(this.bandOffsetBottom+e);return this.renderer.text(n,this.tickLabelStartX,t+this.tickFontSize/4).attr({align:"left"}).css({color:this.tickFontColor,fontSize:this.tickFontSize+"px",lineHeight:this.tickFontSize+"px"}).add()},drawMinorTick:function(e){var n=this.verticalPadding+this.backgroundHeight-(this.bandOffsetBottom+e);return this.renderer.path(["M",this.tickStartX,n,"L",this.tickStartX+this.minorTickLength,n]).attr({stroke:this.tickColor,"stroke-width":this.minorTickWidth}).add()},drawIndicator:function(e){var n=void 0,t=void 0,i=void 0,r=void 0,a=this.normalizedTranslateValue(e),o=this.verticalPadding+this.backgroundHeight-(this.bandOffsetBottom+a),s=this.isShiny?(this.width-this.backgroundWidth)/2:(this.width-this.backgroundWidth)/2-10,l=this.isShiny?s+this.backgroundWidth:s+this.bandWidth+20,h=this.foregroundColor,d=3,c=["M",s,o,"L",l,o];this.isShiny&&(n=["M",s,o-this.markerWindowHeight/2,"L",s-(this.markerSideWidth-this.markerSideCornerRad),o-this.markerWindowHeight/2,"C",s-(this.markerSideWidth-this.markerSideCornerRad),o-this.markerWindowHeight/2,s-this.markerSideWidth,o-this.markerWindowHeight/2,s-this.markerSideWidth,o-this.markerWindowHeight/2+this.markerSideCornerRad,"L",s-this.markerSideWidth,o+this.markerWindowHeight/2-this.markerSideCornerRad,"C",s-this.markerSideWidth,o+this.markerWindowHeight/2-this.markerSideCornerRad,s-this.markerSideWidth,o+this.markerWindowHeight/2,s-(this.markerSideWidth-this.markerSideCornerRad),o+this.markerWindowHeight/2,"L",s,o+this.markerWindowHeight/2,s,o-this.markerWindowHeight/2],t=["M",l,o-this.markerWindowHeight/2,"L",l+(this.markerSideWidth-this.markerSideCornerRad),o-this.markerWindowHeight/2,"C",l+(this.markerSideWidth-this.markerSideCornerRad),o-this.markerWindowHeight/2,l+this.markerSideWidth,o-this.markerWindowHeight/2,l+this.markerSideWidth,o-this.markerWindowHeight/2+this.markerSideCornerRad,"L",l+this.markerSideWidth,o+this.markerWindowHeight/2-this.markerSideCornerRad,"C",l+this.markerSideWidth,o+this.markerWindowHeight/2-this.markerSideCornerRad,l+this.markerSideWidth,o+this.markerWindowHeight/2,l+(this.markerSideWidth-this.markerSideCornerRad),o+this.markerWindowHeight/2,"L",l,o+this.markerWindowHeight/2,l,o-this.markerWindowHeight/2],i=["M",s,o-this.markerWindowHeight/2,"L",l,o-this.markerWindowHeight/2,l,o+this.markerWindowHeight/2,s,o+this.markerWindowHeight/2,s,o-this.markerWindowHeight/2],r=["M",s,o+1,"L",l,o+1],h="red",d=1),this.isShiny&&(this.elements.markerLHS&&this.elements.markerLHS.destroy(),this.elements.markerLHS=this.renderer.path(n).attr({fill:"#cccccc"}).add(),this.elements.markerRHS&&this.elements.markerRHS.destroy(),this.elements.markerRHS=this.renderer.path(t).attr({fill:"#cccccc"}).add(),this.elements.markerWindow&&this.elements.markerWindow.destroy(),this.elements.markerWindow=this.renderer.rect(s,o-this.markerWindowHeight/2,this.backgroundWidth,this.markerWindowHeight,0).attr({fill:"rgba(255, 255, 255, 0.3)"}).add(),this.elements.markerBorder&&this.elements.markerBorder.destroy(),this.elements.markerBorder=this.renderer.path(i).attr({stroke:"white","stroke-width":2}).add(),this.elements.markerUnderline&&this.elements.markerUnderline.destroy(),this.elements.markerUnderline=this.renderer.path(r).attr({stroke:"white","stroke-width":2}).add()),this.elements.markerLine&&this.elements.markerLine.destroy(),this.elements.markerLine=this.renderer.path(c).attr({stroke:h,"stroke-width":d}).add(),this.showValue&&this.drawValueDisplay(e)},drawValueDisplay:function(e){var n=this.formatValue(e),t=this.normalizedTranslateValue(e),i=this.verticalPadding+this.backgroundHeight-this.bandOffsetBottom-t;this.elements.valueDisplay?this.elements.valueDisplay.attr({text:n,y:i+this.valueFontSize/4}):this.elements.valueDisplay=this.renderer.text(n,(this.width-this.backgroundWidth)/2-this.valueOffset,i+this.valueFontSize/4).css({color:"black",fontSize:this.valueFontSize+"px",lineHeight:this.valueFontSize+"px",fontWeight:"bold"}).attr({align:"right"}).add()},normalizedTranslateValue:function(e){return e<this.ranges[0]?0:e>this.ranges[this.ranges.length-1]?this.translateValue(this.ranges[this.ranges.length-1]):this.translateValue(e)},translateValue:function(e){var n=this.ranges[this.ranges.length-1]-this.ranges[0],t=e-this.ranges[0];return Math.round(t/n*this.bandHeight)}}),n["default"]=a,e.exports=n["default"]}])},573:function(e,n){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=20)}({20:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.inherit=function(e,n){var t=function(){};t.prototype=n.prototype,e.prototype=new t,e.prototype.constructor=e}}})},574:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=21)}({0:function(e,n){e.exports=t("require/underscore")},1:function(e,n){e.exports=t("shim/jquery")},21:function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0}),n.getRotation=n.getYAxisProperties=n.getXAxisProperties=n.yAxisKeyIsTrumped=n.xAxisKeyIsTrumped=n.getLegendProperties=n.arraysAreEquivalent=n.stringToHexObject=n.stringToHexArray=n.capitalize=n.stringToArray=n.stringToFieldList=n.stringToObject=n.normalizeBoolean=n.filterPropsByRegex=n.escapeSVG=n.escapeHtml=n.unescapeChars=n.escapeSafeSplit=n.trimWhitespace=void 0;var r=t(1),a=i(r),o=t(0),s=i(o),l=t(3),h=n.trimWhitespace=function(e){return e.replace(/^\s*/,"").replace(/\s*$/,"")},d=function(e){return e.replace(/^(["'])(.*)\1$/,"$2")},c=n.escapeSafeSplit=function(e,n,t){t=t||"\\";var i=e.split(n),r=[i.shift()];return(0,s["default"])(i).each(function(e){var i=(0,s["default"])(r).last();(0,s["default"])(i).last()===t?r[r.length-1]+=n+e:r.push(e)}),r},p=n.unescapeChars=function(e,n){return(0,s["default"])(n).each(function(n){var t=new RegExp("\\\\\\"+n,"g");e=e.replace(t,n)}),e},u=(n.escapeHtml=function(e){return(""+e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")},n.escapeSVG=function(e){return(""+e).replace(/</g,"&lt;").replace(/>/g,"&gt;")},n.filterPropsByRegex=function(e,n){if(!(n instanceof RegExp))return e;var t=void 0,i={};for(t in e)e.hasOwnProperty(t)&&n.test(t)&&(i[t]=e[t]);return i}),f=n.normalizeBoolean=function(e,n){if((0,s["default"])(e).isUndefined())return!!n;switch("string"==typeof e&&(e=e.toLowerCase()),e){case!0:case 1:case"1":case"yes":case"on":case"true":return!0;case!1:case 0:case"0":case"no":case"off":case"false":return!1;default:return e}},m=n.stringToObject=function(e){if(!e)return!1;var n=void 0,t=void 0,i=void 0,r={};e=h(e);var a=e.length;if("{"!==e.charAt(0)||"}"!==e.charAt(a-1))return!1;if(/^{\s*}$/.test(e))return{};e=e.substr(1,a-2);var o=c(e,",");for(n=0;n<o.length;n++){if(t=c(o[n],":"),2!==t.length)return!1;i=h(t[0]),'"'===i[0]&&(i=i.substring(1)),'"'===(0,s["default"])(i).last()&&(i=i.substring(0,i.length-1)),i=p(i,["{","}","[","]","(",")",",",":",'"']),r[i]=d(h(t[1]))}return r},g=n.stringToFieldList=function(e){if("string"!=typeof e||!e)return[];for(var n=[],t=[],i=!1,r=a["default"].trim(e),o=0,s=r.length;o<s;o++)if("\\"!==r.charAt(o))if('"'!==r.charAt(o))" "!==r.charAt(o)&&","!==r.charAt(o)||i?t.push(r.charAt(o)):(t.length>0&&n.push(t.join("")),t=[]);else{if(i){i=!1,n.push(t.join("")),t=[];continue}i=!0}else{var l=o+1;if(s>l&&("\\"===r.charAt(l)||'"'===r.charAt(l))){t.push(r.charAt(l)),o++;continue}t.push(r.charAt(o))}return t.length>0&&n.push(t.join("")),n},x=n.stringToArray=function(e){if(!e)return!1;e=h(e);var n=e.length;return"["===e.charAt(0)&&"]"===e.charAt(n-1)&&(/^\[\s*]$/.test(e)?[]:(e=e.substr(1,n-2),g(e)))},b=(n.capitalize=function(e){return e.charAt(0).toUpperCase()+e.slice(1)},function(e){return s["default"].isNumber(e)?e:"#"===e.substring(0,1)?(0,l.hexFromColor)(e):parseInt(e,16)}),y=(n.stringToHexArray=function(e){var n=void 0,t=void 0,i=void 0;try{i=JSON.parse(e)}catch(r){i=x(e)}if(!i)return!1;for(n=0;n<i.length;n++){if(t=b(i[n]),isNaN(t))return!1;i[n]=t}return i},n.stringToHexObject=function(e){var n=void 0;try{n=JSON.parse(e)}catch(t){n=m(e)}if(!n)return!1;var i={};return(0,s["default"])(n).each(function(e,n){i[n]=b(e)||0}),i},n.arraysAreEquivalent=function(e,n){if(!(e instanceof Array&&n instanceof Array))return!1;if(e===n)return!0;if(e.length!==n.length)return!1;for(var t=0;t<e.length;t++)if(e[t]!==n[t])return!1;return!0},n.getLegendProperties=function(e){var n={},t=u(e,/legend[.]/);return(0,s["default"])(t).each(function(e,t){n[t.replace(/^legend[.]/,"")]=e}),n},n.xAxisKeyIsTrumped=function(e,n){return!!/primaryAxis/.test(e)&&(/primaryAxisTitle/.test(e)?n[e.replace(/primaryAxisTitle/,"axisTitleX")]:n[e.replace(/primaryAxis/,"axisX")])}),v=n.yAxisKeyIsTrumped=function(e,n){return!!/secondaryAxis/.test(e)&&(/secondaryAxisTitle/.test(e)?n[e.replace(/secondaryAxisTitle/,"axisTitleY")]:n[e.replace(/secondaryAxis/,"axisY")])};n.getXAxisProperties=function(e){var n=void 0,t=void 0,i={},r=u(e,/(axisX|primaryAxis|axisLabelsX|axisTitleX|gridLinesX)/);for(n in r)r.hasOwnProperty(n)&&(y(n,e)||(t=n.replace(/(axisX|primaryAxis)/,"axis"),t=t.replace(/axisLabelsX/,"axisLabels"),t=t.replace(/axisTitleX/,"axisTitle"),t=t.replace(/gridLinesX/,"gridLines"),i[t]=r[n]));return i},n.getYAxisProperties=function(e,n){var t=void 0,i=void 0,r={},a=void 0;if(n=(e&&f(e["layout.splitSeries"])?0:n)||0,0===n)a=u(e,/(axisY[^2]|secondaryAxis|axisLabelsY(?!2.*|\.majorLabelStyle\.rotation|\.majorLabelStyle\.overflowMode)|axisTitleY[^2]|gridLinesY[^2])/);else{
if(1!==n)throw new Error("Axis index must be 0 or 1");a=u(e,/(axisY2(?!\.enabled)|axisLabelsY2(?!\.majorLabelStyle\.rotation|\.majorLabelStyle\.overflowMode)|axisTitleY2|gridLinesY2)/),a["axisY2.scale"]&&"inherit"!==a["axisY2.scale"]||(a["axisY2.scale"]=e?e["axisY.scale"]||"linear":"linear"),(s["default"].isUndefined(a["gridLinesY2.showMajorLines"])||"boolean"!=typeof f(a["gridLinesY2.showMajorLines"]))&&(a["gridLinesY2.showMajorLines"]=0),a["axisLabelsY2.extendsAxisRange"]=!e||(e["axisLabelsY.extendsAxisRange"]||!0)}for(t in a)a.hasOwnProperty(t)&&(v(t,e)||(i=t.replace(/(axisY2|axisY|secondaryAxis)/,"axis"),i=i.replace(/axisLabelsY2|axisLabelsY/,"axisLabels"),i=i.replace(/axisTitleY2|axisTitleY/,"axisTitle"),i=i.replace(/gridLinesY2|gridLinesY/,"gridLines"),r[i]=a[t]));return r},n.getRotation=function(e){var n=[-90,-45,0,45,90],t=0,i=parseInt(e,10);return s["default"].indexOf(n,i)===-1?t:i}},3:function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0}),n.interpolateColors=n.getComputedOpacity=n.getLuminance=n.addAlphaToColor=n.hexFromColor=n.normalizeColor=n.stripOutAlpha=n.colorFromHex=void 0;var r=t(1),a=i(r),o=t(0),s=i(o),l=n.colorFromHex=function(e,n){if("number"!=typeof e&&(e=parseInt(e,16)),(0,s["default"])(e).isNaN()||e<0||e>16777215)return null;var t=(16711680&e)>>16,i=(65280&e)>>8,r=255&e;return void 0===n?"rgb("+t+","+i+","+r+")":"rgba("+t+","+i+","+r+","+n+")"},h=(n.stripOutAlpha=function(e){var n=e.split(","),t=n[0].charAt(3);return"a"===t?(n[0]=n[0].replace("rgba","rgb"),n[n.length-1]=")",n=n.join(),n=n.replace(",)",")")):e},function(e){var n=e.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/),t=(n[1]<<16|n[2]<<8|n[3]).toString(16);return"#"+Array(6-t.length).concat([t]).toString().replace(/,/g,0)}),d=n.normalizeColor=function(e){var n=null;if("string"==typeof e&&"#"===e.charAt(0))n=4===e.length?e+e.charAt(1)+e.charAt(2)+e.charAt(3):e;else try{n=h(e)}catch(t){}return n},c=n.hexFromColor=function(e){var n=d(e);return n?parseInt(n.replace("#","0x"),16):0};n.addAlphaToColor=function(e,n){var t="number"==typeof e?e:c(e);return l(t,n)},n.getLuminance=function(e){if("number"!=typeof e&&(e=parseInt(e,16)),isNaN(e)||e<0||e>16777215)return 0;var n=(16711680&e)>>16,t=(65280&e)>>8,i=255&e;return Math.round(.2126*n+.7152*t+.0722*i)},n.getComputedOpacity=function(e){var n=a["default"].trim(e.attr("fill")),t=function(e){var n=parseFloat(e);return n>=0&&n<=1?n:1};if(!/^rgba/.test(n))return t(e.attr("fill-opacity"));var i=n.match(/^rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)$/);return i&&i.length>4?t(i[4]):1},n.interpolateColors=function(e,n,t){var i=e>>16&255,r=e>>8&255,a=255&e,o=n>>16&255,s=n>>8&255,l=255&n,h=i+Math.round((o-i)*t),d=r+Math.round((s-r)*t),c=a+Math.round((l-a)*t);return h<<16|d<<8|c}}})},575:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=5)}({0:function(e,n){e.exports=t("require/underscore")},5:function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0}),n.roundToDecimal=n.valuesAreNumeric=n.isCommaSeparatedNumber=n.getDecimalPrecision=n.degreeToRadian=n.roundWithMinMax=n.roundWithMin=n.nearestPowerOfTen=n.absPowerTen=n.absLogBaseTen=n.logBaseTen=n.parseFloat=void 0;var r=t(0),a=i(r),o=/^( )*(0x|-0x)/,s=/(^[-+]?[0-9]*[.]?[0-9]*$)|(^[-+]?[0-9][.]?[0-9]*e[-+]?[0-9][0-9]*$)/i,l=/(^[-+]?([0]|([1-9][0-9]{0,2})|(([1-9][0-9]{0,2}[,])([0-9]{3}[,])*[0-9]{3}))(([.][0-9]+)?)$)/,h=function(e){return o.test(e)?parseInt(e,16):s.test(e)?parseFloat(e):NaN};n.parseFloat=h;var d=n.logBaseTen=function(e){var n=Math.log(e)/Math.LN10;return Math.round(1e4*n)/1e4},c=n.absLogBaseTen=function(e){if("number"!=typeof e&&(e=parseFloat(e)),(0,a["default"])(e).isNaN())return e;var n=e<0;n&&(e=-e),e<10&&(e+=(10-e)/10);var t=d(e);return n?-t:t},p=n.absPowerTen=function(e){if("number"!=typeof e&&(e=parseFloat(e)),(0,a["default"])(e).isNaN())return e;var n=e<0,t=void 0;return n&&(e=-e),t=Math.pow(10,e),t<10&&(t=10*(t-1)/9),t=n?-t:t,Math.round(1e3*t)/1e3},u=n.nearestPowerOfTen=function(e){if("number"!=typeof e)return NaN;var n=e<0;e=n?-e:e;var t=d(e),i=Math.pow(10,Math.floor(t));return n?-i:i},f=n.roundWithMin=function(e,n){return Math.max(Math.round(e),n)},m=n.roundWithMinMax=function(e,n,t){var i=Math.round(e);return i<n?n:i>t?t:i},g=n.degreeToRadian=function(e){return e*Math.PI/180},x=n.getDecimalPrecision=function(e,n){n=Math.min(n||1/0,20);for(var t=0;t<n&&e.toFixed(t)!==e.toString();)t+=1;return t},b=n.isCommaSeparatedNumber=function(e){return l.test(e)},y=n.valuesAreNumeric=function(e){var n=0,t=0;return(0,a["default"])(e).each(function(e){if((0,a["default"])(e).isArray()&&(e=e.length>0?e[0]:null),!(0,a["default"])(e).isNull()){t++;var i=!!h(e)||b(e);i&&n++}}),0!==t&&n>=t/2},v=n.roundToDecimal=function(e,n){return"undefined"==typeof n||0===+n?Math.round(e):(e=+e,n=+n,isNaN(e)||"number"!=typeof n||n%1!==0?NaN:(e=e.toString().split("e"),e=Math.round(+(e[0]+"e"+(e[1]?+e[1]-n:-n))),e=e.toString().split("e"),+(e[0]+"e"+(e[1]?+e[1]+n:n))))};n["default"]={parseFloat:h,logBaseTen:d,absLogBaseTen:c,absPowerTen:p,nearestPowerOfTen:u,roundWithMin:f,roundWithMinMax:m,degreeToRadian:g,getDecimalPrecision:x,valuesAreNumeric:y,roundToDecimal:v}}})},576:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=3)}([function(e,n){e.exports=t("require/underscore")},function(e,n){e.exports=t("shim/jquery")},,function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0}),n.interpolateColors=n.getComputedOpacity=n.getLuminance=n.addAlphaToColor=n.hexFromColor=n.normalizeColor=n.stripOutAlpha=n.colorFromHex=void 0;var r=t(1),a=i(r),o=t(0),s=i(o),l=n.colorFromHex=function(e,n){if("number"!=typeof e&&(e=parseInt(e,16)),(0,s["default"])(e).isNaN()||e<0||e>16777215)return null;var t=(16711680&e)>>16,i=(65280&e)>>8,r=255&e;return void 0===n?"rgb("+t+","+i+","+r+")":"rgba("+t+","+i+","+r+","+n+")"},h=(n.stripOutAlpha=function(e){var n=e.split(","),t=n[0].charAt(3);return"a"===t?(n[0]=n[0].replace("rgba","rgb"),n[n.length-1]=")",n=n.join(),n=n.replace(",)",")")):e},function(e){var n=e.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/),t=(n[1]<<16|n[2]<<8|n[3]).toString(16);return"#"+Array(6-t.length).concat([t]).toString().replace(/,/g,0)}),d=n.normalizeColor=function(e){var n=null;if("string"==typeof e&&"#"===e.charAt(0))n=4===e.length?e+e.charAt(1)+e.charAt(2)+e.charAt(3):e;else try{n=h(e)}catch(t){}return n},c=n.hexFromColor=function(e){var n=d(e);return n?parseInt(n.replace("#","0x"),16):0};n.addAlphaToColor=function(e,n){var t="number"==typeof e?e:c(e);return l(t,n)},n.getLuminance=function(e){if("number"!=typeof e&&(e=parseInt(e,16)),isNaN(e)||e<0||e>16777215)return 0;var n=(16711680&e)>>16,t=(65280&e)>>8,i=255&e;return Math.round(.2126*n+.7152*t+.0722*i)},n.getComputedOpacity=function(e){var n=a["default"].trim(e.attr("fill")),t=function(e){var n=parseFloat(e);return n>=0&&n<=1?n:1};if(!/^rgba/.test(n))return t(e.attr("fill-opacity"));var i=n.match(/^rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)$/);return i&&i.length>4?t(i[4]):1},n.interpolateColors=function(e,n,t){var i=e>>16&255,r=e>>8&255,a=255&e,o=n>>16&255,s=n>>8&255,l=255&n,h=i+Math.round((o-i)*t),d=r+Math.round((s-r)*t),c=a+Math.round((l-a)*t);return h<<16|d<<8|c}}])},577:function(e,n){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=0)}([function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0});var r=t(1),a=i(r),o=function(){return new Function("\n        return (function() {\n            var module = {\n                exports: true\n            };\n            "+a["default"]+";\n            return module.exports;\n        })();\n    ")()},s=o();s.noConflict=function(){return o()},n["default"]=s,e.exports=n["default"]},function(e,n){e.exports="/**\n * @license Highcharts JS v5.0.12 (2017-05-24)\n *\n * (c) 2009-2016 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n'use strict';\n(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = root.document ?\n            factory(root) :\n            factory;\n    } else {\n        root.Highcharts = factory(root);\n    }\n}(typeof window !== 'undefined' ? window : this, function(win) {\n    var Highcharts = (function() {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        /* global window */\n        var win = window,\n            doc = win.document;\n\n        var SVG_NS = 'http://www.w3.org/2000/svg',\n            userAgent = (win.navigator && win.navigator.userAgent) || '',\n            svg = doc && doc.createElementNS && !!doc.createElementNS(SVG_NS, 'svg').createSVGRect,\n            isMS = /(edge|msie|trident)/i.test(userAgent) && !window.opera,\n            vml = !svg,\n            isFirefox = /Firefox/.test(userAgent),\n            hasBidiBug = isFirefox && parseInt(userAgent.split('Firefox/')[1], 10) < 4; // issue #38\n\n        var Highcharts = win.Highcharts ? win.Highcharts.error(16, true) : {\n            product: 'Highcharts',\n            version: '5.0.12',\n            deg2rad: Math.PI * 2 / 360,\n            doc: doc,\n            hasBidiBug: hasBidiBug,\n            hasTouch: doc && doc.documentElement.ontouchstart !== undefined,\n            isMS: isMS,\n            isWebKit: /AppleWebKit/.test(userAgent),\n            isFirefox: isFirefox,\n            isTouchDevice: /(Mobile|Android|Windows Phone)/.test(userAgent),\n            SVG_NS: SVG_NS,\n            chartCount: 0,\n            seriesTypes: {},\n            symbolSizes: {},\n            svg: svg,\n            vml: vml,\n            win: win,\n            marginNames: ['plotTop', 'marginRight', 'marginBottom', 'plotLeft'],\n            noop: function() {\n                return undefined;\n            },\n            /**\n             * An array containing the current chart objects in the page. A chart's\n             * position in the array is preserved throughout the page's lifetime. When\n             * a chart is destroyed, the array item becomes `undefined`.\n             * @type {Array.<Highcharts.Chart>}\n             * @memberOf Highcharts\n             */\n            charts: []\n        };\n        return Highcharts;\n    }());\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        /* eslint max-len: [\"warn\", 80, 4] */\n\n        /**\n         * The Highcharts object is the placeholder for all other members, and various\n         * utility functions. The most important member of the namespace would be the\n         * chart constructor.\n         *\n         * @example\n         * var chart = Highcharts.chart('container', { ... });\n         * \n         * @namespace Highcharts\n         */\n\n        var timers = [];\n\n        var charts = H.charts,\n            doc = H.doc,\n            win = H.win;\n\n        /**\n         * Provide error messages for debugging, with links to online explanation. This\n         * function can be overridden to provide custom error handling.\n         *\n         * @function #error\n         * @memberOf Highcharts\n         * @param {Number|String} code - The error code. See [errors.xml]{@link \n         *     https://github.com/highcharts/highcharts/blob/master/errors/errors.xml}\n         *     for available codes. If it is a string, the error message is printed\n         *     directly in the console.\n         * @param {Boolean} [stop=false] - Whether to throw an error or just log a \n         *     warning in the console.\n         *\n         * @sample highcharts/chart/highcharts-error/ Custom error handler\n         */\n        H.error = function(code, stop) {\n            var msg = H.isNumber(code) ?\n                'Highcharts error #' + code + ': www.highcharts.com/errors/' + code :\n                code;\n            if (stop) {\n                throw new Error(msg);\n            }\n            // else ...\n            if (win.console) {\n                console.log(msg); // eslint-disable-line no-console\n            }\n        };\n\n        /**\n         * An animator object used internally. One instance applies to one property\n         * (attribute or style prop) on one element. Animation is always initiated\n         * through {@link SVGElement#animate}.\n         *\n         * @constructor Fx\n         * @memberOf Highcharts\n         * @param {HTMLDOMElement|SVGElement} elem - The element to animate.\n         * @param {AnimationOptions} options - Animation options.\n         * @param {string} prop - The single attribute or CSS property to animate.\n         * @private\n         *\n         * @example\n         * var rect = renderer.rect(0, 0, 10, 10).add();\n         * rect.animate({ width: 100 });\n         */\n        H.Fx = function(elem, options, prop) {\n            this.options = options;\n            this.elem = elem;\n            this.prop = prop;\n        };\n        H.Fx.prototype = {\n\n            /**\n             * Set the current step of a path definition on SVGElement.\n             *\n             * @function #dSetter\n             * @memberOf Highcharts.Fx\n             */\n            dSetter: function() {\n                var start = this.paths[0],\n                    end = this.paths[1],\n                    ret = [],\n                    now = this.now,\n                    i = start.length,\n                    startVal;\n\n                // Land on the final path without adjustment points appended in the ends\n                if (now === 1) {\n                    ret = this.toD;\n\n                } else if (i === end.length && now < 1) {\n                    while (i--) {\n                        startVal = parseFloat(start[i]);\n                        ret[i] =\n                            isNaN(startVal) ? // a letter instruction like M or L\n                            start[i] :\n                            now * (parseFloat(end[i] - startVal)) + startVal;\n\n                    }\n                    // If animation is finished or length not matching, land on right value\n                } else {\n                    ret = end;\n                }\n                this.elem.attr('d', ret, null, true);\n            },\n\n            /**\n             * Update the element with the current animation step.\n             *\n             * @function #update\n             * @memberOf Highcharts.Fx\n             */\n            update: function() {\n                var elem = this.elem,\n                    prop = this.prop, // if destroyed, it is null\n                    now = this.now,\n                    step = this.options.step;\n\n                // Animation setter defined from outside\n                if (this[prop + 'Setter']) {\n                    this[prop + 'Setter']();\n\n                    // Other animations on SVGElement\n                } else if (elem.attr) {\n                    if (elem.element) {\n                        elem.attr(prop, now, null, true);\n                    }\n\n                    // HTML styles, raw HTML content like container size\n                } else {\n                    elem.style[prop] = now + this.unit;\n                }\n\n                if (step) {\n                    step.call(elem, now, this);\n                }\n\n            },\n\n            /**\n             * Run an animation.\n             *\n             * @function #run\n             * @memberOf Highcharts.Fx\n             * @param {Number} from - The current value, value to start from.\n             * @param {Number} to - The end value, value to land on.\n             * @param {String} [unit] - The property unit, for example `px`.\n             * @returns {void}\n             */\n            run: function(from, to, unit) {\n                var self = this,\n                    timer = function(gotoEnd) {\n                        return timer.stopped ? false : self.step(gotoEnd);\n                    },\n                    i;\n\n                this.startTime = +new Date();\n                this.start = from;\n                this.end = to;\n                this.unit = unit;\n                this.now = this.start;\n                this.pos = 0;\n\n                timer.elem = this.elem;\n                timer.prop = this.prop;\n\n                if (timer() && timers.push(timer) === 1) {\n                    timer.timerId = setInterval(function() {\n\n                        for (i = 0; i < timers.length; i++) {\n                            if (!timers[i]()) {\n                                timers.splice(i--, 1);\n                            }\n                        }\n\n                        if (!timers.length) {\n                            clearInterval(timer.timerId);\n                        }\n                    }, 13);\n                }\n            },\n\n            /**\n             * Run a single step in the animation.\n             *\n             * @function #step\n             * @memberOf Highcharts.Fx\n             * @param   {Boolean} [gotoEnd] - Whether to go to the endpoint of the\n             *     animation after abort.\n             * @returns {Boolean} Returns `true` if animation continues.\n             */\n            step: function(gotoEnd) {\n                var t = +new Date(),\n                    ret,\n                    done,\n                    options = this.options,\n                    elem = this.elem,\n                    complete = options.complete,\n                    duration = options.duration,\n                    curAnim = options.curAnim;\n\n                if (elem.attr && !elem.element) { // #2616, element is destroyed\n                    ret = false;\n\n                } else if (gotoEnd || t >= duration + this.startTime) {\n                    this.now = this.end;\n                    this.pos = 1;\n                    this.update();\n\n                    curAnim[this.prop] = true;\n\n                    done = true;\n\n                    H.objectEach(curAnim, function(val) {\n                        if (val !== true) {\n                            done = false;\n                        }\n                    });\n\n                    if (done && complete) {\n                        complete.call(elem);\n                    }\n                    ret = false;\n\n                } else {\n                    this.pos = options.easing((t - this.startTime) / duration);\n                    this.now = this.start + ((this.end - this.start) * this.pos);\n                    this.update();\n                    ret = true;\n                }\n                return ret;\n            },\n\n            /**\n             * Prepare start and end values so that the path can be animated one to one.\n             *\n             * @function #initPath\n             * @memberOf Highcharts.Fx\n             * @param {SVGElement} elem - The SVGElement item.\n             * @param {String} fromD - Starting path definition.\n             * @param {Array} toD - Ending path definition.\n             * @returns {Array} An array containing start and end paths in array form\n             * so that they can be animated in parallel.\n             */\n            initPath: function(elem, fromD, toD) {\n                fromD = fromD || '';\n                var shift,\n                    startX = elem.startX,\n                    endX = elem.endX,\n                    bezier = fromD.indexOf('C') > -1,\n                    numParams = bezier ? 7 : 3,\n                    fullLength,\n                    slice,\n                    i,\n                    start = fromD.split(' '),\n                    end = toD.slice(), // copy\n                    isArea = elem.isArea,\n                    positionFactor = isArea ? 2 : 1,\n                    reverse;\n\n                /**\n                 * In splines make moveTo and lineTo points have six parameters like\n                 * bezier curves, to allow animation one-to-one.\n                 */\n                function sixify(arr) {\n                    var isOperator,\n                        nextIsOperator;\n                    i = arr.length;\n                    while (i--) {\n\n                        // Fill in dummy coordinates only if the next operator comes\n                        // three places behind (#5788)\n                        isOperator = arr[i] === 'M' || arr[i] === 'L';\n                        nextIsOperator = /[a-zA-Z]/.test(arr[i + 3]);\n                        if (isOperator && nextIsOperator) {\n                            arr.splice(\n                                i + 1, 0,\n                                arr[i + 1], arr[i + 2],\n                                arr[i + 1], arr[i + 2]\n                            );\n                        }\n                    }\n                }\n\n                /**\n                 * Insert an array at the given position of another array\n                 */\n                function insertSlice(arr, subArr, index) {\n                    [].splice.apply(\n                        arr, [index, 0].concat(subArr)\n                    );\n                }\n\n                /**\n                 * If shifting points, prepend a dummy point to the end path. \n                 */\n                function prepend(arr, other) {\n                    while (arr.length < fullLength) {\n\n                        // Move to, line to or curve to?\n                        arr[0] = other[fullLength - arr.length];\n\n                        // Prepend a copy of the first point\n                        insertSlice(arr, arr.slice(0, numParams), 0);\n\n                        // For areas, the bottom path goes back again to the left, so we\n                        // need to append a copy of the last point.\n                        if (isArea) {\n                            insertSlice(\n                                arr,\n                                arr.slice(arr.length - numParams), arr.length\n                            );\n                            i--;\n                        }\n                    }\n                    arr[0] = 'M';\n                }\n\n                /**\n                 * Copy and append last point until the length matches the end length\n                 */\n                function append(arr, other) {\n                    var i = (fullLength - arr.length) / numParams;\n                    while (i > 0 && i--) {\n\n                        // Pull out the slice that is going to be appended or inserted.\n                        // In a line graph, the positionFactor is 1, and the last point\n                        // is sliced out. In an area graph, the positionFactor is 2,\n                        // causing the middle two points to be sliced out, since an area\n                        // path starts at left, follows the upper path then turns and\n                        // follows the bottom back. \n                        slice = arr.slice().splice(\n                            (arr.length / positionFactor) - numParams,\n                            numParams * positionFactor\n                        );\n\n                        // Move to, line to or curve to?\n                        slice[0] = other[fullLength - numParams - (i * numParams)];\n\n                        // Disable first control point\n                        if (bezier) {\n                            slice[numParams - 6] = slice[numParams - 2];\n                            slice[numParams - 5] = slice[numParams - 1];\n                        }\n\n                        // Now insert the slice, either in the middle (for areas) or at\n                        // the end (for lines)\n                        insertSlice(arr, slice, arr.length / positionFactor);\n\n                        if (isArea) {\n                            i--;\n                        }\n                    }\n                }\n\n                if (bezier) {\n                    sixify(start);\n                    sixify(end);\n                }\n\n                // For sideways animation, find out how much we need to shift to get the\n                // start path Xs to match the end path Xs.\n                if (startX && endX) {\n                    for (i = 0; i < startX.length; i++) {\n                        // Moving left, new points coming in on right\n                        if (startX[i] === endX[0]) {\n                            shift = i;\n                            break;\n                            // Moving right\n                        } else if (startX[0] ===\n                            endX[endX.length - startX.length + i]) {\n                            shift = i;\n                            reverse = true;\n                            break;\n                        }\n                    }\n                    if (shift === undefined) {\n                        start = [];\n                    }\n                }\n\n                if (start.length && H.isNumber(shift)) {\n\n                    // The common target length for the start and end array, where both \n                    // arrays are padded in opposite ends\n                    fullLength = end.length + shift * positionFactor * numParams;\n\n                    if (!reverse) {\n                        prepend(end, start);\n                        append(start, end);\n                    } else {\n                        prepend(start, end);\n                        append(end, start);\n                    }\n                }\n\n                return [start, end];\n            }\n        }; // End of Fx prototype\n\n        /**\n         * Handle animation of the color attributes directly.\n         */\n        H.Fx.prototype.fillSetter =\n            H.Fx.prototype.strokeSetter = function() {\n                this.elem.attr(\n                    this.prop,\n                    H.color(this.start).tweenTo(H.color(this.end), this.pos),\n                    null,\n                    true\n                );\n            };\n\n\n        /**\n         * Utility function to extend an object with the members of another.\n         *\n         * @function #extend\n         * @memberOf Highcharts\n         * @param {Object} a - The object to be extended.\n         * @param {Object} b - The object to add to the first one.\n         * @returns {Object} Object a, the original object.\n         */\n        H.extend = function(a, b) {\n            var n;\n            if (!a) {\n                a = {};\n            }\n            for (n in b) {\n                a[n] = b[n];\n            }\n            return a;\n        };\n\n        /**\n         * Utility function to deep merge two or more objects and return a third object.\n         * If the first argument is true, the contents of the second object is copied\n         * into the first object. The merge function can also be used with a single \n         * object argument to create a deep copy of an object.\n         *\n         * @function #merge\n         * @memberOf Highcharts\n         * @param {Boolean} [extend] - Whether to extend the left-side object (a) or\n                  return a whole new object.\n         * @param {Object} a - The first object to extend. When only this is given, the\n                  function returns a deep copy.\n         * @param {...Object} [n] - An object to merge into the previous one.\n         * @returns {Object} - The merged object. If the first argument is true, the \n         * return is the same as the second argument.\n         */\n        H.merge = function() {\n            var i,\n                args = arguments,\n                len,\n                ret = {},\n                doCopy = function(copy, original) {\n                    // An object is replacing a primitive\n                    if (typeof copy !== 'object') {\n                        copy = {};\n                    }\n\n                    H.objectEach(original, function(value, key) {\n\n                        // Copy the contents of objects, but not arrays or DOM nodes\n                        if (\n                            H.isObject(value, true) &&\n                            !H.isClass(value) &&\n                            !H.isDOMElement(value)\n                        ) {\n                            copy[key] = doCopy(copy[key] || {}, value);\n\n                            // Primitives and arrays are copied over directly\n                        } else {\n                            copy[key] = original[key];\n                        }\n                    });\n                    return copy;\n                };\n\n            // If first argument is true, copy into the existing object. Used in\n            // setOptions.\n            if (args[0] === true) {\n                ret = args[1];\n                args = Array.prototype.slice.call(args, 2);\n            }\n\n            // For each argument, extend the return\n            len = args.length;\n            for (i = 0; i < len; i++) {\n                ret = doCopy(ret, args[i]);\n            }\n\n            return ret;\n        };\n\n        /**\n         * Shortcut for parseInt\n         * @ignore\n         * @param {Object} s\n         * @param {Number} mag Magnitude\n         */\n        H.pInt = function(s, mag) {\n            return parseInt(s, mag || 10);\n        };\n\n        /**\n         * Utility function to check for string type.\n         *\n         * @function #isString\n         * @memberOf Highcharts\n         * @param {Object} s - The item to check.\n         * @returns {Boolean} - True if the argument is a string.\n         */\n        H.isString = function(s) {\n            return typeof s === 'string';\n        };\n\n        /**\n         * Utility function to check if an item is an array.\n         *\n         * @function #isArray\n         * @memberOf Highcharts\n         * @param {Object} obj - The item to check.\n         * @returns {Boolean} - True if the argument is an array.\n         */\n        H.isArray = function(obj) {\n            var str = Object.prototype.toString.call(obj);\n            return str === '[object Array]' || str === '[object Array Iterator]';\n        };\n\n        /**\n         * Utility function to check if an item is of type object.\n         *\n         * @function #isObject\n         * @memberOf Highcharts\n         * @param {Object} obj - The item to check.\n         * @param {Boolean} [strict=false] - Also checks that the object is not an\n         *    array.\n         * @returns {Boolean} - True if the argument is an object.\n         */\n        H.isObject = function(obj, strict) {\n            return !!obj && typeof obj === 'object' && (!strict || !H.isArray(obj));\n        };\n\n        /**\n         * Utility function to check if an Object is a HTML Element.\n         *\n         * @function #isDOMElement\n         * @memberOf Highcharts\n         * @param {Object} obj - The item to check.\n         * @returns {Boolean} - True if the argument is a HTML Element.\n         */\n        H.isDOMElement = function(obj) {\n            return H.isObject(obj) && typeof obj.nodeType === 'number';\n        };\n\n        /**\n         * Utility function to check if an Object is an class.\n         *\n         * @function #isClass\n         * @memberOf Highcharts\n         * @param {Object} obj - The item to check.\n         * @returns {Boolean} - True if the argument is an class.\n         */\n        H.isClass = function(obj) {\n            var c = obj && obj.constructor;\n            return !!(\n                H.isObject(obj, true) &&\n                !H.isDOMElement(obj) &&\n                (c && c.name && c.name !== 'Object')\n            );\n        };\n\n        /**\n         * Utility function to check if an item is of type number.\n         *\n         * @function #isNumber\n         * @memberOf Highcharts\n         * @param {Object} n - The item to check.\n         * @returns {Boolean} - True if the item is a number and is not NaN.\n         */\n        H.isNumber = function(n) {\n            return typeof n === 'number' && !isNaN(n);\n        };\n\n        /**\n         * Remove the last occurence of an item from an array.\n         *\n         * @function #erase\n         * @memberOf Highcharts\n         * @param {Array} arr - The array.\n         * @param {*} item - The item to remove.\n         */\n        H.erase = function(arr, item) {\n            var i = arr.length;\n            while (i--) {\n                if (arr[i] === item) {\n                    arr.splice(i, 1);\n                    break;\n                }\n            }\n        };\n\n        /**\n         * Check if an object is null or undefined.\n         *\n         * @function #defined\n         * @memberOf Highcharts\n         * @param {Object} obj - The object to check.\n         * @returns {Boolean} - False if the object is null or undefined, otherwise\n         *        true.\n         */\n        H.defined = function(obj) {\n            return obj !== undefined && obj !== null;\n        };\n\n        /**\n         * Set or get an attribute or an object of attributes. To use as a setter, pass\n         * a key and a value, or let the second argument be a collection of keys and\n         * values. To use as a getter, pass only a string as the second argument.\n         *\n         * @function #attr\n         * @memberOf Highcharts\n         * @param {Object} elem - The DOM element to receive the attribute(s).\n         * @param {String|Object} [prop] - The property or an object of key-value pairs.\n         * @param {String} [value] - The value if a single property is set.\n         * @returns {*} When used as a getter, return the value.\n         */\n        H.attr = function(elem, prop, value) {\n            var ret;\n\n            // if the prop is a string\n            if (H.isString(prop)) {\n                // set the value\n                if (H.defined(value)) {\n                    elem.setAttribute(prop, value);\n\n                    // get the value\n                } else if (elem && elem.getAttribute) {\n                    ret = elem.getAttribute(prop);\n                }\n\n                // else if prop is defined, it is a hash of key/value pairs\n            } else if (H.defined(prop) && H.isObject(prop)) {\n                H.objectEach(prop, function(val, key) {\n                    elem.setAttribute(key, val);\n                });\n            }\n            return ret;\n        };\n\n        /**\n         * Check if an element is an array, and if not, make it into an array.\n         *\n         * @function #splat\n         * @memberOf Highcharts\n         * @param obj {*} - The object to splat.\n         * @returns {Array} The produced or original array.\n         */\n        H.splat = function(obj) {\n            return H.isArray(obj) ? obj : [obj];\n        };\n\n        /**\n         * Set a timeout if the delay is given, otherwise perform the function\n         * synchronously.\n         *\n         * @function #syncTimeout\n         * @memberOf Highcharts\n         * @param   {Function} fn - The function callback.\n         * @param   {Number}   delay - Delay in milliseconds.\n         * @param   {Object}   [context] - The context.\n         * @returns {Number} An identifier for the timeout that can later be cleared\n         * with clearTimeout.\n         */\n        H.syncTimeout = function(fn, delay, context) {\n            if (delay) {\n                return setTimeout(fn, delay, context);\n            }\n            fn.call(0, context);\n        };\n\n\n        /**\n         * Return the first value that is not null or undefined.\n         *\n         * @function #pick\n         * @memberOf Highcharts\n         * @param {...*} items - Variable number of arguments to inspect.\n         * @returns {*} The value of the first argument that is not null or undefined.\n         */\n        H.pick = function() {\n            var args = arguments,\n                i,\n                arg,\n                length = args.length;\n            for (i = 0; i < length; i++) {\n                arg = args[i];\n                if (arg !== undefined && arg !== null) {\n                    return arg;\n                }\n            }\n        };\n\n        /**\n         * @typedef {Object} CSSObject - A style object with camel case property names.\n         * The properties can be whatever styles are supported on the given SVG or HTML\n         * element.\n         * @example\n         * {\n         *    fontFamily: 'monospace',\n         *    fontSize: '1.2em'\n         * }\n         */\n        /**\n         * Set CSS on a given element.\n         *\n         * @function #css\n         * @memberOf Highcharts\n         * @param {HTMLDOMElement} el - A HTML DOM element.\n         * @param {CSSObject} styles - Style object with camel case property names.\n         * @returns {void}\n         */\n        H.css = function(el, styles) {\n            if (H.isMS && !H.svg) { // #2686\n                if (styles && styles.opacity !== undefined) {\n                    styles.filter = 'alpha(opacity=' + (styles.opacity * 100) + ')';\n                }\n            }\n            H.extend(el.style, styles);\n        };\n\n        /**\n         * A HTML DOM element.\n         * @typedef {Object} HTMLDOMElement\n         */\n\n        /**\n         * Utility function to create an HTML element with attributes and styles.\n         *\n         * @function #createElement\n         * @memberOf Highcharts\n         * @param {String} tag - The HTML tag.\n         * @param {Object} [attribs] - Attributes as an object of key-value pairs.\n         * @param {CSSObject} [styles] - Styles as an object of key-value pairs.\n         * @param {Object} [parent] - The parent HTML object.\n         * @param {Boolean} [nopad=false] - If true, remove all padding, border and\n         *    margin.\n         * @returns {HTMLDOMElement} The created DOM element.\n         */\n        H.createElement = function(tag, attribs, styles, parent, nopad) {\n            var el = doc.createElement(tag),\n                css = H.css;\n            if (attribs) {\n                H.extend(el, attribs);\n            }\n            if (nopad) {\n                css(el, {\n                    padding: 0,\n                    border: 'none',\n                    margin: 0\n                });\n            }\n            if (styles) {\n                css(el, styles);\n            }\n            if (parent) {\n                parent.appendChild(el);\n            }\n            return el;\n        };\n\n        /**\n         * Extend a prototyped class by new members.\n         *\n         * @function #extendClass\n         * @memberOf Highcharts\n         * @param {Object} parent - The parent prototype to inherit.\n         * @param {Object} members - A collection of prototype members to add or\n         *        override compared to the parent prototype.\n         * @returns {Object} A new prototype.\n         */\n        H.extendClass = function(parent, members) {\n            var object = function() {};\n            object.prototype = new parent(); // eslint-disable-line new-cap\n            H.extend(object.prototype, members);\n            return object;\n        };\n\n        /**\n         * Left-pad a string to a given length by adding a character repetetively.\n         *\n         * @function #pad\n         * @memberOf Highcharts\n         * @param {Number} number - The input string or number.\n         * @param {Number} length - The desired string length.\n         * @param {String} [padder=0] - The character to pad with.\n         * @returns {String} The padded string.\n         */\n        H.pad = function(number, length, padder) {\n            return new Array((length || 2) + 1 -\n                String(number).length).join(padder || 0) + number;\n        };\n\n        /**\n         * @typedef {Number|String} RelativeSize - If a number is given, it defines the\n         *    pixel length. If a percentage string is given, like for example `'50%'`,\n         *    the setting defines a length relative to a base size, for example the size\n         *    of a container.\n         */\n        /**\n         * Return a length based on either the integer value, or a percentage of a base.\n         *\n         * @function #relativeLength\n         * @memberOf Highcharts\n         * @param {RelativeSize} value - A percentage string or a number.\n         * @param {Number} base - The full length that represents 100%.\n         * @returns {Number} The computed length.\n         */\n        H.relativeLength = function(value, base) {\n            return (/%$/).test(value) ?\n                base * parseFloat(value) / 100 :\n                parseFloat(value);\n        };\n\n        /**\n         * Wrap a method with extended functionality, preserving the original function.\n         *\n         * @function #wrap\n         * @memberOf Highcharts\n         * @param {Object} obj - The context object that the method belongs to. In real\n         *        cases, this is often a prototype.\n         * @param {String} method - The name of the method to extend.\n         * @param {Function} func - A wrapper function callback. This function is called\n         *        with the same arguments as the original function, except that the\n         *        original function is unshifted and passed as the first argument.\n         * @returns {void}\n         */\n        H.wrap = function(obj, method, func) {\n            var proceed = obj[method];\n            obj[method] = function() {\n                var args = Array.prototype.slice.call(arguments),\n                    outerArgs = arguments,\n                    ctx = this,\n                    ret;\n                ctx.proceed = function() {\n                    proceed.apply(ctx, arguments.length ? arguments : outerArgs);\n                };\n                args.unshift(proceed);\n                ret = func.apply(this, args);\n                ctx.proceed = null;\n                return ret;\n            };\n        };\n\n        /**\n         * Get the time zone offset based on the current timezone information as set in\n         * the global options.\n         *\n         * @function #getTZOffset\n         * @memberOf Highcharts\n         * @param  {Number} timestamp - The JavaScript timestamp to inspect.\n         * @return {Number} - The timezone offset in minutes compared to UTC.\n         */\n        H.getTZOffset = function(timestamp) {\n            var d = H.Date;\n            return ((d.hcGetTimezoneOffset && d.hcGetTimezoneOffset(timestamp)) ||\n                d.hcTimezoneOffset || 0) * 60000;\n        };\n\n        /**\n         * Formats a JavaScript date timestamp (milliseconds since Jan 1st 1970) into a\n         * human readable date string. The format is a subset of the formats for PHP's\n         * [strftime]{@link\n         * http://www.php.net/manual/en/function.strftime.php} function. Additional\n         * formats can be given in the {@link Highcharts.dateFormats} hook.\n         *\n         * @function #dateFormat\n         * @memberOf Highcharts\n         * @param {String} format - The desired format where various time\n         *        representations are prefixed with %.\n         * @param {Number} timestamp - The JavaScript timestamp.\n         * @param {Boolean} [capitalize=false] - Upper case first letter in the return.\n         * @returns {String} The formatted date.\n         */\n        H.dateFormat = function(format, timestamp, capitalize) {\n            if (!H.defined(timestamp) || isNaN(timestamp)) {\n                return H.defaultOptions.lang.invalidDate || '';\n            }\n            format = H.pick(format, '%Y-%m-%d %H:%M:%S');\n\n            var D = H.Date,\n                date = new D(timestamp - H.getTZOffset(timestamp)),\n                // get the basic time values\n                hours = date[D.hcGetHours](),\n                day = date[D.hcGetDay](),\n                dayOfMonth = date[D.hcGetDate](),\n                month = date[D.hcGetMonth](),\n                fullYear = date[D.hcGetFullYear](),\n                lang = H.defaultOptions.lang,\n                langWeekdays = lang.weekdays,\n                shortWeekdays = lang.shortWeekdays,\n                pad = H.pad,\n\n                // List all format keys. Custom formats can be added from the outside. \n                replacements = H.extend({\n\n                        //-- Day\n                        // Short weekday, like 'Mon'\n                        'a': shortWeekdays ?\n                            shortWeekdays[day] : langWeekdays[day].substr(0, 3),\n                        // Long weekday, like 'Monday'\n                        'A': langWeekdays[day],\n                        // Two digit day of the month, 01 to 31\n                        'd': pad(dayOfMonth),\n                        // Day of the month, 1 through 31\n                        'e': pad(dayOfMonth, 2, ' '),\n                        'w': day,\n\n                        // Week (none implemented)\n                        //'W': weekNumber(),\n\n                        //-- Month\n                        // Short month, like 'Jan'\n                        'b': lang.shortMonths[month],\n                        // Long month, like 'January'\n                        'B': lang.months[month],\n                        // Two digit month number, 01 through 12\n                        'm': pad(month + 1),\n\n                        //-- Year\n                        // Two digits year, like 09 for 2009\n                        'y': fullYear.toString().substr(2, 2),\n                        // Four digits year, like 2009\n                        'Y': fullYear,\n\n                        //-- Time\n                        // Two digits hours in 24h format, 00 through 23\n                        'H': pad(hours),\n                        // Hours in 24h format, 0 through 23\n                        'k': hours,\n                        // Two digits hours in 12h format, 00 through 11\n                        'I': pad((hours % 12) || 12),\n                        // Hours in 12h format, 1 through 12\n                        'l': (hours % 12) || 12,\n                        // Two digits minutes, 00 through 59\n                        'M': pad(date[D.hcGetMinutes]()),\n                        // Upper case AM or PM\n                        'p': hours < 12 ? 'AM' : 'PM',\n                        // Lower case AM or PM\n                        'P': hours < 12 ? 'am' : 'pm',\n                        // Two digits seconds, 00 through  59\n                        'S': pad(date.getSeconds()),\n                        // Milliseconds (naming from Ruby)\n                        'L': pad(Math.round(timestamp % 1000), 3)\n                    },\n\n                    /**\n                     * A hook for defining additional date format specifiers. New\n                     * specifiers are defined as key-value pairs by using the specifier\n                     * as key, and a function which takes the timestamp as value. This\n                     * function returns the formatted portion of the date.\n                     *\n                     * @type {Object}\n                     * @name dateFormats\n                     * @memberOf Highcharts\n                     * @sample highcharts/global/dateformats/ Adding support for week\n                     * number\n                     */\n                    H.dateFormats\n                );\n\n\n            // Do the replaces\n            H.objectEach(replacements, function(val, key) {\n                // Regex would do it in one line, but this is faster\n                while (format.indexOf('%' + key) !== -1) {\n                    format = format.replace(\n                        '%' + key,\n                        typeof val === 'function' ? val(timestamp) : val\n                    );\n                }\n\n            });\n\n            // Optionally capitalize the string and return\n            return capitalize ?\n                format.substr(0, 1).toUpperCase() + format.substr(1) :\n                format;\n        };\n\n        /**\n         * Format a single variable. Similar to sprintf, without the % prefix.\n         *\n         * @example\n         * formatSingle('.2f', 5); // => '5.00'.\n         *\n         * @function #formatSingle\n         * @memberOf Highcharts\n         * @param {String} format The format string.\n         * @param {*} val The value.\n         * @returns {String} The formatted representation of the value.\n         */\n        H.formatSingle = function(format, val) {\n            var floatRegex = /f$/,\n                decRegex = /\\.([0-9])/,\n                lang = H.defaultOptions.lang,\n                decimals;\n\n            if (floatRegex.test(format)) { // float\n                decimals = format.match(decRegex);\n                decimals = decimals ? decimals[1] : -1;\n                if (val !== null) {\n                    val = H.numberFormat(\n                        val,\n                        decimals,\n                        lang.decimalPoint,\n                        format.indexOf(',') > -1 ? lang.thousandsSep : ''\n                    );\n                }\n            } else {\n                val = H.dateFormat(format, val);\n            }\n            return val;\n        };\n\n        /**\n         * Format a string according to a subset of the rules of Python's String.format\n         * method.\n         *\n         * @function #format\n         * @memberOf Highcharts\n         * @param {String} str The string to format.\n         * @param {Object} ctx The context, a collection of key-value pairs where each\n         *        key is replaced by its value.\n         * @returns {String} The formatted string.\n         *\n         * @example\n         * var s = Highcharts.format(\n         *     'The {color} fox was {len:.2f} feet long',\n         *     { color: 'red', len: Math.PI }\n         * );\n         * // => The red fox was 3.14 feet long\n         */\n        H.format = function(str, ctx) {\n            var splitter = '{',\n                isInside = false,\n                segment,\n                valueAndFormat,\n                path,\n                i,\n                len,\n                ret = [],\n                val,\n                index;\n\n            while (str) {\n                index = str.indexOf(splitter);\n                if (index === -1) {\n                    break;\n                }\n\n                segment = str.slice(0, index);\n                if (isInside) { // we're on the closing bracket looking back\n\n                    valueAndFormat = segment.split(':');\n                    path = valueAndFormat.shift().split('.'); // get first and leave\n                    len = path.length;\n                    val = ctx;\n\n                    // Assign deeper paths\n                    for (i = 0; i < len; i++) {\n                        val = val[path[i]];\n                    }\n\n                    // Format the replacement\n                    if (valueAndFormat.length) {\n                        val = H.formatSingle(valueAndFormat.join(':'), val);\n                    }\n\n                    // Push the result and advance the cursor\n                    ret.push(val);\n\n                } else {\n                    ret.push(segment);\n\n                }\n                str = str.slice(index + 1); // the rest\n                isInside = !isInside; // toggle\n                splitter = isInside ? '}' : '{'; // now look for next matching bracket\n            }\n            ret.push(str);\n            return ret.join('');\n        };\n\n        /**\n         * Get the magnitude of a number.\n         *\n         * @function #getMagnitude\n         * @memberOf Highcharts\n         * @param {Number} number The number.\n         * @returns {Number} The magnitude, where 1-9 are magnitude 1, 10-99 magnitude 2\n         *        etc.\n         */\n        H.getMagnitude = function(num) {\n            return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));\n        };\n\n        /**\n         * Take an interval and normalize it to multiples of round numbers.\n         *\n         * @todo  Move this function to the Axis prototype. It is here only for\n         *        historical reasons.\n         * @function #normalizeTickInterval\n         * @memberOf Highcharts\n         * @param {Number} interval - The raw, un-rounded interval.\n         * @param {Array} [multiples] - Allowed multiples.\n         * @param {Number} [magnitude] - The magnitude of the number.\n         * @param {Boolean} [allowDecimals] - Whether to allow decimals.\n         * @param {Boolean} [hasTickAmount] - If it has tickAmount, avoid landing\n         *        on tick intervals lower than original.\n         * @returns {Number} The normalized interval.\n         */\n        H.normalizeTickInterval = function(interval, multiples, magnitude,\n            allowDecimals, hasTickAmount) {\n            var normalized,\n                i,\n                retInterval = interval;\n\n            // round to a tenfold of 1, 2, 2.5 or 5\n            magnitude = H.pick(magnitude, 1);\n            normalized = interval / magnitude;\n\n            // multiples for a linear scale\n            if (!multiples) {\n                multiples = hasTickAmount ?\n                    // Finer grained ticks when the tick amount is hard set, including\n                    // when alignTicks is true on multiple axes (#4580).\n                    [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] :\n\n                    // Else, let ticks fall on rounder numbers\n                    [1, 2, 2.5, 5, 10];\n\n\n                // the allowDecimals option\n                if (allowDecimals === false) {\n                    if (magnitude === 1) {\n                        multiples = H.grep(multiples, function(num) {\n                            return num % 1 === 0;\n                        });\n                    } else if (magnitude <= 0.1) {\n                        multiples = [1 / magnitude];\n                    }\n                }\n            }\n\n            // normalize the interval to the nearest multiple\n            for (i = 0; i < multiples.length; i++) {\n                retInterval = multiples[i];\n                // only allow tick amounts smaller than natural\n                if ((hasTickAmount && retInterval * magnitude >= interval) ||\n                    (!hasTickAmount && (normalized <= (multiples[i] +\n                        (multiples[i + 1] || multiples[i])) / 2))) {\n                    break;\n                }\n            }\n\n            // Multiply back to the correct magnitude. Correct floats to appropriate \n            // precision (#6085).\n            retInterval = H.correctFloat(\n                retInterval * magnitude, -Math.round(Math.log(0.001) / Math.LN10)\n            );\n\n            return retInterval;\n        };\n\n\n        /**\n         * Sort an object array and keep the order of equal items. The ECMAScript\n         * standard does not specify the behaviour when items are equal.\n         *\n         * @function #stableSort\n         * @memberOf Highcharts\n         * @param {Array} arr - The array to sort.\n         * @param {Function} sortFunction - The function to sort it with, like with \n         *        regular Array.prototype.sort.\n         * @returns {void}\n         */\n        H.stableSort = function(arr, sortFunction) {\n            var length = arr.length,\n                sortValue,\n                i;\n\n            // Add index to each item\n            for (i = 0; i < length; i++) {\n                arr[i].safeI = i; // stable sort index\n            }\n\n            arr.sort(function(a, b) {\n                sortValue = sortFunction(a, b);\n                return sortValue === 0 ? a.safeI - b.safeI : sortValue;\n            });\n\n            // Remove index from items\n            for (i = 0; i < length; i++) {\n                delete arr[i].safeI; // stable sort index\n            }\n        };\n\n        /**\n         * Non-recursive method to find the lowest member of an array. `Math.min` raises\n         * a maximum call stack size exceeded error in Chrome when trying to apply more\n         * than 150.000 points. This method is slightly slower, but safe.\n         *\n         * @function #arrayMin\n         * @memberOf  Highcharts\n         * @param {Array} data An array of numbers.\n         * @returns {Number} The lowest number.\n         */\n        H.arrayMin = function(data) {\n            var i = data.length,\n                min = data[0];\n\n            while (i--) {\n                if (data[i] < min) {\n                    min = data[i];\n                }\n            }\n            return min;\n        };\n\n        /**\n         * Non-recursive method to find the lowest member of an array. `Math.max` raises\n         * a maximum call stack size exceeded error in Chrome when trying to apply more\n         * than 150.000 points. This method is slightly slower, but safe.\n         *\n         * @function #arrayMax\n         * @memberOf  Highcharts\n         * @param {Array} data - An array of numbers.\n         * @returns {Number} The highest number.\n         */\n        H.arrayMax = function(data) {\n            var i = data.length,\n                max = data[0];\n\n            while (i--) {\n                if (data[i] > max) {\n                    max = data[i];\n                }\n            }\n            return max;\n        };\n\n        /**\n         * Utility method that destroys any SVGElement instances that are properties on\n         * the given object. It loops all properties and invokes destroy if there is a\n         * destroy method. The property is then delete.\n         *\n         * @function #destroyObjectProperties\n         * @memberOf Highcharts\n         * @param {Object} obj - The object to destroy properties on.\n         * @param {Object} [except] - Exception, do not destroy this property, only\n         *    delete it.\n         * @returns {void}\n         */\n        H.destroyObjectProperties = function(obj, except) {\n            H.objectEach(obj, function(val, n) {\n                // If the object is non-null and destroy is defined\n                if (val && val !== except && val.destroy) {\n                    // Invoke the destroy\n                    val.destroy();\n                }\n\n                // Delete the property from the object.\n                delete obj[n];\n            });\n        };\n\n\n        /**\n         * Discard a HTML element by moving it to the bin and delete.\n         *\n         * @function #discardElement\n         * @memberOf Highcharts\n         * @param {HTMLDOMElement} element - The HTML node to discard.\n         * @returns {void}\n         */\n        H.discardElement = function(element) {\n            var garbageBin = H.garbageBin;\n            // create a garbage bin element, not part of the DOM\n            if (!garbageBin) {\n                garbageBin = H.createElement('div');\n            }\n\n            // move the node and empty bin\n            if (element) {\n                garbageBin.appendChild(element);\n            }\n            garbageBin.innerHTML = '';\n        };\n\n        /**\n         * Fix JS round off float errors.\n         *\n         * @function #correctFloat\n         * @memberOf Highcharts\n         * @param {Number} num - A float number to fix.\n         * @param {Number} [prec=14] - The precision.\n         * @returns {Number} The corrected float number.\n         */\n        H.correctFloat = function(num, prec) {\n            return parseFloat(\n                num.toPrecision(prec || 14)\n            );\n        };\n\n        /**\n         * Set the global animation to either a given value, or fall back to the given\n         * chart's animation option.\n         *\n         * @function #setAnimation\n         * @memberOf Highcharts\n         * @param {Boolean|Animation} animation - The animation object.\n         * @param {Object} chart - The chart instance.\n         * @returns {void}\n         * @todo This function always relates to a chart, and sets a property on the\n         *        renderer, so it should be moved to the SVGRenderer.\n         */\n        H.setAnimation = function(animation, chart) {\n            chart.renderer.globalAnimation = H.pick(\n                animation,\n                chart.options.chart.animation,\n                true\n            );\n        };\n\n        /**\n         * Get the animation in object form, where a disabled animation is always\n         * returned as `{ duration: 0 }`.\n         *\n         * @function #animObject\n         * @memberOf Highcharts\n         * @param {Boolean|AnimationOptions} animation - An animation setting. Can be an\n         *        object with duration, complete and easing properties, or a boolean to\n         *        enable or disable.\n         * @returns {AnimationOptions} An object with at least a duration property.\n         */\n        H.animObject = function(animation) {\n            return H.isObject(animation) ?\n                H.merge(animation) : {\n                    duration: animation ? 500 : 0\n                };\n        };\n\n        /**\n         * The time unit lookup\n         */\n        H.timeUnits = {\n            millisecond: 1,\n            second: 1000,\n            minute: 60000,\n            hour: 3600000,\n            day: 24 * 3600000,\n            week: 7 * 24 * 3600000,\n            month: 28 * 24 * 3600000,\n            year: 364 * 24 * 3600000\n        };\n\n        /**\n         * Format a number and return a string based on input settings.\n         *\n         * @function #numberFormat\n         * @memberOf Highcharts\n         * @param {Number} number - The input number to format.\n         * @param {Number} decimals - The amount of decimals. A value of -1 preserves\n         *        the amount in the input number.\n         * @param {String} [decimalPoint] - The decimal point, defaults to the one given\n         *        in the lang options, or a dot.\n         * @param {String} [thousandsSep] - The thousands separator, defaults to the one\n         *        given in the lang options, or a space character.\n         * @returns {String} The formatted number.\n         *\n         * @sample members/highcharts-numberformat/ Custom number format\n         */\n        H.numberFormat = function(number, decimals, decimalPoint, thousandsSep) {\n            number = +number || 0;\n            decimals = +decimals;\n\n            var lang = H.defaultOptions.lang,\n                origDec = (number.toString().split('.')[1] || '').length,\n                strinteger,\n                thousands,\n                ret,\n                roundedNumber;\n\n            if (decimals === -1) {\n                // Preserve decimals. Not huge numbers (#3793).\n                decimals = Math.min(origDec, 20);\n            } else if (!H.isNumber(decimals)) {\n                decimals = 2;\n            }\n\n            // Add another decimal to avoid rounding errors of float numbers. (#4573)\n            // Then use toFixed to handle rounding.\n            roundedNumber = (\n                Math.abs(number) + Math.pow(10, -Math.max(decimals, origDec) - 1)\n            ).toFixed(decimals);\n\n            // A string containing the positive integer component of the number\n            strinteger = String(H.pInt(roundedNumber));\n\n            // Leftover after grouping into thousands. Can be 0, 1 or 3.\n            thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;\n\n            // Language\n            decimalPoint = H.pick(decimalPoint, lang.decimalPoint);\n            thousandsSep = H.pick(thousandsSep, lang.thousandsSep);\n\n            // Start building the return\n            ret = number < 0 ? '-' : '';\n\n            // Add the leftover after grouping into thousands. For example, in the\n            // number 42 000 000, this line adds 42.\n            ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : '';\n\n            // Add the remaining thousands groups, joined by the thousands separator\n            ret += strinteger\n                .substr(thousands)\n                .replace(/(\\d{3})(?=\\d)/g, '$1' + thousandsSep);\n\n            // Add the decimal point and the decimal component\n            if (decimals) {\n                // Get the decimal component\n                ret += decimalPoint + roundedNumber.slice(-decimals);\n            }\n\n            return ret;\n        };\n\n        /**\n         * Easing definition\n         * @ignore\n         * @param   {Number} pos Current position, ranging from 0 to 1.\n         */\n        Math.easeInOutSine = function(pos) {\n            return -0.5 * (Math.cos(Math.PI * pos) - 1);\n        };\n\n        /**\n         * Get the computed CSS value for given element and property, only for numerical\n         * properties. For width and height, the dimension of the inner box (excluding\n         * padding) is returned. Used for fitting the chart within the container.\n         *\n         * @function #getStyle\n         * @memberOf Highcharts\n         * @param {HTMLDOMElement} el - A HTML element.\n         * @param {String} prop - The property name.\n         * @param {Boolean} [toInt=true] - Parse to integer.\n         * @returns {Number} - The numeric value.\n         */\n        H.getStyle = function(el, prop, toInt) {\n\n            var style;\n\n            // For width and height, return the actual inner pixel size (#4913)\n            if (prop === 'width') {\n                return Math.min(el.offsetWidth, el.scrollWidth) -\n                    H.getStyle(el, 'padding-left') -\n                    H.getStyle(el, 'padding-right');\n            } else if (prop === 'height') {\n                return Math.min(el.offsetHeight, el.scrollHeight) -\n                    H.getStyle(el, 'padding-top') -\n                    H.getStyle(el, 'padding-bottom');\n            }\n\n            // Otherwise, get the computed style\n            style = win.getComputedStyle(el, undefined);\n            if (style) {\n                style = style.getPropertyValue(prop);\n                if (H.pick(toInt, true)) {\n                    style = H.pInt(style);\n                }\n            }\n            return style;\n        };\n\n        /**\n         * Search for an item in an array.\n         *\n         * @function #inArray\n         * @memberOf Highcharts\n         * @param {*} item - The item to search for.\n         * @param {arr} arr - The array or node collection to search in.\n         * @returns {Number} - The index within the array, or -1 if not found.\n         */\n        H.inArray = function(item, arr) {\n            return arr.indexOf ? arr.indexOf(item) : [].indexOf.call(arr, item);\n        };\n\n        /**\n         * Filter an array by a callback.\n         *\n         * @function #grep\n         * @memberOf Highcharts\n         * @param {Array} arr - The array to filter.\n         * @param {Function} callback - The callback function. The function receives the\n         *        item as the first argument. Return `true` if the item is to be\n         *        preserved.\n         * @returns {Array} - A new, filtered array.\n         */\n        H.grep = function(arr, callback) {\n            return [].filter.call(arr, callback);\n        };\n\n        /**\n         * Return the value of the first element in the array that satisfies the \n         * provided testing function.\n         *\n         * @function #find\n         * @memberOf Highcharts\n         * @param {Array} arr - The array to test.\n         * @param {Function} callback - The callback function. The function receives the\n         *        item as the first argument. Return `true` if this item satisfies the\n         *        condition.\n         * @returns {Mixed} - The value of the element.\n         */\n        H.find = function(arr, callback) {\n            return [].find.call(arr, callback);\n        };\n\n        /**\n         * Map an array by a callback.\n         *\n         * @function #map\n         * @memberOf Highcharts\n         * @param {Array} arr - The array to map.\n         * @param {Function} fn - The callback function. Return the new value for the \n         *        new array.\n         * @returns {Array} - A new array item with modified items.\n         */\n        H.map = function(arr, fn) {\n            var results = [],\n                i = 0,\n                len = arr.length;\n\n            for (; i < len; i++) {\n                results[i] = fn.call(arr[i], arr[i], i, arr);\n            }\n\n            return results;\n        };\n\n        /**\n         * Get the element's offset position, corrected for `overflow: auto`.\n         *\n         * @function #offset\n         * @memberOf Highcharts\n         * @param {HTMLDOMElement} el - The HTML element.\n         * @returns {Object} An object containing `left` and `top` properties for the\n         * position in the page.\n         */\n        H.offset = function(el) {\n            var docElem = doc.documentElement,\n                box = el.getBoundingClientRect();\n\n            return {\n                top: box.top + (win.pageYOffset || docElem.scrollTop) -\n                    (docElem.clientTop || 0),\n                left: box.left + (win.pageXOffset || docElem.scrollLeft) -\n                    (docElem.clientLeft || 0)\n            };\n        };\n\n        /**\n         * Stop running animation.\n         *\n         * @todo A possible extension to this would be to stop a single property, when\n         * we want to continue animating others. Then assign the prop to the timer\n         * in the Fx.run method, and check for the prop here. This would be an\n         * improvement in all cases where we stop the animation from .attr. Instead of\n         * stopping everything, we can just stop the actual attributes we're setting.\n         *\n         * @function #stop\n         * @memberOf Highcharts\n         * @param {SVGElement} el - The SVGElement to stop animation on.\n         * @param {string} [prop] - The property to stop animating. If given, the stop\n         *    method will stop a single property from animating, while others continue.\n         * @returns {void}\n         */\n        H.stop = function(el, prop) {\n\n            var i = timers.length;\n\n            // Remove timers related to this element (#4519)\n            while (i--) {\n                if (timers[i].elem === el && (!prop || prop === timers[i].prop)) {\n                    timers[i].stopped = true; // #4667\n                }\n            }\n        };\n\n        /**\n         * Iterate over an array.\n         *\n         * @function #each\n         * @memberOf Highcharts\n         * @param {Array} arr - The array to iterate over.\n         * @param {Function} fn - The iterator callback. It passes three arguments:\n         * * item - The array item.\n         * * index - The item's index in the array.\n         * * arr - The array that each is being applied to.\n         * @param {Object} [ctx] The context.\n         */\n        H.each = function(arr, fn, ctx) { // modern browsers\n            return Array.prototype.forEach.call(arr, fn, ctx);\n        };\n\n        /**\n         * Iterate over object key pairs in an object.\n         *\n         * @function #objectEach\n         * @memberOf Highcharts\n         * @param  {Object}   obj - The object to iterate over.\n         * @param  {Function} fn  - The iterator callback. It passes three arguments:\n         * * value - The property value.\n         * * key - The property key.\n         * * obj - The object that objectEach is being applied to.\n         * @param  {Object}   ctx The context\n         */\n        H.objectEach = function(obj, fn, ctx) {\n            for (var key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    fn.call(ctx, obj[key], key, obj);\n                }\n            }\n        };\n\n        /**\n         * Add an event listener.\n         *\n         * @function #addEvent\n         * @memberOf Highcharts\n         * @param {Object} el - The element or object to add a listener to. It can be a\n         *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.\n         * @param {String} type - The event type.\n         * @param {Function} fn - The function callback to execute when the event is \n         *        fired.\n         * @returns {Function} A callback function to remove the added event.\n         */\n        H.addEvent = function(el, type, fn) {\n\n            var events = el.hcEvents = el.hcEvents || {};\n\n            function wrappedFn(e) {\n                e.target = e.srcElement || win; // #2820\n                fn.call(el, e);\n            }\n\n            // Handle DOM events in modern browsers\n            if (el.addEventListener) {\n                el.addEventListener(type, fn, false);\n\n                // Handle old IE implementation\n            } else if (el.attachEvent) {\n\n                if (!el.hcEventsIE) {\n                    el.hcEventsIE = {};\n                }\n\n                // Link wrapped fn with original fn, so we can get this in removeEvent\n                el.hcEventsIE[fn.toString()] = wrappedFn;\n\n                el.attachEvent('on' + type, wrappedFn);\n            }\n\n            if (!events[type]) {\n                events[type] = [];\n            }\n\n            events[type].push(fn);\n\n            // Return a function that can be called to remove this event.\n            return function() {\n                H.removeEvent(el, type, fn);\n            };\n        };\n\n        /**\n         * Remove an event that was added with {@link Highcharts#addEvent}.\n         *\n         * @function #removeEvent\n         * @memberOf Highcharts\n         * @param {Object} el - The element to remove events on.\n         * @param {String} [type] - The type of events to remove. If undefined, all\n         *        events are removed from the element.\n         * @param {Function} [fn] - The specific callback to remove. If undefined, all\n         *        events that match the element and optionally the type are removed.\n         * @returns {void}\n         */\n        H.removeEvent = function(el, type, fn) {\n\n            var events,\n                hcEvents = el.hcEvents,\n                index;\n\n            function removeOneEvent(type, fn) {\n                if (el.removeEventListener) {\n                    el.removeEventListener(type, fn, false);\n                } else if (el.attachEvent) {\n                    fn = el.hcEventsIE[fn.toString()];\n                    el.detachEvent('on' + type, fn);\n                }\n            }\n\n            function removeAllEvents() {\n                var types,\n                    len;\n\n                if (!el.nodeName) {\n                    return; // break on non-DOM events\n                }\n\n                if (type) {\n                    types = {};\n                    types[type] = true;\n                } else {\n                    types = hcEvents;\n                }\n\n                H.objectEach(types, function(val, n) {\n                    if (hcEvents[n]) {\n                        len = hcEvents[n].length;\n                        while (len--) {\n                            removeOneEvent(n, hcEvents[n][len]);\n                        }\n                    }\n                });\n            }\n\n            if (hcEvents) {\n                if (type) {\n                    events = hcEvents[type] || [];\n                    if (fn) {\n                        index = H.inArray(fn, events);\n                        if (index > -1) {\n                            events.splice(index, 1);\n                            hcEvents[type] = events;\n                        }\n                        removeOneEvent(type, fn);\n\n                    } else {\n                        removeAllEvents();\n                        hcEvents[type] = [];\n                    }\n                } else {\n                    removeAllEvents();\n                    el.hcEvents = {};\n                }\n            }\n        };\n\n        /**\n         * Fire an event that was registered with {@link Highcharts#addEvent}.\n         *\n         * @function #fireEvent\n         * @memberOf Highcharts\n         * @param {Object} el - The object to fire the event on. It can be a\n         *        {@link HTMLDOMElement}, an {@link SVGElement} or any other object.\n         * @param {String} type - The type of event.\n         * @param {Object} [eventArguments] - Custom event arguments that are passed on\n         *        as an argument to the event handler.\n         * @param {Function} [defaultFunction] - The default function to execute if the \n         *        other listeners haven't returned false.\n         * @returns {void}\n         */\n        H.fireEvent = function(el, type, eventArguments, defaultFunction) {\n            var e,\n                hcEvents = el.hcEvents,\n                events,\n                len,\n                i,\n                fn;\n\n            eventArguments = eventArguments || {};\n\n            if (doc.createEvent && (el.dispatchEvent || el.fireEvent)) {\n                e = doc.createEvent('Events');\n                e.initEvent(type, true, true);\n                //e.target = el;\n\n                H.extend(e, eventArguments);\n\n                if (el.dispatchEvent) {\n                    el.dispatchEvent(e);\n                } else {\n                    el.fireEvent(type, e);\n                }\n\n            } else if (hcEvents) {\n\n                events = hcEvents[type] || [];\n                len = events.length;\n\n                if (!eventArguments.target) { // We're running a custom event\n\n                    H.extend(eventArguments, {\n                        // Attach a simple preventDefault function to skip default\n                        // handler if called. The built-in defaultPrevented property is\n                        // not overwritable (#5112)\n                        preventDefault: function() {\n                            eventArguments.defaultPrevented = true;\n                        },\n                        // Setting target to native events fails with clicking the\n                        // zoom-out button in Chrome.\n                        target: el,\n                        // If the type is not set, we're running a custom event (#2297).\n                        // If it is set, we're running a browser event, and setting it\n                        // will cause en error in IE8 (#2465).\t\t\n                        type: type\n                    });\n                }\n\n\n                for (i = 0; i < len; i++) {\n                    fn = events[i];\n\n                    // If the event handler return false, prevent the default handler\n                    // from executing\n                    if (fn && fn.call(el, eventArguments) === false) {\n                        eventArguments.preventDefault();\n                    }\n                }\n            }\n\n            // Run the default if not prevented\n            if (defaultFunction && !eventArguments.defaultPrevented) {\n                defaultFunction(eventArguments);\n            }\n        };\n\n        /**\n         * An animation configuration. Animation configurations can also be defined as\n         * booleans, where `false` turns off animation and `true` defaults to a duration\n         * of 500ms.\n         * @typedef {Object} AnimationOptions\n         * @property {Number} duration - The animation duration in milliseconds.\n         * @property {String} [easing] - The name of an easing function as defined on\n         *     the `Math` object.\n         * @property {Function} [complete] - A callback function to exectute when the\n         *     animation finishes.\n         * @property {Function} [step] - A callback function to execute on each step of\n         *     each attribute or CSS property that's being animated. The first argument\n         *     contains information about the animation and progress.\n         */\n\n\n        /**\n         * The global animate method, which uses Fx to create individual animators.\n         *\n         * @function #animate\n         * @memberOf Highcharts\n         * @param {HTMLDOMElement|SVGElement} el - The element to animate.\n         * @param {Object} params - An object containing key-value pairs of the\n         *        properties to animate. Supports numeric as pixel-based CSS properties\n         *        for HTML objects and attributes for SVGElements.\n         * @param {AnimationOptions} [opt] - Animation options.\n         */\n        H.animate = function(el, params, opt) {\n            var start,\n                unit = '',\n                end,\n                fx,\n                args;\n\n            if (!H.isObject(opt)) { // Number or undefined/null\n                args = arguments;\n                opt = {\n                    duration: args[2],\n                    easing: args[3],\n                    complete: args[4]\n                };\n            }\n            if (!H.isNumber(opt.duration)) {\n                opt.duration = 400;\n            }\n            opt.easing = typeof opt.easing === 'function' ?\n                opt.easing :\n                (Math[opt.easing] || Math.easeInOutSine);\n            opt.curAnim = H.merge(params);\n\n            H.objectEach(params, function(val, prop) {\n                // Stop current running animation of this property\n                H.stop(el, prop);\n\n                fx = new H.Fx(el, opt, prop);\n                end = null;\n\n                if (prop === 'd') {\n                    fx.paths = fx.initPath(\n                        el,\n                        el.d,\n                        params.d\n                    );\n                    fx.toD = params.d;\n                    start = 0;\n                    end = 1;\n                } else if (el.attr) {\n                    start = el.attr(prop);\n                } else {\n                    start = parseFloat(H.getStyle(el, prop)) || 0;\n                    if (prop !== 'opacity') {\n                        unit = 'px';\n                    }\n                }\n\n                if (!end) {\n                    end = val;\n                }\n                if (end && end.match && end.match('px')) {\n                    end = end.replace(/px/g, ''); // #4351\n                }\n                fx.run(start, end, unit);\n            });\n        };\n\n        /**\n         * Factory to create new series prototypes.\n         *\n         * @function #seriesType\n         * @memberOf Highcharts\n         *\n         * @param {String} type - The series type name.\n         * @param {String} parent - The parent series type name. Use `line` to inherit\n         *        from the basic {@link Series} object.\n         * @param {Object} options - The additional default options that is merged with\n         *        the parent's options.\n         * @param {Object} props - The properties (functions and primitives) to set on\n         *        the new prototype.\n         * @param {Object} [pointProps] - Members for a series-specific extension of the\n         *        {@link Point} prototype if needed.\n         * @returns {*} - The newly created prototype as extended from {@link Series}\n         * or its derivatives.\n         */\n        // docs: add to API + extending Highcharts\n        H.seriesType = function(type, parent, options, props, pointProps) {\n            var defaultOptions = H.getOptions(),\n                seriesTypes = H.seriesTypes;\n\n            if (seriesTypes[type]) {\n                return H.error(27); // Series type already defined\n            }\n\n            // Merge the options\n            defaultOptions.plotOptions[type] = H.merge(\n                defaultOptions.plotOptions[parent],\n                options\n            );\n\n            // Create the class\n            seriesTypes[type] = H.extendClass(seriesTypes[parent] ||\n                function() {}, props);\n            seriesTypes[type].prototype.type = type;\n\n            // Create the point class if needed\n            if (pointProps) {\n                seriesTypes[type].prototype.pointClass =\n                    H.extendClass(H.Point, pointProps);\n            }\n\n            return seriesTypes[type];\n        };\n\n        /**\n         * Get a unique key for using in internal element id's and pointers. The key\n         * is composed of a random hash specific to this Highcharts instance, and a \n         * counter.\n         * @function #uniqueKey\n         * @memberOf Highcharts\n         * @return {string} The key.\n         * @example\n         * var id = H.uniqueKey(); // => 'highcharts-x45f6hp-0'\n         */\n        H.uniqueKey = (function() {\n\n            var uniqueKeyHash = Math.random().toString(36).substring(2, 9),\n                idCounter = 0;\n\n            return function() {\n                return 'highcharts-' + uniqueKeyHash + '-' + idCounter++;\n            };\n        }());\n\n        /**\n         * Register Highcharts as a plugin in jQuery\n         */\n        if (win.jQuery) {\n            win.jQuery.fn.highcharts = function() {\n                var args = [].slice.call(arguments);\n\n                if (this[0]) { // this[0] is the renderTo div\n\n                    // Create the chart\n                    if (args[0]) {\n                        new H[ // eslint-disable-line no-new\n                            // Constructor defaults to Chart\n                            H.isString(args[0]) ? args.shift() : 'Chart'\n                        ](this[0], args[0], args[1]);\n                        return this;\n                    }\n\n                    // When called without parameters or with the return argument,\n                    // return an existing chart\n                    return charts[H.attr(this[0], 'data-highcharts-chart')];\n                }\n            };\n        }\n\n\n        /**\n         * Compatibility section to add support for legacy IE. This can be removed if\n         * old IE support is not needed.\n         */\n        if (doc && !doc.defaultView) {\n            H.getStyle = function(el, prop) {\n                var val,\n                    alias = {\n                        width: 'clientWidth',\n                        height: 'clientHeight'\n                    }[prop];\n\n                if (el.style[prop]) {\n                    return H.pInt(el.style[prop]);\n                }\n                if (prop === 'opacity') {\n                    prop = 'filter';\n                }\n\n                // Getting the rendered width and height\n                if (alias) {\n                    el.style.zoom = 1;\n                    return Math.max(el[alias] - 2 * H.getStyle(el, 'padding'), 0);\n                }\n\n                val = el.currentStyle[prop.replace(/\\-(\\w)/g, function(a, b) {\n                    return b.toUpperCase();\n                })];\n                if (prop === 'filter') {\n                    val = val.replace(\n                        /alpha\\(opacity=([0-9]+)\\)/,\n                        function(a, b) {\n                            return b / 100;\n                        }\n                    );\n                }\n\n                return val === '' ? 1 : H.pInt(val);\n            };\n        }\n\n        if (!Array.prototype.forEach) {\n            H.each = function(arr, fn, ctx) { // legacy\n                var i = 0,\n                    len = arr.length;\n                for (; i < len; i++) {\n                    if (fn.call(ctx, arr[i], i, arr) === false) {\n                        return i;\n                    }\n                }\n            };\n        }\n\n        if (!Array.prototype.indexOf) {\n            H.inArray = function(item, arr) {\n                var len,\n                    i = 0;\n\n                if (arr) {\n                    len = arr.length;\n\n                    for (; i < len; i++) {\n                        if (arr[i] === item) {\n                            return i;\n                        }\n                    }\n                }\n\n                return -1;\n            };\n        }\n\n        if (!Array.prototype.filter) {\n            H.grep = function(elements, fn) {\n                var ret = [],\n                    i = 0,\n                    length = elements.length;\n\n                for (; i < length; i++) {\n                    if (fn(elements[i], i)) {\n                        ret.push(elements[i]);\n                    }\n                }\n\n                return ret;\n            };\n        }\n\n        if (!Array.prototype.find) {\n            H.find = function(arr, fn) {\n                var i,\n                    length = arr.length;\n\n                for (i = 0; i < length; i++) {\n                    if (fn(arr[i], i)) {\n                        return arr[i];\n                    }\n                }\n            };\n        }\n\n        //--- End compatibility section ---\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var each = H.each,\n            isNumber = H.isNumber,\n            map = H.map,\n            merge = H.merge,\n            pInt = H.pInt;\n\n        /**\n         * @typedef {string} ColorString\n         * A valid color to be parsed and handled by Highcharts. Highcharts internally \n         * supports hex colors like `#ffffff`, rgb colors like `rgb(255,255,255)` and\n         * rgba colors like `rgba(255,255,255,1)`. Other colors may be supported by the\n         * browsers and displayed correctly, but Highcharts is not able to process them\n         * and apply concepts like opacity and brightening.\n         */\n        /**\n         * Handle color operations. The object methods are chainable.\n         * @param {String} input The input color in either rbga or hex format\n         */\n        H.Color = function(input) {\n            // Backwards compatibility, allow instanciation without new\n            if (!(this instanceof H.Color)) {\n                return new H.Color(input);\n            }\n            // Initialize\n            this.init(input);\n        };\n        H.Color.prototype = {\n\n            // Collection of parsers. This can be extended from the outside by pushing parsers\n            // to Highcharts.Color.prototype.parsers.\n            parsers: [{\n                // RGBA color\n                regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n                parse: function(result) {\n                    return [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];\n                }\n            }, {\n                // RGB color\n                regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n                parse: function(result) {\n                    return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];\n                }\n            }],\n\n            // Collection of named colors. Can be extended from the outside by adding\n            // colors to Highcharts.Color.prototype.names.\n            names: {\n                none: 'rgba(255,255,255,0)',\n                white: '#ffffff',\n                black: '#000000'\n            },\n\n            /**\n             * Parse the input color to rgba array\n             * @param {String} input\n             */\n            init: function(input) {\n                var result,\n                    rgba,\n                    i,\n                    parser,\n                    len;\n\n                this.input = input = this.names[\n                    input && input.toLowerCase ?\n                    input.toLowerCase() :\n                    ''\n                ] || input;\n\n                // Gradients\n                if (input && input.stops) {\n                    this.stops = map(input.stops, function(stop) {\n                        return new H.Color(stop[1]);\n                    });\n\n                    // Solid colors\n                } else {\n\n                    // Check if it's possible to do bitmasking instead of regex\n                    if (input && input[0] === '#') {\n\n                        len = input.length;\n                        input = parseInt(input.substr(1), 16);\n\n                        // Handle long-form, e.g. #AABBCC\n                        if (len === 7) {\n\n                            rgba = [\n                                (input & 0xFF0000) >> 16,\n                                (input & 0xFF00) >> 8,\n                                (input & 0xFF),\n                                1\n                            ];\n\n                            // Handle short-form, e.g. #ABC\n                            // In short form, the value is assumed to be the same \n                            // for both nibbles for each component. e.g. #ABC = #AABBCC\n                        } else if (len === 4) {\n\n                            rgba = [\n                                ((input & 0xF00) >> 4) | (input & 0xF00) >> 8,\n                                ((input & 0xF0) >> 4) | (input & 0xF0),\n                                ((input & 0xF) << 4) | (input & 0xF),\n                                1\n                            ];\n                        }\n                    }\n\n                    // Otherwise, check regex parsers\n                    if (!rgba) {\n                        i = this.parsers.length;\n                        while (i-- && !rgba) {\n                            parser = this.parsers[i];\n                            result = parser.regex.exec(input);\n                            if (result) {\n                                rgba = parser.parse(result);\n                            }\n                        }\n                    }\n                }\n                this.rgba = rgba || [];\n            },\n\n            /**\n             * Return the color a specified format\n             * @param {String} format\n             */\n            get: function(format) {\n                var input = this.input,\n                    rgba = this.rgba,\n                    ret;\n\n                if (this.stops) {\n                    ret = merge(input);\n                    ret.stops = [].concat(ret.stops);\n                    each(this.stops, function(stop, i) {\n                        ret.stops[i] = [ret.stops[i][0], stop.get(format)];\n                    });\n\n                    // it's NaN if gradient colors on a column chart\n                } else if (rgba && isNumber(rgba[0])) {\n                    if (format === 'rgb' || (!format && rgba[3] === 1)) {\n                        ret = 'rgb(' + rgba[0] + ',' + rgba[1] + ',' + rgba[2] + ')';\n                    } else if (format === 'a') {\n                        ret = rgba[3];\n                    } else {\n                        ret = 'rgba(' + rgba.join(',') + ')';\n                    }\n                } else {\n                    ret = input;\n                }\n                return ret;\n            },\n\n            /**\n             * Brighten the color\n             * @param {Number} alpha\n             */\n            brighten: function(alpha) {\n                var i,\n                    rgba = this.rgba;\n\n                if (this.stops) {\n                    each(this.stops, function(stop) {\n                        stop.brighten(alpha);\n                    });\n\n                } else if (isNumber(alpha) && alpha !== 0) {\n                    for (i = 0; i < 3; i++) {\n                        rgba[i] += pInt(alpha * 255);\n\n                        if (rgba[i] < 0) {\n                            rgba[i] = 0;\n                        }\n                        if (rgba[i] > 255) {\n                            rgba[i] = 255;\n                        }\n                    }\n                }\n                return this;\n            },\n\n            /**\n             * Set the color's opacity to a given alpha value\n             * @param {Number} alpha\n             */\n            setOpacity: function(alpha) {\n                this.rgba[3] = alpha;\n                return this;\n            },\n\n            /*\n             * Return an intermediate color between two colors.\n             *\n             * @param  {Highcharts.Color} to\n             *         The color object to tween to.\n             * @param  {Number} pos\n             *         The intermediate position, where 0 is the from color (current\n             *         color item), and 1 is the `to` color.\n             *\n             * @return {String}\n             *         The intermediate color in rgba notation.\n             */\n            tweenTo: function(to, pos) {\n                // Check for has alpha, because rgba colors perform worse due to lack of\n                // support in WebKit.\n                var from = this,\n                    hasAlpha,\n                    ret;\n\n                // Unsupported color, return to-color (#3920)\n                if (!to.rgba.length) {\n                    ret = to.input || 'none';\n\n                    // Interpolate\n                } else {\n                    from = from.rgba;\n                    to = to.rgba;\n                    hasAlpha = (to[3] !== 1 || from[3] !== 1);\n                    ret = (hasAlpha ? 'rgba(' : 'rgb(') +\n                        Math.round(to[0] + (from[0] - to[0]) * (1 - pos)) + ',' +\n                        Math.round(to[1] + (from[1] - to[1]) * (1 - pos)) + ',' +\n                        Math.round(to[2] + (from[2] - to[2]) * (1 - pos)) +\n                        (hasAlpha ?\n                            (',' + (to[3] + (from[3] - to[3]) * (1 - pos))) :\n                            '') + ')';\n                }\n                return ret;\n            }\n        };\n        H.color = function(input) {\n            return new H.Color(input);\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var SVGElement,\n            SVGRenderer,\n\n            addEvent = H.addEvent,\n            animate = H.animate,\n            attr = H.attr,\n            charts = H.charts,\n            color = H.color,\n            css = H.css,\n            createElement = H.createElement,\n            defined = H.defined,\n            deg2rad = H.deg2rad,\n            destroyObjectProperties = H.destroyObjectProperties,\n            doc = H.doc,\n            each = H.each,\n            extend = H.extend,\n            erase = H.erase,\n            grep = H.grep,\n            hasTouch = H.hasTouch,\n            inArray = H.inArray,\n            isArray = H.isArray,\n            isFirefox = H.isFirefox,\n            isMS = H.isMS,\n            isObject = H.isObject,\n            isString = H.isString,\n            isWebKit = H.isWebKit,\n            merge = H.merge,\n            noop = H.noop,\n            objectEach = H.objectEach,\n            pick = H.pick,\n            pInt = H.pInt,\n            removeEvent = H.removeEvent,\n            splat = H.splat,\n            stop = H.stop,\n            svg = H.svg,\n            SVG_NS = H.SVG_NS,\n            symbolSizes = H.symbolSizes,\n            win = H.win;\n\n        /**\n         * @typedef {Object} SVGDOMElement - An SVG DOM element.\n         */\n        /**\n         * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the\n         * rendering layer of Highcharts. Combined with the {@link\n         * Highcharts.SVGRenderer} object, these prototypes allow freeform annotation\n         * in the charts or even in HTML pages without instanciating a chart. The\n         * SVGElement can also wrap HTML labels, when `text` or `label` elements are\n         * created with the `useHTML` parameter.\n         *\n         * The SVGElement instances are created through factory functions on the \n         * {@link Highcharts.SVGRenderer} object, like\n         * [rect]{@link Highcharts.SVGRenderer#rect}, [path]{@link\n         * Highcharts.SVGRenderer#path}, [text]{@link Highcharts.SVGRenderer#text},\n         * [label]{@link Highcharts.SVGRenderer#label}, [g]{@link\n         * Highcharts.SVGRenderer#g} and more.\n         *\n         * @class Highcharts.SVGElement\n         */\n        SVGElement = H.SVGElement = function() {\n            return this;\n        };\n        extend(SVGElement.prototype, /** @lends Highcharts.SVGElement.prototype */ {\n\n            // Default base for animation\n            opacity: 1,\n            SVG_NS: SVG_NS,\n\n            /**\n             * For labels, these CSS properties are applied to the `text` node directly.\n             * @type {Array.<string>}\n             */\n            textProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily',\n                'fontStyle', 'color', 'lineHeight', 'width', 'textAlign',\n                'textDecoration', 'textOverflow', 'textOutline'\n            ],\n\n            /**\n             * Initialize the SVG renderer. This function only exists to make the\n             * initiation process overridable. It should not be called directly.\n             *\n             * @param  {HighchartsSVGRenderer} renderer\n             *         The SVGRenderer instance to initialize to.\n             * @param  {String} nodeName\n             *         The SVG node name.\n             * @returns {void}\n             */\n            init: function(renderer, nodeName) {\n\n                /** \n                 * The DOM node. Each SVGRenderer instance wraps a main DOM node, but \n                 * may also represent more nodes.\n                 * @type {SVGDOMNode|HTMLDOMNode}\n                 */\n                this.element = nodeName === 'span' ?\n                    createElement(nodeName) :\n                    doc.createElementNS(this.SVG_NS, nodeName);\n\n                /**\n                 * The renderer that the SVGElement belongs to.\n                 * @type {Highcharts.SVGRenderer}\n                 */\n                this.renderer = renderer;\n            },\n\n            /**\n             * Animate to given attributes or CSS properties.\n             * \n             * @param {SVGAttributes} params SVG attributes or CSS to animate.\n             * @param {AnimationOptions} [options] Animation options.\n             * @param {Function} [complete] Function to perform at the end of animation.\n             *\n             * @sample highcharts/members/element-on/\n             *         Setting some attributes by animation\n             * \n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             */\n            animate: function(params, options, complete) {\n                var animOptions = H.animObject(\n                    pick(options, this.renderer.globalAnimation, true)\n                );\n                if (animOptions.duration !== 0) {\n                    if (complete) { // allows using a callback with the global animation without overwriting it\n                        animOptions.complete = complete;\n                    }\n                    animate(this, params, animOptions);\n                } else {\n                    this.attr(params, null, complete);\n                    if (animOptions.step) {\n                        animOptions.step.call(this);\n                    }\n                }\n                return this;\n            },\n\n            /**\n             * @typedef {Object} GradientOptions\n             * @property {Object} linearGradient Holds an object that defines the start\n             *    position and the end position relative to the shape.\n             * @property {Number} linearGradient.x1 Start horizontal position of the\n             *    gradient. Ranges 0-1.\n             * @property {Number} linearGradient.x2 End horizontal position of the\n             *    gradient. Ranges 0-1.\n             * @property {Number} linearGradient.y1 Start vertical position of the\n             *    gradient. Ranges 0-1.\n             * @property {Number} linearGradient.y2 End vertical position of the\n             *    gradient. Ranges 0-1.\n             * @property {Object} radialGradient Holds an object that defines the center\n             *    position and the radius.\n             * @property {Number} radialGradient.cx Center horizontal position relative\n             *    to the shape. Ranges 0-1.\n             * @property {Number} radialGradient.cy Center vertical position relative\n             *    to the shape. Ranges 0-1.\n             * @property {Number} radialGradient.r Radius relative to the shape. Ranges\n             *    0-1.\n             * @property {Array.<Array>} stops The first item in each tuple is the\n             *    position in the gradient, where 0 is the start of the gradient and 1\n             *    is the end of the gradient. Multiple stops can be applied. The second\n             *    item is the color for each stop. This color can also be given in the\n             *    rgba format.\n             *\n             * @example\n             * // Linear gradient used as a color option\n             * color: {\n             *     linearGradient: { x1: 0, x2: 0, y1: 0, y2: 1 },\n             *         stops: [\n             *             [0, '#003399'], // start\n             *             [0.5, '#ffffff'], // middle\n             *             [1, '#3366AA'] // end\n             *         ]\n             *     }\n             * }\n             */\n            /**\n             * Build and apply an SVG gradient out of a common JavaScript configuration\n             * object. This function is called from the attribute setters.\n             *\n             * @private\n             * @param {GradientOptions} color The gradient options structure.\n             * @param {string} prop The property to apply, can either be `fill` or\n             * `stroke`. \n             * @param {SVGDOMElement} elem SVG DOM element to apply the gradient on.\n             */\n            colorGradient: function(color, prop, elem) {\n                var renderer = this.renderer,\n                    colorObject,\n                    gradName,\n                    gradAttr,\n                    radAttr,\n                    gradients,\n                    gradientObject,\n                    stops,\n                    stopColor,\n                    stopOpacity,\n                    radialReference,\n                    id,\n                    key = [],\n                    value;\n\n                // Apply linear or radial gradients\n                if (color.radialGradient) {\n                    gradName = 'radialGradient';\n                } else if (color.linearGradient) {\n                    gradName = 'linearGradient';\n                }\n\n                if (gradName) {\n                    gradAttr = color[gradName];\n                    gradients = renderer.gradients;\n                    stops = color.stops;\n                    radialReference = elem.radialReference;\n\n                    // Keep < 2.2 kompatibility\n                    if (isArray(gradAttr)) {\n                        color[gradName] = gradAttr = {\n                            x1: gradAttr[0],\n                            y1: gradAttr[1],\n                            x2: gradAttr[2],\n                            y2: gradAttr[3],\n                            gradientUnits: 'userSpaceOnUse'\n                        };\n                    }\n\n                    // Correct the radial gradient for the radial reference system\n                    if (\n                        gradName === 'radialGradient' &&\n                        radialReference &&\n                        !defined(gradAttr.gradientUnits)\n                    ) {\n                        radAttr = gradAttr; // Save the radial attributes for updating\n                        gradAttr = merge(\n                            gradAttr,\n                            renderer.getRadialAttr(radialReference, radAttr), {\n                                gradientUnits: 'userSpaceOnUse'\n                            }\n                        );\n                    }\n\n                    // Build the unique key to detect whether we need to create a new element (#1282)\n                    objectEach(gradAttr, function(val, n) {\n                        if (n !== 'id') {\n                            key.push(n, val);\n                        }\n                    });\n                    objectEach(stops, function(val) {\n                        key.push(val);\n                    });\n                    key = key.join(',');\n\n                    // Check if a gradient object with the same config object is created within this renderer\n                    if (gradients[key]) {\n                        id = gradients[key].attr('id');\n\n                    } else {\n\n                        // Set the id and create the element\n                        gradAttr.id = id = H.uniqueKey();\n                        gradients[key] = gradientObject = renderer.createElement(gradName)\n                            .attr(gradAttr)\n                            .add(renderer.defs);\n\n                        gradientObject.radAttr = radAttr;\n\n                        // The gradient needs to keep a list of stops to be able to destroy them\n                        gradientObject.stops = [];\n                        each(stops, function(stop) {\n                            var stopObject;\n                            if (stop[1].indexOf('rgba') === 0) {\n                                colorObject = H.color(stop[1]);\n                                stopColor = colorObject.get('rgb');\n                                stopOpacity = colorObject.get('a');\n                            } else {\n                                stopColor = stop[1];\n                                stopOpacity = 1;\n                            }\n                            stopObject = renderer.createElement('stop').attr({\n                                offset: stop[0],\n                                'stop-color': stopColor,\n                                'stop-opacity': stopOpacity\n                            }).add(gradientObject);\n\n                            // Add the stop element to the gradient\n                            gradientObject.stops.push(stopObject);\n                        });\n                    }\n\n                    // Set the reference to the gradient object\n                    value = 'url(' + renderer.url + '#' + id + ')';\n                    elem.setAttribute(prop, value);\n                    elem.gradient = key;\n\n                    // Allow the color to be concatenated into tooltips formatters etc. (#2995)\n                    color.toString = function() {\n                        return value;\n                    };\n                }\n            },\n\n            /**\n             * Apply a text outline through a custom CSS property, by copying the text\n             * element and apply stroke to the copy. Used internally. Contrast checks\n             * at http://jsfiddle.net/highcharts/43soe9m1/2/ .\n             *\n             * @private\n             * @param {String} textOutline A custom CSS `text-outline` setting, defined\n             *    by `width color`. \n             * @example\n             * // Specific color\n             * text.css({\n             *    textOutline: '1px black'\n             * });\n             * // Automatic contrast\n             * text.css({\n             *    color: '#000000', // black text\n             *    textOutline: '1px contrast' // => white outline\n             * });\n             */\n            applyTextOutline: function(textOutline) {\n                var elem = this.element,\n                    tspans,\n                    tspan,\n                    hasContrast = textOutline.indexOf('contrast') !== -1,\n                    styles = {},\n                    color,\n                    strokeWidth,\n                    firstRealChild,\n                    i;\n\n                // When the text shadow is set to contrast, use dark stroke for light\n                // text and vice versa.\n                if (hasContrast) {\n                    styles.textOutline = textOutline = textOutline.replace(\n                        /contrast/g,\n                        this.renderer.getContrast(elem.style.fill)\n                    );\n                }\n\n                // Extract the stroke width and color\n                textOutline = textOutline.split(' ');\n                color = textOutline[textOutline.length - 1];\n                strokeWidth = textOutline[0];\n\n                if (strokeWidth && strokeWidth !== 'none' && H.svg) {\n\n                    this.fakeTS = true; // Fake text shadow\n\n                    tspans = [].slice.call(elem.getElementsByTagName('tspan'));\n\n                    // In order to get the right y position of the clone,\n                    // copy over the y setter\n                    this.ySetter = this.xSetter;\n\n                    // Since the stroke is applied on center of the actual outline, we\n                    // need to double it to get the correct stroke-width outside the \n                    // glyphs.\n                    strokeWidth = strokeWidth.replace(\n                        /(^[\\d\\.]+)(.*?)$/g,\n                        function(match, digit, unit) {\n                            return (2 * digit) + unit;\n                        }\n                    );\n\n                    // Remove shadows from previous runs. Iterate from the end to\n                    // support removing items inside the cycle (#6472).\n                    i = tspans.length;\n                    while (i--) {\n                        tspan = tspans[i];\n                        if (tspan.getAttribute('class') === 'highcharts-text-outline') {\n                            // Remove then erase\n                            erase(tspans, elem.removeChild(tspan));\n                        }\n                    }\n\n                    // For each of the tspans, create a stroked copy behind it.\n                    firstRealChild = elem.firstChild;\n                    each(tspans, function(tspan, y) {\n                        var clone;\n\n                        // Let the first line start at the correct X position\n                        if (y === 0) {\n                            tspan.setAttribute('x', elem.getAttribute('x'));\n                            y = elem.getAttribute('y');\n                            tspan.setAttribute('y', y || 0);\n                            if (y === null) {\n                                elem.setAttribute('y', 0);\n                            }\n                        }\n\n                        // Create the clone and apply outline properties\n                        clone = tspan.cloneNode(1);\n                        attr(clone, {\n                            'class': 'highcharts-text-outline',\n                            'fill': color,\n                            'stroke': color,\n                            'stroke-width': strokeWidth,\n                            'stroke-linejoin': 'round'\n                        });\n                        elem.insertBefore(clone, firstRealChild);\n                    });\n                }\n            },\n\n            /**\n             *\n             * @typedef {Object} SVGAttributes An object of key-value pairs for SVG\n             *   attributes. Attributes in Highcharts elements for the most parts\n             *   correspond to SVG, but some are specific to Highcharts, like `zIndex`,\n             *   `rotation`, `translateX`, `translateY`, `scaleX` and `scaleY`. SVG\n             *   attributes containing a hyphen are _not_ camel-cased, they should be\n             *   quoted to preserve the hyphen.\n             * @example\n             * {\n             *     'stroke': '#ff0000', // basic\n             *     'stroke-width': 2, // hyphenated\n             *     'rotation': 45 // custom\n             *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format\n             * }\n             */\n            /**\n             * Apply native and custom attributes to the SVG elements.\n             * \n             * In order to set the rotation center for rotation, set x and y to 0 and\n             * use `translateX` and `translateY` attributes to position the element\n             * instead.\n             *\n             * Attributes frequently used in Highcharts are `fill`, `stroke`,\n             * `stroke-width`.\n             *\n             * @param {SVGAttributes|String} hash - The native and custom SVG\n             *    attributes. \n             * @param {string} [val] - If the type of the first argument is `string`, \n             *    the second can be a value, which will serve as a single attribute\n             *    setter. If the first argument is a string and the second is undefined,\n             *    the function serves as a getter and the current value of the property\n             *    is returned.\n             * @param {Function} [complete] - A callback function to execute after setting\n             *    the attributes. This makes the function compliant and interchangeable\n             *    with the {@link SVGElement#animate} function.\n             * @param {boolean} [continueAnimation=true] Used internally when `.attr` is\n             *    called as part of an animation step. Otherwise, calling `.attr` for an\n             *    attribute will stop animation for that attribute.\n             *    \n             * @returns {SVGElement|string|number} If used as a setter, it returns the \n             *    current {@link SVGElement} so the calls can be chained. If used as a \n             *    getter, the current value of the attribute is returned.\n             *\n             * @sample highcharts/members/renderer-rect/\n             *         Setting some attributes\n             * \n             * @example\n             * // Set multiple attributes\n             * element.attr({\n             *     stroke: 'red',\n             *     fill: 'blue',\n             *     x: 10,\n             *     y: 10\n             * });\n             *\n             * // Set a single attribute\n             * element.attr('stroke', 'red');\n             *\n             * // Get an attribute\n             * element.attr('stroke'); // => 'red'\n             * \n             */\n            attr: function(hash, val, complete, continueAnimation) {\n                var key,\n                    element = this.element,\n                    hasSetSymbolSize,\n                    ret = this,\n                    skipAttr,\n                    setter;\n\n                // single key-value pair\n                if (typeof hash === 'string' && val !== undefined) {\n                    key = hash;\n                    hash = {};\n                    hash[key] = val;\n                }\n\n                // used as a getter: first argument is a string, second is undefined\n                if (typeof hash === 'string') {\n                    ret = (this[hash + 'Getter'] || this._defaultGetter).call(this, hash, element);\n\n                    // setter\n                } else {\n\n                    objectEach(hash, function(val, key) {\n                        skipAttr = false;\n\n                        // Unless .attr is from the animator update, stop current\n                        // running animation of this property\n                        if (!continueAnimation) {\n                            stop(this, key);\n                        }\n\n                        // Special handling of symbol attributes\n                        if (\n                            this.symbolName &&\n                            /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/\n                            .test(key)\n                        ) {\n                            if (!hasSetSymbolSize) {\n                                this.symbolAttr(hash);\n                                hasSetSymbolSize = true;\n                            }\n                            skipAttr = true;\n                        }\n\n                        if (this.rotation && (key === 'x' || key === 'y')) {\n                            this.doTransform = true;\n                        }\n\n                        if (!skipAttr) {\n                            setter = this[key + 'Setter'] || this._defaultSetter;\n                            setter.call(this, val, key, element);\n\n\n                            // Let the shadow follow the main element\n                            if (this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key)) {\n                                this.updateShadows(key, val, setter);\n                            }\n\n                        }\n                    }, this);\n\n                    this.afterSetters();\n                }\n\n                // In accordance with animate, run a complete callback\n                if (complete) {\n                    complete();\n                }\n\n                return ret;\n            },\n\n            /**\n             * This method is executed in the end of {attr}, after setting all attributes in the hash.\n             * In can be used to efficiently consolidate multiple attributes in one SVG property -- e.g.,\n             * translate, rotate and scale are merged in one \"transform\" attribute in the SVG node.\n             */\n            afterSetters: function() {\n                // Update transform. Do this outside the loop to prevent redundant updating for batch setting\n                // of attributes.\n                if (this.doTransform) {\n                    this.updateTransform();\n                    this.doTransform = false;\n                }\n            },\n\n\n            /**\n             * Update the shadow elements with new attributes.\n             *\n             * @private\n             * @param {String} key - The attribute name.\n             * @param {String|Number} value - The value of the attribute.\n             * @param {Function} setter - The setter function, inherited from the\n             *   parent wrapper\n             * @returns {void}\n             */\n            updateShadows: function(key, value, setter) {\n                var shadows = this.shadows,\n                    i = shadows.length;\n\n                while (i--) {\n                    setter.call(\n                        shadows[i],\n                        key === 'height' ?\n                        Math.max(value - (shadows[i].cutHeight || 0), 0) :\n                        key === 'd' ? this.d : value,\n                        key,\n                        shadows[i]\n                    );\n                }\n            },\n\n\n            /**\n             * Add a class name to an element.\n             *\n             * @param {string} className - The new class name to add.\n             * @param {boolean} [replace=false] - When true, the existing class name(s)\n             *    will be overwritten with the new one. When false, the new one is\n             *    added.\n             * @returns {Highcharts.SVGElement} Return the SVG element for chainability.\n             */\n            addClass: function(className, replace) {\n                var currentClassName = this.attr('class') || '';\n\n                if (currentClassName.indexOf(className) === -1) {\n                    if (!replace) {\n                        className =\n                            (currentClassName + (currentClassName ? ' ' : '') +\n                                className).replace('  ', ' ');\n                    }\n                    this.attr('class', className);\n                }\n                return this;\n            },\n\n            /**\n             * Check if an element has the given class name.\n             * @param  {string}  className - The class name to check for.\n             * @return {Boolean}\n             */\n            hasClass: function(className) {\n                return attr(this.element, 'class').indexOf(className) !== -1;\n            },\n\n            /**\n             * Remove a class name from the element.\n             * @param  {string} className The class name to remove.\n             * @return {Highcharts.SVGElement} Returns the SVG element for chainability.\n             */\n            removeClass: function(className) {\n                attr(this.element, 'class', (attr(this.element, 'class') || '').replace(className, ''));\n                return this;\n            },\n\n            /**\n             * If one of the symbol size affecting parameters are changed,\n             * check all the others only once for each call to an element's\n             * .attr() method\n             * @param {Object} hash - The attributes to set.\n             * @private\n             */\n            symbolAttr: function(hash) {\n                var wrapper = this;\n\n                each(['x', 'y', 'r', 'start', 'end', 'width', 'height', 'innerR', 'anchorX', 'anchorY'], function(key) {\n                    wrapper[key] = pick(hash[key], wrapper[key]);\n                });\n\n                wrapper.attr({\n                    d: wrapper.renderer.symbols[wrapper.symbolName](\n                        wrapper.x,\n                        wrapper.y,\n                        wrapper.width,\n                        wrapper.height,\n                        wrapper\n                    )\n                });\n            },\n\n            /**\n             * Apply a clipping rectangle to this element.\n             * \n             * @param {ClipRect} [clipRect] - The clipping rectangle. If skipped, the\n             *    current clip is removed.\n             * @returns {Highcharts.SVGElement} Returns the SVG element to allow chaining.\n             */\n            clip: function(clipRect) {\n                return this.attr(\n                    'clip-path',\n                    clipRect ?\n                    'url(' + this.renderer.url + '#' + clipRect.id + ')' :\n                    'none'\n                );\n            },\n\n            /**\n             * Calculate the coordinates needed for drawing a rectangle crisply and\n             * return the calculated attributes.\n             * \n             * @param {Object} rect - A rectangle.\n             * @param {number} rect.x - The x position.\n             * @param {number} rect.y - The y position.\n             * @param {number} rect.width - The width.\n             * @param {number} rect.height - The height.\n             * @param {number} [strokeWidth] - The stroke width to consider when\n             *    computing crisp positioning. It can also be set directly on the rect\n             *    parameter.\n             *\n             * @returns {{x: Number, y: Number, width: Number, height: Number}} The\n             *    modified rectangle arguments.\n             */\n            crisp: function(rect, strokeWidth) {\n\n                var wrapper = this,\n                    attribs = {},\n                    normalizer;\n\n                strokeWidth = strokeWidth || rect.strokeWidth || 0;\n                normalizer = Math.round(strokeWidth) % 2 / 2; // Math.round because strokeWidth can sometimes have roundoff errors\n\n                // normalize for crisp edges\n                rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;\n                rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;\n                rect.width = Math.floor((rect.width || wrapper.width || 0) - 2 * normalizer);\n                rect.height = Math.floor((rect.height || wrapper.height || 0) - 2 * normalizer);\n                if (defined(rect.strokeWidth)) {\n                    rect.strokeWidth = strokeWidth;\n                }\n\n                objectEach(rect, function(val, key) {\n                    if (wrapper[key] !== val) { // only set attribute if changed\n                        wrapper[key] = attribs[key] = val;\n                    }\n                });\n\n                return attribs;\n            },\n\n            /**\n             * Set styles for the element. In addition to CSS styles supported by \n             * native SVG and HTML elements, there are also some custom made for \n             * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text\n             * elements.\n             * @param {CSSObject} styles The new CSS styles.\n             * @returns {Highcharts.SVGElement} Return the SVG element for chaining.\n             *\n             * @sample highcharts/members/renderer-text-on-chart/\n             *         Styled text\n             */\n            css: function(styles) {\n                var oldStyles = this.styles,\n                    newStyles = {},\n                    elem = this.element,\n                    textWidth,\n                    serializedCss = '',\n                    hyphenate,\n                    hasNew = !oldStyles,\n                    // These CSS properties are interpreted internally by the SVG\n                    // renderer, but are not supported by SVG and should not be added to\n                    // the DOM. In styled mode, no CSS should find its way to the DOM\n                    // whatsoever (#6173, #6474).\n                    svgPseudoProps = ['textOutline', 'textOverflow', 'width'];\n\n                // convert legacy\n                if (styles && styles.color) {\n                    styles.fill = styles.color;\n                }\n\n                // Filter out existing styles to increase performance (#2640)\n                if (oldStyles) {\n                    objectEach(styles, function(style, n) {\n                        if (style !== oldStyles[n]) {\n                            newStyles[n] = style;\n                            hasNew = true;\n                        }\n                    });\n                }\n                if (hasNew) {\n\n                    // Merge the new styles with the old ones\n                    if (oldStyles) {\n                        styles = extend(\n                            oldStyles,\n                            newStyles\n                        );\n                    }\n\n                    // Get the text width from style\n                    textWidth = this.textWidth = (\n                        styles &&\n                        styles.width &&\n                        styles.width !== 'auto' &&\n                        elem.nodeName.toLowerCase() === 'text' &&\n                        pInt(styles.width)\n                    );\n\n                    // store object\n                    this.styles = styles;\n\n                    if (textWidth && (!svg && this.renderer.forExport)) {\n                        delete styles.width;\n                    }\n\n                    // serialize and set style attribute\n                    if (isMS && !svg) {\n                        css(this.element, styles);\n                    } else {\n                        hyphenate = function(a, b) {\n                            return '-' + b.toLowerCase();\n                        };\n                        objectEach(styles, function(style, n) {\n                            if (inArray(n, svgPseudoProps) === -1) {\n                                serializedCss +=\n                                    n.replace(/([A-Z])/g, hyphenate) + ':' +\n                                    style + ';';\n                            }\n                        });\n                        if (serializedCss) {\n                            attr(elem, 'style', serializedCss); // #1881\n                        }\n                    }\n\n\n                    if (this.added) {\n\n                        // Rebuild text after added. Cache mechanisms in the buildText\n                        // will prevent building if there are no significant changes.\n                        if (this.element.nodeName === 'text') {\n                            this.renderer.buildText(this);\n                        }\n\n                        // Apply text outline after added\n                        if (styles && styles.textOutline) {\n                            this.applyTextOutline(styles.textOutline);\n                        }\n                    }\n                }\n\n                return this;\n            },\n\n\n            /**\n             * Get the current stroke width. In classic mode, the setter registers it \n             * directly on the element.\n             * @returns {number} The stroke width in pixels.\n             * @ignore\n             */\n            strokeWidth: function() {\n                return this['stroke-width'] || 0;\n            },\n\n\n            /**\n             * Add an event listener. This is a simple setter that replaces all other\n             * events of the same type, opposed to the {@link Highcharts#addEvent}\n             * function.\n             * @param {string} eventType - The event type. If the type is `click`, \n             *    Highcharts will internally translate it to a `touchstart` event on \n             *    touch devices, to prevent the browser from waiting for a click event\n             *    from firing.\n             * @param {Function} handler - The handler callback.\n             * @returns {Highcharts.SVGElement} The SVGElement for chaining.\n             *\n             * @sample highcharts/members/element-on/\n             *         A clickable rectangle\n             */\n            on: function(eventType, handler) {\n                var svgElement = this,\n                    element = svgElement.element;\n\n                // touch\n                if (hasTouch && eventType === 'click') {\n                    element.ontouchstart = function(e) {\n                        svgElement.touchEventFired = Date.now(); // #2269\n                        e.preventDefault();\n                        handler.call(element, e);\n                    };\n                    element.onclick = function(e) {\n                        if (win.navigator.userAgent.indexOf('Android') === -1 ||\n                            Date.now() - (svgElement.touchEventFired || 0) > 1100) {\n                            handler.call(element, e);\n                        }\n                    };\n                } else {\n                    // simplest possible event model for internal use\n                    element['on' + eventType] = handler;\n                }\n                return this;\n            },\n\n            /**\n             * Set the coordinates needed to draw a consistent radial gradient across\n             * a shape regardless of positioning inside the chart. Used on pie slices\n             * to make all the slices have the same radial reference point.\n             *\n             * @param {Array} coordinates The center reference. The format is\n             *    `[centerX, centerY, diameter]` in pixels.\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             */\n            setRadialReference: function(coordinates) {\n                var existingGradient = this.renderer.gradients[this.element.gradient];\n\n                this.element.radialReference = coordinates;\n\n                // On redrawing objects with an existing gradient, the gradient needs\n                // to be repositioned (#3801)\n                if (existingGradient && existingGradient.radAttr) {\n                    existingGradient.animate(\n                        this.renderer.getRadialAttr(\n                            coordinates,\n                            existingGradient.radAttr\n                        )\n                    );\n                }\n\n                return this;\n            },\n\n            /**\n             * Move an object and its children by x and y values.\n             * \n             * @param {number} x - The x value.\n             * @param {number} y - The y value.\n             */\n            translate: function(x, y) {\n                return this.attr({\n                    translateX: x,\n                    translateY: y\n                });\n            },\n\n            /**\n             * Invert a group, rotate and flip. This is used internally on inverted \n             * charts, where the points and graphs are drawn as if not inverted, then\n             * the series group elements are inverted.\n             *\n             * @param {boolean} inverted - Whether to invert or not. An inverted shape\n             *    can be un-inverted by setting it to false.\n             * @returns {Highcharts.SVGElement} Return the SVGElement for chaining.\n             */\n            invert: function(inverted) {\n                var wrapper = this;\n                wrapper.inverted = inverted;\n                wrapper.updateTransform();\n                return wrapper;\n            },\n\n            /**\n             * Update the transform attribute based on internal properties. Deals with\n             * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`\n             * attributes and updates the SVG `transform` attribute.\n             * @private\n             * @returns {void}\n             */\n            updateTransform: function() {\n                var wrapper = this,\n                    translateX = wrapper.translateX || 0,\n                    translateY = wrapper.translateY || 0,\n                    scaleX = wrapper.scaleX,\n                    scaleY = wrapper.scaleY,\n                    inverted = wrapper.inverted,\n                    rotation = wrapper.rotation,\n                    element = wrapper.element,\n                    transform;\n\n                // flipping affects translate as adjustment for flipping around the group's axis\n                if (inverted) {\n                    translateX += wrapper.width;\n                    translateY += wrapper.height;\n                }\n\n                // Apply translate. Nearly all transformed elements have translation, so instead\n                // of checking for translate = 0, do it always (#1767, #1846).\n                transform = ['translate(' + translateX + ',' + translateY + ')'];\n\n                // apply rotation\n                if (inverted) {\n                    transform.push('rotate(90) scale(-1,1)');\n                } else if (rotation) { // text rotation\n                    transform.push('rotate(' + rotation + ' ' + (element.getAttribute('x') || 0) + ' ' + (element.getAttribute('y') || 0) + ')');\n\n                    // Delete bBox memo when the rotation changes\n                    //delete wrapper.bBox;\n                }\n\n                // apply scale\n                if (defined(scaleX) || defined(scaleY)) {\n                    transform.push('scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')');\n                }\n\n                if (transform.length) {\n                    element.setAttribute('transform', transform.join(' '));\n                }\n            },\n\n            /**\n             * Bring the element to the front. Alternatively, a new zIndex can be set.\n             *\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             *\n             * @sample highcharts/members/element-tofront/\n             *         Click an element to bring it to front\n             */\n            toFront: function() {\n                var element = this.element;\n                element.parentNode.appendChild(element);\n                return this;\n            },\n\n\n            /**\n             * Align the element relative to the chart or another box.\n             * \n             * @param {Object} [alignOptions] The alignment options. The function can be\n             *   called without this parameter in order to re-align an element after the\n             *   box has been updated.\n             * @param {string} [alignOptions.align=left] Horizontal alignment. Can be\n             *   one of `left`, `center` and `right`.\n             * @param {string} [alignOptions.verticalAlign=top] Vertical alignment. Can\n             *   be one of `top`, `middle` and `bottom`.\n             * @param {number} [alignOptions.x=0] Horizontal pixel offset from\n             *   alignment.\n             * @param {number} [alignOptions.y=0] Vertical pixel offset from alignment.\n             * @param {Boolean} [alignByTranslate=false] Use the `transform` attribute\n             *   with translateX and translateY custom attributes to align this elements\n             *   rather than `x` and `y` attributes.\n             * @param {String|Object} box The box to align to, needs a width and height.\n             *   When the box is a string, it refers to an object in the Renderer. For\n             *   example, when box is `spacingBox`, it refers to `Renderer.spacingBox`\n             *   which holds `width`, `height`, `x` and `y` properties.\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             */\n            align: function(alignOptions, alignByTranslate, box) {\n                var align,\n                    vAlign,\n                    x,\n                    y,\n                    attribs = {},\n                    alignTo,\n                    renderer = this.renderer,\n                    alignedObjects = renderer.alignedObjects,\n                    alignFactor,\n                    vAlignFactor;\n\n                // First call on instanciate\n                if (alignOptions) {\n                    this.alignOptions = alignOptions;\n                    this.alignByTranslate = alignByTranslate;\n                    if (!box || isString(box)) { // boxes other than renderer handle this internally\n                        this.alignTo = alignTo = box || 'renderer';\n                        erase(alignedObjects, this); // prevent duplicates, like legendGroup after resize\n                        alignedObjects.push(this);\n                        box = null; // reassign it below\n                    }\n\n                    // When called on resize, no arguments are supplied\n                } else {\n                    alignOptions = this.alignOptions;\n                    alignByTranslate = this.alignByTranslate;\n                    alignTo = this.alignTo;\n                }\n\n                box = pick(box, renderer[alignTo], renderer);\n\n                // Assign variables\n                align = alignOptions.align;\n                vAlign = alignOptions.verticalAlign;\n                x = (box.x || 0) + (alignOptions.x || 0); // default: left align\n                y = (box.y || 0) + (alignOptions.y || 0); // default: top align\n\n                // Align\n                if (align === 'right') {\n                    alignFactor = 1;\n                } else if (align === 'center') {\n                    alignFactor = 2;\n                }\n                if (alignFactor) {\n                    x += (box.width - (alignOptions.width || 0)) / alignFactor;\n                }\n                attribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);\n\n\n                // Vertical align\n                if (vAlign === 'bottom') {\n                    vAlignFactor = 1;\n                } else if (vAlign === 'middle') {\n                    vAlignFactor = 2;\n                }\n                if (vAlignFactor) {\n                    y += (box.height - (alignOptions.height || 0)) / vAlignFactor;\n                }\n                attribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);\n\n                // Animate only if already placed\n                this[this.placed ? 'animate' : 'attr'](attribs);\n                this.placed = true;\n                this.alignAttr = attribs;\n\n                return this;\n            },\n\n            /**\n             * Get the bounding box (width, height, x and y) for the element. Generally\n             * used to get rendered text size. Since this is called a lot in charts,\n             * the results are cached based on text properties, in order to save DOM\n             * traffic. The returned bounding box includes the rotation, so for example\n             * a single text line of rotation 90 will report a greater height, and a\n             * width corresponding to the line-height.\n             *\n             * @param {boolean} [reload] Skip the cache and get the updated DOM bouding\n             *   box.\n             * @param {number} [rot] Override the element's rotation. This is internally\n             *   used on axis labels with a value of 0 to find out what the bounding box\n             *   would be have been if it were not rotated.\n             * @returns {Object} The bounding box with `x`, `y`, `width` and `height`\n             * properties.\n             *\n             * @sample highcharts/members/renderer-on-chart/\n             *         Draw a rectangle based on a text's bounding box\n             */\n            getBBox: function(reload, rot) {\n                var wrapper = this,\n                    bBox, // = wrapper.bBox,\n                    renderer = wrapper.renderer,\n                    width,\n                    height,\n                    rotation,\n                    rad,\n                    element = wrapper.element,\n                    styles = wrapper.styles,\n                    fontSize,\n                    textStr = wrapper.textStr,\n                    toggleTextShadowShim,\n                    cache = renderer.cache,\n                    cacheKeys = renderer.cacheKeys,\n                    cacheKey;\n\n                rotation = pick(rot, wrapper.rotation);\n                rad = rotation * deg2rad;\n\n\n                fontSize = styles && styles.fontSize;\n\n\n                if (textStr !== undefined) {\n\n                    cacheKey = textStr.toString();\n\n                    // Since numbers are monospaced, and numerical labels appear a lot\n                    // in a chart, we assume that a label of n characters has the same\n                    // bounding box as others of the same length. Unless there is inner\n                    // HTML in the label. In that case, leave the numbers as is (#5899).\n                    if (cacheKey.indexOf('<') === -1) {\n                        cacheKey = cacheKey.replace(/[0-9]/g, '0');\n                    }\n\n                    // Properties that affect bounding box\n                    cacheKey += [\n                            '',\n                            rotation || 0,\n                            fontSize,\n                            styles && styles.width,\n                            styles && styles.textOverflow // #5968\n                        ]\n                        .join(',');\n\n                }\n\n                if (cacheKey && !reload) {\n                    bBox = cache[cacheKey];\n                }\n\n                // No cache found\n                if (!bBox) {\n\n                    // SVG elements\n                    if (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {\n                        try { // Fails in Firefox if the container has display: none.\n\n                            // When the text shadow shim is used, we need to hide the fake shadows\n                            // to get the correct bounding box (#3872)\n                            toggleTextShadowShim = this.fakeTS && function(display) {\n                                each(element.querySelectorAll('.highcharts-text-outline'), function(tspan) {\n                                    tspan.style.display = display;\n                                });\n                            };\n\n                            // Workaround for #3842, Firefox reporting wrong bounding box for shadows\n                            if (toggleTextShadowShim) {\n                                toggleTextShadowShim('none');\n                            }\n\n                            bBox = element.getBBox ?\n                                // SVG: use extend because IE9 is not allowed to change width and height in case\n                                // of rotation (below)\n                                extend({}, element.getBBox()) : {\n\n                                    // Legacy IE in export mode\n                                    width: element.offsetWidth,\n                                    height: element.offsetHeight\n                                };\n\n                            // #3842\n                            if (toggleTextShadowShim) {\n                                toggleTextShadowShim('');\n                            }\n                        } catch (e) {}\n\n                        // If the bBox is not set, the try-catch block above failed. The other condition\n                        // is for Opera that returns a width of -Infinity on hidden elements.\n                        if (!bBox || bBox.width < 0) {\n                            bBox = {\n                                width: 0,\n                                height: 0\n                            };\n                        }\n\n\n                        // VML Renderer or useHTML within SVG\n                    } else {\n\n                        bBox = wrapper.htmlGetBBox();\n\n                    }\n\n                    // True SVG elements as well as HTML elements in modern browsers using the .useHTML option\n                    // need to compensated for rotation\n                    if (renderer.isSVG) {\n                        width = bBox.width;\n                        height = bBox.height;\n\n                        // Workaround for wrong bounding box in IE, Edge and Chrome on\n                        // Windows. With Highcharts' default font, IE and Edge report\n                        // a box height of 16.899 and Chrome rounds it to 17. If this \n                        // stands uncorrected, it results in more padding added below\n                        // the text than above when adding a label border or background.\n                        // Also vertical positioning is affected.\n                        // http://jsfiddle.net/highcharts/em37nvuj/\n                        // (#1101, #1505, #1669, #2568, #6213).\n                        if (\n                            styles &&\n                            styles.fontSize === '11px' &&\n                            Math.round(height) === 17\n                        ) {\n                            bBox.height = height = 14;\n                        }\n\n                        // Adjust for rotated text\n                        if (rotation) {\n                            bBox.width = Math.abs(height * Math.sin(rad)) + Math.abs(width * Math.cos(rad));\n                            bBox.height = Math.abs(height * Math.cos(rad)) + Math.abs(width * Math.sin(rad));\n                        }\n                    }\n\n                    // Cache it. When loading a chart in a hidden iframe in Firefox and IE/Edge, the\n                    // bounding box height is 0, so don't cache it (#5620).\n                    if (cacheKey && bBox.height > 0) {\n\n                        // Rotate (#4681)\n                        while (cacheKeys.length > 250) {\n                            delete cache[cacheKeys.shift()];\n                        }\n\n                        if (!cache[cacheKey]) {\n                            cacheKeys.push(cacheKey);\n                        }\n                        cache[cacheKey] = bBox;\n                    }\n                }\n                return bBox;\n            },\n\n            /**\n             * Show the element after it has been hidden. \n             *\n             * @param {boolean} [inherit=false] Set the visibility attribute to\n             * `inherit` rather than `visible`. The difference is that an element with\n             * `visibility=\"visible\"` will be visible even if the parent is hidden.\n             *\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             */\n            show: function(inherit) {\n                return this.attr({\n                    visibility: inherit ? 'inherit' : 'visible'\n                });\n            },\n\n            /**\n             * Hide the element, equivalent to setting the `visibility` attribute to\n             * `hidden`.\n             *\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             */\n            hide: function() {\n                return this.attr({\n                    visibility: 'hidden'\n                });\n            },\n\n            /**\n             * Fade out an element by animating its opacity down to 0, and hide it on\n             * complete. Used internally for the tooltip.\n             * \n             * @param {number} [duration=150] The fade duration in milliseconds.\n             */\n            fadeOut: function(duration) {\n                var elemWrapper = this;\n                elemWrapper.animate({\n                    opacity: 0\n                }, {\n                    duration: duration || 150,\n                    complete: function() {\n                        elemWrapper.attr({\n                            y: -9999\n                        }); // #3088, assuming we're only using this for tooltips\n                    }\n                });\n            },\n\n            /**\n             * Add the element to the DOM. All elements must be added this way.\n             * \n             * @param {Highcharts.SVGElement|SVGDOMElement} [parent] The parent item to add it to.\n             *   If undefined, the element is added to the {@link\n             *   Highcharts.SVGRenderer.box}.\n             *\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             *\n             * @sample highcharts/members/renderer-g - Elements added to a group\n             */\n            add: function(parent) {\n\n                var renderer = this.renderer,\n                    element = this.element,\n                    inserted;\n\n                if (parent) {\n                    this.parentGroup = parent;\n                }\n\n                // mark as inverted\n                this.parentInverted = parent && parent.inverted;\n\n                // build formatted text\n                if (this.textStr !== undefined) {\n                    renderer.buildText(this);\n                }\n\n                // Mark as added\n                this.added = true;\n\n                // If we're adding to renderer root, or other elements in the group\n                // have a z index, we need to handle it\n                if (!parent || parent.handleZ || this.zIndex) {\n                    inserted = this.zIndexSetter();\n                }\n\n                // If zIndex is not handled, append at the end\n                if (!inserted) {\n                    (parent ? parent.element : renderer.box).appendChild(element);\n                }\n\n                // fire an event for internal hooks\n                if (this.onAdd) {\n                    this.onAdd();\n                }\n\n                return this;\n            },\n\n            /**\n             * Removes an element from the DOM.\n             *\n             * @private\n             * @param {SVGDOMElement|HTMLDOMElement} element The DOM node to remove.\n             */\n            safeRemoveChild: function(element) {\n                var parentNode = element.parentNode;\n                if (parentNode) {\n                    parentNode.removeChild(element);\n                }\n            },\n\n            /**\n             * Destroy the element and element wrapper and clear up the DOM and event\n             * hooks.\n             *\n             * @returns {void}\n             */\n            destroy: function() {\n                var wrapper = this,\n                    element = wrapper.element || {},\n                    parentToClean =\n                    wrapper.renderer.isSVG &&\n                    element.nodeName === 'SPAN' &&\n                    wrapper.parentGroup,\n                    grandParent,\n                    ownerSVGElement = element.ownerSVGElement,\n                    i;\n\n                // remove events\n                element.onclick = element.onmouseout = element.onmouseover =\n                    element.onmousemove = element.point = null;\n                stop(wrapper); // stop running animations\n\n                if (wrapper.clipPath && ownerSVGElement) {\n                    // Look for existing references to this clipPath and remove them\n                    // before destroying the element (#6196).\n                    each(\n                        ownerSVGElement.querySelectorAll('[clip-path]'),\n                        function(el) {\n                            // Include the closing paranthesis in the test to rule out\n                            // id's from 10 and above (#6550)\n                            if (el.getAttribute('clip-path')\n                                .indexOf(wrapper.clipPath.element.id + ')') > -1) {\n                                el.removeAttribute('clip-path');\n                            }\n                        }\n                    );\n                    wrapper.clipPath = wrapper.clipPath.destroy();\n                }\n\n                // Destroy stops in case this is a gradient object\n                if (wrapper.stops) {\n                    for (i = 0; i < wrapper.stops.length; i++) {\n                        wrapper.stops[i] = wrapper.stops[i].destroy();\n                    }\n                    wrapper.stops = null;\n                }\n\n                // remove element\n                wrapper.safeRemoveChild(element);\n\n\n                wrapper.destroyShadows();\n\n\n                // In case of useHTML, clean up empty containers emulating SVG groups (#1960, #2393, #2697).\n                while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {\n                    grandParent = parentToClean.parentGroup;\n                    wrapper.safeRemoveChild(parentToClean.div);\n                    delete parentToClean.div;\n                    parentToClean = grandParent;\n                }\n\n                // remove from alignObjects\n                if (wrapper.alignTo) {\n                    erase(wrapper.renderer.alignedObjects, wrapper);\n                }\n\n                objectEach(wrapper, function(val, key) {\n                    delete wrapper[key];\n                });\n\n                return null;\n            },\n\n\n            /**\n             * @typedef {Object} ShadowOptions\n             * @property {string} [color=#000000] The shadow color.\n             * @property {number} [offsetX=1] The horizontal offset from the element.\n             * @property {number} [offsetY=1] The vertical offset from the element.\n             * @property {number} [opacity=0.15] The shadow opacity.\n             * @property {number} [width=3] The shadow width or distance from the\n             *    element.\n             */\n            /**\n             * Add a shadow to the element. Must be called after the element is added to\n             * the DOM. In styled mode, this method is not used, instead use `defs` and\n             * filters.\n             * \n             * @param {boolean|ShadowOptions} shadowOptions The shadow options. If\n             *    `true`, the default options are applied. If `false`, the current\n             *    shadow will be removed.\n             * @param {Highcharts.SVGElement} [group] The SVG group element where the shadows will \n             *    be applied. The default is to add it to the same parent as the current\n             *    element. Internally, this is ised for pie slices, where all the\n             *    shadows are added to an element behind all the slices.\n             * @param {boolean} [cutOff] Used internally for column shadows.\n             *\n             * @returns {Highcharts.SVGElement} Returns the SVGElement for chaining.\n             *\n             * @example\n             * renderer.rect(10, 100, 100, 100)\n             *     .attr({ fill: 'red' })\n             *     .shadow(true);\n             */\n            shadow: function(shadowOptions, group, cutOff) {\n                var shadows = [],\n                    i,\n                    shadow,\n                    element = this.element,\n                    strokeWidth,\n                    shadowWidth,\n                    shadowElementOpacity,\n\n                    // compensate for inverted plot area\n                    transform;\n\n                if (!shadowOptions) {\n                    this.destroyShadows();\n\n                } else if (!this.shadows) {\n                    shadowWidth = pick(shadowOptions.width, 3);\n                    shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n                    transform = this.parentInverted ?\n                        '(-1,-1)' :\n                        '(' + pick(shadowOptions.offsetX, 1) + ', ' + pick(shadowOptions.offsetY, 1) + ')';\n                    for (i = 1; i <= shadowWidth; i++) {\n                        shadow = element.cloneNode(0);\n                        strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n                        attr(shadow, {\n                            'isShadow': 'true',\n                            'stroke': shadowOptions.color || '#000000',\n                            'stroke-opacity': shadowElementOpacity * i,\n                            'stroke-width': strokeWidth,\n                            'transform': 'translate' + transform,\n                            'fill': 'none'\n                        });\n                        if (cutOff) {\n                            attr(shadow, 'height', Math.max(attr(shadow, 'height') - strokeWidth, 0));\n                            shadow.cutHeight = strokeWidth;\n                        }\n\n                        if (group) {\n                            group.element.appendChild(shadow);\n                        } else {\n                            element.parentNode.insertBefore(shadow, element);\n                        }\n\n                        shadows.push(shadow);\n                    }\n\n                    this.shadows = shadows;\n                }\n                return this;\n\n            },\n\n            /**\n             * Destroy shadows on the element.\n             * @private\n             */\n            destroyShadows: function() {\n                each(this.shadows || [], function(shadow) {\n                    this.safeRemoveChild(shadow);\n                }, this);\n                this.shadows = undefined;\n            },\n\n\n\n            xGetter: function(key) {\n                if (this.element.nodeName === 'circle') {\n                    if (key === 'x') {\n                        key = 'cx';\n                    } else if (key === 'y') {\n                        key = 'cy';\n                    }\n                }\n                return this._defaultGetter(key);\n            },\n\n            /**\n             * Get the current value of an attribute or pseudo attribute, used mainly\n             * for animation. Called internally from the {@link\n             * Highcharts.SVGRenderer#attr}\n             * function.\n             *\n             * @private\n             */\n            _defaultGetter: function(key) {\n                var ret = pick(this[key], this.element ? this.element.getAttribute(key) : null, 0);\n\n                if (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n                    ret = parseFloat(ret);\n                }\n                return ret;\n            },\n\n\n            dSetter: function(value, key, element) {\n                if (value && value.join) { // join path\n                    value = value.join(' ');\n                }\n                if (/(NaN| {2}|^$)/.test(value)) {\n                    value = 'M 0 0';\n                }\n                element.setAttribute(key, value);\n\n                this[key] = value;\n            },\n\n            dashstyleSetter: function(value) {\n                var i,\n                    strokeWidth = this['stroke-width'];\n\n                // If \"inherit\", like maps in IE, assume 1 (#4981). With HC5 and the new strokeWidth \n                // function, we should be able to use that instead.\n                if (strokeWidth === 'inherit') {\n                    strokeWidth = 1;\n                }\n                value = value && value.toLowerCase();\n                if (value) {\n                    value = value\n                        .replace('shortdashdotdot', '3,1,1,1,1,1,')\n                        .replace('shortdashdot', '3,1,1,1')\n                        .replace('shortdot', '1,1,')\n                        .replace('shortdash', '3,1,')\n                        .replace('longdash', '8,3,')\n                        .replace(/dot/g, '1,3,')\n                        .replace('dash', '4,3,')\n                        .replace(/,$/, '')\n                        .split(','); // ending comma\n\n                    i = value.length;\n                    while (i--) {\n                        value[i] = pInt(value[i]) * strokeWidth;\n                    }\n                    value = value.join(',')\n                        .replace(/NaN/g, 'none'); // #3226\n                    this.element.setAttribute('stroke-dasharray', value);\n                }\n            },\n\n            alignSetter: function(value) {\n                var convert = {\n                    left: 'start',\n                    center: 'middle',\n                    right: 'end'\n                };\n                this.element.setAttribute('text-anchor', convert[value]);\n            },\n            opacitySetter: function(value, key, element) {\n                this[key] = value;\n                element.setAttribute(key, value);\n            },\n            titleSetter: function(value) {\n                var titleNode = this.element.getElementsByTagName('title')[0];\n                if (!titleNode) {\n                    titleNode = doc.createElementNS(this.SVG_NS, 'title');\n                    this.element.appendChild(titleNode);\n                }\n\n                // Remove text content if it exists\n                if (titleNode.firstChild) {\n                    titleNode.removeChild(titleNode.firstChild);\n                }\n\n                titleNode.appendChild(\n                    doc.createTextNode(\n                        (String(pick(value), '')).replace(/<[^>]*>/g, '') // #3276, #3895\n                    )\n                );\n            },\n            textSetter: function(value) {\n                if (value !== this.textStr) {\n                    // Delete bBox memo when the text changes\n                    delete this.bBox;\n\n                    this.textStr = value;\n                    if (this.added) {\n                        this.renderer.buildText(this);\n                    }\n                }\n            },\n            fillSetter: function(value, key, element) {\n                if (typeof value === 'string') {\n                    element.setAttribute(key, value);\n                } else if (value) {\n                    this.colorGradient(value, key, element);\n                }\n            },\n            visibilitySetter: function(value, key, element) {\n                // IE9-11 doesn't handle visibilty:inherit well, so we remove the attribute instead (#2881, #3909)\n                if (value === 'inherit') {\n                    element.removeAttribute(key);\n                } else {\n                    element.setAttribute(key, value);\n                }\n            },\n            zIndexSetter: function(value, key) {\n                var renderer = this.renderer,\n                    parentGroup = this.parentGroup,\n                    parentWrapper = parentGroup || renderer,\n                    parentNode = parentWrapper.element || renderer.box,\n                    childNodes,\n                    otherElement,\n                    otherZIndex,\n                    element = this.element,\n                    inserted,\n                    run = this.added,\n                    i;\n\n                if (defined(value)) {\n                    element.zIndex = value; // So we can read it for other elements in the group\n                    value = +value;\n                    if (this[key] === value) { // Only update when needed (#3865)\n                        run = false;\n                    }\n                    this[key] = value;\n                }\n\n                // Insert according to this and other elements' zIndex. Before .add() is called,\n                // nothing is done. Then on add, or by later calls to zIndexSetter, the node\n                // is placed on the right place in the DOM.\n                if (run) {\n                    value = this.zIndex;\n\n                    if (value && parentGroup) {\n                        parentGroup.handleZ = true;\n                    }\n\n                    childNodes = parentNode.childNodes;\n                    for (i = 0; i < childNodes.length && !inserted; i++) {\n                        otherElement = childNodes[i];\n                        otherZIndex = otherElement.zIndex;\n                        if (otherElement !== element && (\n                                // Insert before the first element with a higher zIndex\n                                pInt(otherZIndex) > value ||\n                                // If no zIndex given, insert before the first element with a zIndex\n                                (!defined(value) && defined(otherZIndex)) ||\n                                // Negative zIndex versus no zIndex:\n                                // On all levels except the highest. If the parent is <svg>,\n                                // then we don't want to put items before <desc> or <defs>\n                                (value < 0 && !defined(otherZIndex) && parentNode !== renderer.box)\n\n                            )) {\n                            parentNode.insertBefore(element, otherElement);\n                            inserted = true;\n                        }\n                    }\n                    if (!inserted) {\n                        parentNode.appendChild(element);\n                    }\n                }\n                return inserted;\n            },\n            _defaultSetter: function(value, key, element) {\n                element.setAttribute(key, value);\n            }\n        });\n\n        // Some shared setters and getters\n        SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;\n        SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter =\n            SVGElement.prototype.rotationSetter = SVGElement.prototype.verticalAlignSetter =\n            SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = function(value, key) {\n                this[key] = value;\n                this.doTransform = true;\n            };\n\n\n        // WebKit and Batik have problems with a stroke-width of zero, so in this case we remove the \n        // stroke attribute altogether. #1270, #1369, #3065, #3072.\n        SVGElement.prototype['stroke-widthSetter'] = SVGElement.prototype.strokeSetter = function(value, key, element) {\n            this[key] = value;\n            // Only apply the stroke attribute if the stroke width is defined and larger than 0\n            if (this.stroke && this['stroke-width']) {\n                SVGElement.prototype.fillSetter.call(this, this.stroke, 'stroke', element); // use prototype as instance may be overridden\n                element.setAttribute('stroke-width', this['stroke-width']);\n                this.hasStroke = true;\n            } else if (key === 'stroke-width' && value === 0 && this.hasStroke) {\n                element.removeAttribute('stroke');\n                this.hasStroke = false;\n            }\n        };\n\n\n        /**\n         * Allows direct access to the Highcharts rendering layer in order to draw\n         * primitive shapes like circles, rectangles, paths or text directly on a chart,\n         * or independent from any chart. The SVGRenderer represents a wrapper object\n         * for SVGin modern browsers and through the VMLRenderer, for VML in IE < 8.\n         *\n         * An existing chart's renderer can be accessed through {@link Chart#renderer}.\n         * The renderer can also be used completely decoupled from a chart.\n         *\n         * @param {HTMLDOMElement} container - Where to put the SVG in the web page.\n         * @param {number} width - The width of the SVG.\n         * @param {number} height - The height of the SVG.\n         * @param {boolean} [forExport=false] - Whether the rendered content is intended\n         *   for export.\n         * @param {boolean} [allowHTML=true] - Whether the renderer is allowed to\n         *   include HTML text, which will be projected on top of the SVG.\n         *\n         * @example\n         * // Use directly without a chart object.\n         * var renderer = new Highcharts.Renderer(parentNode, 600, 400);\n         *\n         * @sample highcharts/members/renderer-on-chart - Annotating a chart programmatically.\n         * @sample highcharts/members/renderer-basic - Independedt SVG drawing.\n         *\n         * @class Highcharts.SVGRenderer\n         */\n        SVGRenderer = H.SVGRenderer = function() {\n            this.init.apply(this, arguments);\n        };\n        extend(SVGRenderer.prototype, /** @lends Highcharts.SVGRenderer.prototype */ {\n            /**\n             * A pointer to the renderer's associated Element class. The VMLRenderer\n             * will have a pointer to VMLElement here.\n             * @type {Highcharts.SVGElement}\n             */\n            Element: SVGElement,\n            SVG_NS: SVG_NS,\n            /**\n             * Initialize the SVGRenderer. Overridable initiator function that takes\n             * the same parameters as the constructor.\n             */\n            init: function(container, width, height, style, forExport, allowHTML) {\n                var renderer = this,\n                    boxWrapper,\n                    element,\n                    desc;\n\n                boxWrapper = renderer.createElement('svg')\n                    .attr({\n                        'version': '1.1',\n                        'class': 'highcharts-root'\n                    })\n\n                    .css(this.getStyle(style));\n                element = boxWrapper.element;\n                container.appendChild(element);\n\n                // For browsers other than IE, add the namespace attribute (#1978)\n                if (container.innerHTML.indexOf('xmlns') === -1) {\n                    attr(element, 'xmlns', this.SVG_NS);\n                }\n\n                // object properties\n                renderer.isSVG = true;\n\n                /** \n                 * The root `svg` node of the renderer.\n                 * @type {SVGDOMElement}\n                 */\n                this.box = element;\n                /** \n                 * The wrapper for the root `svg` node of the renderer.\n                 * @type {Highcharts.SVGElement}\n                 */\n                this.boxWrapper = boxWrapper;\n                renderer.alignedObjects = [];\n\n                /**\n                 * Page url used for internal references.\n                 * @type {string}\n                 */\n                // #24, #672, #1070\n                this.url = (isFirefox || isWebKit) && doc.getElementsByTagName('base').length ?\n                    win.location.href\n                    .replace(/#.*?$/, '') // remove the hash\n                    .replace(/<[^>]*>/g, '') // wing cut HTML\n                    .replace(/([\\('\\)])/g, '\\\\$1') // escape parantheses and quotes\n                    .replace(/ /g, '%20') : // replace spaces (needed for Safari only)\n                    '';\n\n                // Add description\n                desc = this.createElement('desc').add();\n                desc.element.appendChild(doc.createTextNode('Created with Highcharts 5.0.12'));\n\n\n                renderer.defs = this.createElement('defs').add();\n                renderer.allowHTML = allowHTML;\n                renderer.forExport = forExport;\n                renderer.gradients = {}; // Object where gradient SvgElements are stored\n                renderer.cache = {}; // Cache for numerical bounding boxes\n                renderer.cacheKeys = [];\n                renderer.imgCount = 0;\n\n                renderer.setSize(width, height, false);\n\n\n\n                // Issue 110 workaround:\n                // In Firefox, if a div is positioned by percentage, its pixel position may land\n                // between pixels. The container itself doesn't display this, but an SVG element\n                // inside this container will be drawn at subpixel precision. In order to draw\n                // sharp lines, this must be compensated for. This doesn't seem to work inside\n                // iframes though (like in jsFiddle).\n                var subPixelFix, rect;\n                if (isFirefox && container.getBoundingClientRect) {\n                    subPixelFix = function() {\n                        css(container, {\n                            left: 0,\n                            top: 0\n                        });\n                        rect = container.getBoundingClientRect();\n                        css(container, {\n                            left: (Math.ceil(rect.left) - rect.left) + 'px',\n                            top: (Math.ceil(rect.top) - rect.top) + 'px'\n                        });\n                    };\n\n                    // run the fix now\n                    subPixelFix();\n\n                    // run it on resize\n                    renderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix);\n                }\n            },\n\n\n\n            /**\n             * Get the global style setting for the renderer.\n             * @private\n             * @param  {CSSObject} style - Style settings.\n             * @return {CSSObject} The style settings mixed with defaults.\n             */\n            getStyle: function(style) {\n                this.style = extend({\n\n                    fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif', // default font\n                    fontSize: '12px'\n\n                }, style);\n                return this.style;\n            },\n            /**\n             * Apply the global style on the renderer, mixed with the default styles.\n             * @param {CSSObject} style - CSS to apply.\n             */\n            setStyle: function(style) {\n                this.boxWrapper.css(this.getStyle(style));\n            },\n\n\n            /**\n             * Detect whether the renderer is hidden. This happens when one of the\n             * parent elements has display: none. Used internally to detect when we need\n             * to render preliminarily in another div to get the text bounding boxes \n             * right.\n             *\n             * @returns {boolean} True if it is hidden.\n             */\n            isHidden: function() { // #608\n                return !this.boxWrapper.getBBox().width;\n            },\n\n            /**\n             * Destroys the renderer and its allocated members.\n             */\n            destroy: function() {\n                var renderer = this,\n                    rendererDefs = renderer.defs;\n                renderer.box = null;\n                renderer.boxWrapper = renderer.boxWrapper.destroy();\n\n                // Call destroy on all gradient elements\n                destroyObjectProperties(renderer.gradients || {});\n                renderer.gradients = null;\n\n                // Defs are null in VMLRenderer\n                // Otherwise, destroy them here.\n                if (rendererDefs) {\n                    renderer.defs = rendererDefs.destroy();\n                }\n\n                // Remove sub pixel fix handler (#982)\n                if (renderer.unSubPixelFix) {\n                    renderer.unSubPixelFix();\n                }\n\n                renderer.alignedObjects = null;\n\n                return null;\n            },\n\n            /**\n             * Create a wrapper for an SVG element. Serves as a factory for \n             * {@link SVGElement}, but this function is itself mostly called from \n             * primitive factories like {@link SVGRenderer#path}, {@link\n             * SVGRenderer#rect} or {@link SVGRenderer#text}.\n             * \n             * @param {string} nodeName - The node name, for example `rect`, `g` etc.\n             * @returns {Highcharts.SVGElement} The generated SVGElement.\n             */\n            createElement: function(nodeName) {\n                var wrapper = new this.Element();\n                wrapper.init(this, nodeName);\n                return wrapper;\n            },\n\n            /**\n             * Dummy function for plugins, called every time the renderer is updated.\n             * Prior to Highcharts 5, this was used for the canvg renderer.\n             * @function\n             */\n            draw: noop,\n\n            /**\n             * Get converted radial gradient attributes according to the radial\n             * reference. Used internally from the {@link SVGElement#colorGradient}\n             * function.\n             *\n             * @private\n             */\n            getRadialAttr: function(radialReference, gradAttr) {\n                return {\n                    cx: (radialReference[0] - radialReference[2] / 2) + gradAttr.cx * radialReference[2],\n                    cy: (radialReference[1] - radialReference[2] / 2) + gradAttr.cy * radialReference[2],\n                    r: gradAttr.r * radialReference[2]\n                };\n            },\n\n            getSpanWidth: function(wrapper, tspan) {\n                var renderer = this,\n                    bBox = wrapper.getBBox(true),\n                    actualWidth = bBox.width;\n\n                // Old IE cannot measure the actualWidth for SVG elements (#2314)\n                if (!svg && renderer.forExport) {\n                    actualWidth = renderer.measureSpanWidth(tspan.firstChild.data, wrapper.styles);\n                }\n                return actualWidth;\n            },\n\n            applyEllipsis: function(wrapper, tspan, text, width) {\n                var renderer = this,\n                    actualWidth = renderer.getSpanWidth(wrapper, tspan),\n                    wasTooLong = actualWidth > width,\n                    str = text,\n                    currentIndex,\n                    minIndex = 0,\n                    maxIndex = text.length,\n                    updateTSpan = function(s) {\n                        tspan.removeChild(tspan.firstChild);\n                        if (s) {\n                            tspan.appendChild(doc.createTextNode(s));\n                        }\n                    };\n                if (wasTooLong) {\n                    while (minIndex <= maxIndex) {\n                        currentIndex = Math.ceil((minIndex + maxIndex) / 2);\n                        str = text.substring(0, currentIndex) + '\\u2026';\n                        updateTSpan(str);\n                        actualWidth = renderer.getSpanWidth(wrapper, tspan);\n                        if (minIndex === maxIndex) {\n                            // Complete\n                            minIndex = maxIndex + 1;\n                        } else if (actualWidth > width) {\n                            // Too large. Set max index to current.\n                            maxIndex = currentIndex - 1;\n                        } else {\n                            // Within width. Set min index to current.\n                            minIndex = currentIndex;\n                        }\n                    }\n                    // If max index was 0 it means just ellipsis was also to large.\n                    if (maxIndex === 0) {\n                        // Remove ellipses.\n                        updateTSpan('');\n                    }\n                }\n                return wasTooLong;\n            },\n\n            /**\n             * Parse a simple HTML string into SVG tspans. Called internally when text\n             *   is set on an SVGElement. The function supports a subset of HTML tags,\n             *   CSS text features like `width`, `text-overflow`, `white-space`, and\n             *   also attributes like `href` and `style`.\n             * @private\n             * @param {Highcharts.SVGElement} wrapper The parent SVGElement.\n             */\n            buildText: function(wrapper) {\n                var textNode = wrapper.element,\n                    renderer = this,\n                    forExport = renderer.forExport,\n                    textStr = pick(wrapper.textStr, '').toString(),\n                    hasMarkup = textStr.indexOf('<') !== -1,\n                    lines,\n                    childNodes = textNode.childNodes,\n                    clsRegex,\n                    styleRegex,\n                    hrefRegex,\n                    wasTooLong,\n                    parentX = attr(textNode, 'x'),\n                    textStyles = wrapper.styles,\n                    width = wrapper.textWidth,\n                    textLineHeight = textStyles && textStyles.lineHeight,\n                    textOutline = textStyles && textStyles.textOutline,\n                    ellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n                    noWrap = textStyles && textStyles.whiteSpace === 'nowrap',\n                    fontSize = textStyles && textStyles.fontSize,\n                    textCache,\n                    isSubsequentLine,\n                    i = childNodes.length,\n                    tempParent = width && !wrapper.added && this.box,\n                    getLineHeight = function(tspan) {\n                        var fontSizeStyle;\n\n                        fontSizeStyle = /(px|em)$/.test(tspan && tspan.style.fontSize) ?\n                            tspan.style.fontSize :\n                            (fontSize || renderer.style.fontSize || 12);\n\n\n                        return textLineHeight ?\n                            pInt(textLineHeight) :\n                            renderer.fontMetrics(\n                                fontSizeStyle,\n                                // Get the computed size from parent if not explicit\n                                tspan.getAttribute('style') ? tspan : textNode\n                            ).h;\n                    },\n                    unescapeAngleBrackets = function(inputStr) {\n                        return inputStr.replace(/&lt;/g, '<').replace(/&gt;/g, '>');\n                    };\n\n                // The buildText code is quite heavy, so if we're not changing something\n                // that affects the text, skip it (#6113).\n                textCache = [\n                    textStr,\n                    ellipsis,\n                    noWrap,\n                    textLineHeight,\n                    textOutline,\n                    fontSize,\n                    width\n                ].join(',');\n                if (textCache === wrapper.textCache) {\n                    return;\n                }\n                wrapper.textCache = textCache;\n\n                /// remove old text\n                while (i--) {\n                    textNode.removeChild(childNodes[i]);\n                }\n\n                // Skip tspans, add text directly to text node. The forceTSpan is a hook\n                // used in text outline hack.\n                if (!hasMarkup && !textOutline && !ellipsis && !width && textStr.indexOf(' ') === -1) {\n                    textNode.appendChild(doc.createTextNode(unescapeAngleBrackets(textStr)));\n\n                    // Complex strings, add more logic\n                } else {\n\n                    clsRegex = /<.*class=\"([^\"]+)\".*>/;\n                    styleRegex = /<.*style=\"([^\"]+)\".*>/;\n                    hrefRegex = /<.*href=\"([^\"]+)\".*>/;\n\n                    if (tempParent) {\n                        tempParent.appendChild(textNode); // attach it to the DOM to read offset width\n                    }\n\n                    if (hasMarkup) {\n                        lines = textStr\n\n                            .replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">')\n                            .replace(/<(i|em)>/g, '<span style=\"font-style:italic\">')\n\n                            .replace(/<a/g, '<span')\n                            .replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n                            .split(/<br.*?>/g);\n\n                    } else {\n                        lines = [textStr];\n                    }\n\n\n                    // Trim empty lines (#5261)\n                    lines = grep(lines, function(line) {\n                        return line !== '';\n                    });\n\n\n                    // build the lines\n                    each(lines, function buildTextLines(line, lineNo) {\n                        var spans,\n                            spanNo = 0;\n                        line = line\n                            .replace(/^\\s+|\\s+$/g, '') // Trim to prevent useless/costly process on the spaces (#5258)\n                            .replace(/<span/g, '|||<span')\n                            .replace(/<\\/span>/g, '</span>|||');\n                        spans = line.split('|||');\n\n                        each(spans, function buildTextSpans(span) {\n                            if (span !== '' || spans.length === 1) {\n                                var attributes = {},\n                                    tspan = doc.createElementNS(renderer.SVG_NS, 'tspan'),\n                                    spanCls,\n                                    spanStyle; // #390\n                                if (clsRegex.test(span)) {\n                                    spanCls = span.match(clsRegex)[1];\n                                    attr(tspan, 'class', spanCls);\n                                }\n                                if (styleRegex.test(span)) {\n                                    spanStyle = span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2');\n                                    attr(tspan, 'style', spanStyle);\n                                }\n                                if (hrefRegex.test(span) && !forExport) { // Not for export - #1529\n                                    attr(tspan, 'onclick', 'location.href=\\\"' + span.match(hrefRegex)[1] + '\\\"');\n                                    css(tspan, {\n                                        cursor: 'pointer'\n                                    });\n                                }\n\n                                span = unescapeAngleBrackets(span.replace(/<(.|\\n)*?>/g, '') || ' ');\n\n                                // Nested tags aren't supported, and cause crash in Safari (#1596)\n                                if (span !== ' ') {\n\n                                    // add the text node\n                                    tspan.appendChild(doc.createTextNode(span));\n\n                                    if (!spanNo) { // first span in a line, align it to the left\n                                        if (lineNo && parentX !== null) {\n                                            attributes.x = parentX;\n                                        }\n                                    } else {\n                                        attributes.dx = 0; // #16\n                                    }\n\n                                    // add attributes\n                                    attr(tspan, attributes);\n\n                                    // Append it\n                                    textNode.appendChild(tspan);\n\n                                    // first span on subsequent line, add the line height\n                                    if (!spanNo && isSubsequentLine) {\n\n                                        // allow getting the right offset height in exporting in IE\n                                        if (!svg && forExport) {\n                                            css(tspan, {\n                                                display: 'block'\n                                            });\n                                        }\n\n                                        // Set the line height based on the font size of either\n                                        // the text element or the tspan element\n                                        attr(\n                                            tspan,\n                                            'dy',\n                                            getLineHeight(tspan)\n                                        );\n                                    }\n\n                                    /*if (width) {\n                                    \trenderer.breakText(wrapper, width);\n                                    }*/\n\n                                    // Check width and apply soft breaks or ellipsis\n                                    if (width) {\n                                        var words = span.replace(/([^\\^])-/g, '$1- ').split(' '), // #1273\n                                            hasWhiteSpace = spans.length > 1 || lineNo || (words.length > 1 && !noWrap),\n                                            tooLong,\n                                            rest = [],\n                                            actualWidth,\n                                            dy = getLineHeight(tspan),\n                                            rotation = wrapper.rotation;\n\n                                        if (ellipsis) {\n                                            wasTooLong = renderer.applyEllipsis(wrapper, tspan, span, width);\n                                        }\n\n                                        while (!ellipsis && hasWhiteSpace && (words.length || rest.length)) {\n                                            wrapper.rotation = 0; // discard rotation when computing box\n                                            actualWidth = renderer.getSpanWidth(wrapper, tspan);\n                                            tooLong = actualWidth > width;\n\n                                            // For ellipsis, do a binary search for the correct string length\n                                            if (wasTooLong === undefined) {\n                                                wasTooLong = tooLong; // First time\n                                            }\n\n                                            // Looping down, this is the first word sequence that is not too long,\n                                            // so we can move on to build the next line.\n                                            if (!tooLong || words.length === 1) {\n                                                words = rest;\n                                                rest = [];\n\n                                                if (words.length && !noWrap) {\n                                                    tspan = doc.createElementNS(SVG_NS, 'tspan');\n                                                    attr(tspan, {\n                                                        dy: dy,\n                                                        x: parentX\n                                                    });\n                                                    if (spanStyle) { // #390\n                                                        attr(tspan, 'style', spanStyle);\n                                                    }\n                                                    textNode.appendChild(tspan);\n                                                }\n                                                if (actualWidth > width) { // a single word is pressing it out\n                                                    width = actualWidth;\n                                                }\n                                            } else { // append to existing line tspan\n                                                tspan.removeChild(tspan.firstChild);\n                                                rest.unshift(words.pop());\n                                            }\n                                            if (words.length) {\n                                                tspan.appendChild(doc.createTextNode(words.join(' ').replace(/- /g, '-')));\n                                            }\n                                        }\n                                        wrapper.rotation = rotation;\n                                    }\n\n                                    spanNo++;\n                                }\n                            }\n                        });\n                        // To avoid beginning lines that doesn't add to the textNode (#6144)\n                        isSubsequentLine = isSubsequentLine || textNode.childNodes.length;\n                    });\n\n                    if (wasTooLong) {\n                        wrapper.attr('title', wrapper.textStr);\n                    }\n                    if (tempParent) {\n                        tempParent.removeChild(textNode); // attach it to the DOM to read offset width\n                    }\n\n                    // Apply the text outline\n                    if (textOutline && wrapper.applyTextOutline) {\n                        wrapper.applyTextOutline(textOutline);\n                    }\n                }\n            },\n\n\n\n            /*\n            breakText: function (wrapper, width) {\n            \tvar bBox = wrapper.getBBox(),\n            \t\tnode = wrapper.element,\n            \t\ttextLength = node.textContent.length,\n            \t\tpos = Math.round(width * textLength / bBox.width), // try this position first, based on average character width\n            \t\tincrement = 0,\n            \t\tfinalPos;\n\n            \tif (bBox.width > width) {\n            \t\twhile (finalPos === undefined) {\n            \t\t\ttextLength = node.getSubStringLength(0, pos);\n\n            \t\t\tif (textLength <= width) {\n            \t\t\t\tif (increment === -1) {\n            \t\t\t\t\tfinalPos = pos;\n            \t\t\t\t} else {\n            \t\t\t\t\tincrement = 1;\n            \t\t\t\t}\n            \t\t\t} else {\n            \t\t\t\tif (increment === 1) {\n            \t\t\t\t\tfinalPos = pos - 1;\n            \t\t\t\t} else {\n            \t\t\t\t\tincrement = -1;\n            \t\t\t\t}\n            \t\t\t}\n            \t\t\tpos += increment;\n            \t\t}\n            \t}\n            \tconsole.log('width', width, 'stringWidth', node.getSubStringLength(0, finalPos))\n            },\n            */\n\n            /**\n             * Returns white for dark colors and black for bright colors.\n             *\n             * @param {ColorString} rgba - The color to get the contrast for.\n             * @returns {string} The contrast color, either `#000000` or `#FFFFFF`.\n             */\n            getContrast: function(rgba) {\n                rgba = color(rgba).rgba;\n\n                // The threshold may be discussed. Here's a proposal for adding\n                // different weight to the color channels (#6216)\n                /*\n        rgba[0] *= 1; // red\n        rgba[1] *= 1.2; // green\n        rgba[2] *= 0.7; // blue\n        */\n\n                return rgba[0] + rgba[1] + rgba[2] > 2 * 255 ? '#000000' : '#FFFFFF';\n            },\n\n            /**\n             * Create a button with preset states.\n             * @param {string} text - The text or HTML to draw.\n             * @param {number} x - The x position of the button's left side.\n             * @param {number} y - The y position of the button's top side.\n             * @param {Function} callback - The function to execute on button click or \n             *    touch.\n             * @param {SVGAttributes} [normalState] - SVG attributes for the normal\n             *    state.\n             * @param {SVGAttributes} [hoverState] - SVG attributes for the hover state.\n             * @param {SVGAttributes} [pressedState] - SVG attributes for the pressed\n             *    state.\n             * @param {SVGAttributes} [disabledState] - SVG attributes for the disabled\n             *    state.\n             * @param {Symbol} [shape=rect] - The shape type.\n             * @returns {SVGRenderer} The button element.\n             */\n            button: function(text, x, y, callback, normalState, hoverState, pressedState, disabledState, shape) {\n                var label = this.label(text, x, y, shape, null, null, null, null, 'button'),\n                    curState = 0;\n\n                // Default, non-stylable attributes\n                label.attr(merge({\n                    'padding': 8,\n                    'r': 2\n                }, normalState));\n\n\n                // Presentational\n                var normalStyle,\n                    hoverStyle,\n                    pressedStyle,\n                    disabledStyle;\n\n                // Normal state - prepare the attributes\n                normalState = merge({\n                    fill: '#f7f7f7',\n                    stroke: '#cccccc',\n                    'stroke-width': 1,\n                    style: {\n                        color: '#333333',\n                        cursor: 'pointer',\n                        fontWeight: 'normal'\n                    }\n                }, normalState);\n                normalStyle = normalState.style;\n                delete normalState.style;\n\n                // Hover state\n                hoverState = merge(normalState, {\n                    fill: '#e6e6e6'\n                }, hoverState);\n                hoverStyle = hoverState.style;\n                delete hoverState.style;\n\n                // Pressed state\n                pressedState = merge(normalState, {\n                    fill: '#e6ebf5',\n                    style: {\n                        color: '#000000',\n                        fontWeight: 'bold'\n                    }\n                }, pressedState);\n                pressedStyle = pressedState.style;\n                delete pressedState.style;\n\n                // Disabled state\n                disabledState = merge(normalState, {\n                    style: {\n                        color: '#cccccc'\n                    }\n                }, disabledState);\n                disabledStyle = disabledState.style;\n                delete disabledState.style;\n\n\n                // Add the events. IE9 and IE10 need mouseover and mouseout to funciton (#667).\n                addEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function() {\n                    if (curState !== 3) {\n                        label.setState(1);\n                    }\n                });\n                addEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function() {\n                    if (curState !== 3) {\n                        label.setState(curState);\n                    }\n                });\n\n                label.setState = function(state) {\n                    // Hover state is temporary, don't record it\n                    if (state !== 1) {\n                        label.state = curState = state;\n                    }\n                    // Update visuals\n                    label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/)\n                        .addClass('highcharts-button-' + ['normal', 'hover', 'pressed', 'disabled'][state || 0]);\n\n\n                    label.attr([normalState, hoverState, pressedState, disabledState][state || 0])\n                        .css([normalStyle, hoverStyle, pressedStyle, disabledStyle][state || 0]);\n\n                };\n\n\n\n                // Presentational attributes\n                label\n                    .attr(normalState)\n                    .css(extend({\n                        cursor: 'default'\n                    }, normalStyle));\n\n\n                return label\n                    .on('click', function(e) {\n                        if (curState !== 3) {\n                            callback.call(label, e);\n                        }\n                    });\n            },\n\n            /**\n             * Make a straight line crisper by not spilling out to neighbour pixels.\n             * \n             * @param {Array} points - The original points on the format `['M', 0, 0,\n             *    'L', 100, 0]`.\n             * @param {number} width - The width of the line.\n             * @returns {Array} The original points array, but modified to render\n             * crisply.\n             */\n            crispLine: function(points, width) {\n                // normalize to a crisp line\n                if (points[1] === points[4]) {\n                    // Substract due to #1129. Now bottom and left axis gridlines behave the same.\n                    points[1] = points[4] = Math.round(points[1]) - (width % 2 / 2);\n                }\n                if (points[2] === points[5]) {\n                    points[2] = points[5] = Math.round(points[2]) + (width % 2 / 2);\n                }\n                return points;\n            },\n\n\n            /**\n             * Draw a path, wraps the SVG `path` element.\n             * \n             * @param {Array} [path] An SVG path definition in array form.\n             * \n             * @example\n             * var path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])\n             *     .attr({ stroke: '#ff00ff' })\n             *     .add();\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             *\n             * @sample highcharts/members/renderer-path-on-chart/\n             *         Draw a path in a chart\n             * @sample highcharts/members/renderer-path/\n             *         Draw a path independent from a chart\n             *\n             */\n            /**\n             * Draw a path, wraps the SVG `path` element.\n             * \n             * @param {SVGAttributes} [attribs] The initial attributes.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             */\n            path: function(path) {\n                var attribs = {\n\n                    fill: 'none'\n\n                };\n                if (isArray(path)) {\n                    attribs.d = path;\n                } else if (isObject(path)) { // attributes\n                    extend(attribs, path);\n                }\n                return this.createElement('path').attr(attribs);\n            },\n\n            /**\n             * Draw a circle, wraps the SVG `circle` element.\n             * \n             * @param {number} [x] The center x position.\n             * @param {number} [y] The center y position.\n             * @param {number} [r] The radius.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             *\n             * @sample highcharts/members/renderer-circle/ Drawing a circle\n             */\n            /**\n             * Draw a circle, wraps the SVG `circle` element.\n             * \n             * @param {SVGAttributes} [attribs] The initial attributes.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             */\n            circle: function(x, y, r) {\n                var attribs = isObject(x) ? x : {\n                        x: x,\n                        y: y,\n                        r: r\n                    },\n                    wrapper = this.createElement('circle');\n\n                // Setting x or y translates to cx and cy\n                wrapper.xSetter = wrapper.ySetter = function(value, key, element) {\n                    element.setAttribute('c' + key, value);\n                };\n\n                return wrapper.attr(attribs);\n            },\n\n            /**\n             * Draw and return an arc.\n             * @param {number} [x=0] Center X position.\n             * @param {number} [y=0] Center Y position.\n             * @param {number} [r=0] The outer radius of the arc.\n             * @param {number} [innerR=0] Inner radius like used in donut charts.\n             * @param {number} [start=0] The starting angle of the arc in radians, where\n             *    0 is to the right and `-Math.PI/2` is up.\n             * @param {number} [end=0] The ending angle of the arc in radians, where 0\n             *    is to the right and `-Math.PI/2` is up.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             *\n             * @sample highcharts/members/renderer-arc/\n             *         Drawing an arc\n             */\n            /**\n             * Draw and return an arc. Overloaded function that takes arguments object.\n             * @param {SVGAttributes} attribs Initial SVG attributes.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             */\n            arc: function(x, y, r, innerR, start, end) {\n                var arc,\n                    options;\n\n                if (isObject(x)) {\n                    options = x;\n                    y = options.y;\n                    r = options.r;\n                    innerR = options.innerR;\n                    start = options.start;\n                    end = options.end;\n                    x = options.x;\n                } else {\n                    options = {\n                        innerR: innerR,\n                        start: start,\n                        end: end\n                    };\n                }\n\n                // Arcs are defined as symbols for the ability to set\n                // attributes in attr and animate\n                arc = this.symbol('arc', x, y, r, r, options);\n                arc.r = r; // #959\n                return arc;\n            },\n\n            /**\n             * Draw and return a rectangle.\n             * @param {number} [x] Left position.\n             * @param {number} [y] Top position.\n             * @param {number} [width] Width of the rectangle.\n             * @param {number} [height] Height of the rectangle.\n             * @param {number} [r] Border corner radius.\n             * @param {number} [strokeWidth] A stroke width can be supplied to allow\n             *    crisp drawing.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             */\n            /**\n             * Draw and return a rectangle.\n             * @param  {SVGAttributes} [attributes]\n             *         General SVG attributes for the rectangle.\n             * @return {Highcharts.SVGElement}\n             *         The generated wrapper element.\n             *\n             * @sample highcharts/members/renderer-rect-on-chart/\n             *         Draw a rectangle in a chart\n             * @sample highcharts/members/renderer-rect/\n             *         Draw a rectangle independent from a chart\n             */\n            rect: function(x, y, width, height, r, strokeWidth) {\n\n                r = isObject(x) ? x.r : r;\n\n                var wrapper = this.createElement('rect'),\n                    attribs = isObject(x) ? x : x === undefined ? {} : {\n                        x: x,\n                        y: y,\n                        width: Math.max(width, 0),\n                        height: Math.max(height, 0)\n                    };\n\n\n                if (strokeWidth !== undefined) {\n                    attribs.strokeWidth = strokeWidth;\n                    attribs = wrapper.crisp(attribs);\n                }\n                attribs.fill = 'none';\n\n\n                if (r) {\n                    attribs.r = r;\n                }\n\n                wrapper.rSetter = function(value, key, element) {\n                    attr(element, {\n                        rx: value,\n                        ry: value\n                    });\n                };\n\n                return wrapper.attr(attribs);\n            },\n\n            /**\n             * Resize the {@link SVGRenderer#box} and re-align all aligned child\n             * elements.\n             * @param {number} width The new pixel width.\n             * @param {number} height The new pixel height.\n             * @param {boolean} animate Whether to animate.\n             */\n            setSize: function(width, height, animate) {\n                var renderer = this,\n                    alignedObjects = renderer.alignedObjects,\n                    i = alignedObjects.length;\n\n                renderer.width = width;\n                renderer.height = height;\n\n                renderer.boxWrapper.animate({\n                    width: width,\n                    height: height\n                }, {\n                    step: function() {\n                        this.attr({\n                            viewBox: '0 0 ' + this.attr('width') + ' ' + this.attr('height')\n                        });\n                    },\n                    duration: pick(animate, true) ? undefined : 0\n                });\n\n                while (i--) {\n                    alignedObjects[i].align();\n                }\n            },\n\n            /**\n             * Create and return an svg group element. Child {@link Highcharts.SVGElement}\n             * objects are added to the group by using the group as the first parameter\n             * in {@link Highcharts.SVGElement#add|add()}.\n             * \n             * @param {string} [name] The group will be given a class name of\n             * `highcharts-{name}`. This can be used for styling and scripting.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             *\n             * @sample highcharts/members/renderer-g/\n             *         Show and hide grouped objects\n             */\n            g: function(name) {\n                var elem = this.createElement('g');\n                return name ? elem.attr({\n                    'class': 'highcharts-' + name\n                }) : elem;\n            },\n\n            /**\n             * Display an image.\n             * @param {string} src The image source.\n             * @param {number} [x] The X position.\n             * @param {number} [y] The Y position.\n             * @param {number} [width] The image width. If omitted, it defaults to the \n             *    image file width.\n             * @param {number} [height] The image height. If omitted it defaults to the\n             *    image file height.\n             * @returns {Highcharts.SVGElement} The generated wrapper element.\n             *\n             * @sample highcharts/members/renderer-image-on-chart/\n             *         Add an image in a chart\n             * @sample highcharts/members/renderer-image/\n             *         Add an image independent of a chart\n             */\n            image: function(src, x, y, width, height) {\n                var attribs = {\n                        preserveAspectRatio: 'none'\n                    },\n                    elemWrapper;\n\n                // optional properties\n                if (arguments.length > 1) {\n                    extend(attribs, {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    });\n                }\n\n                elemWrapper = this.createElement('image').attr(attribs);\n\n                // set the href in the xlink namespace\n                if (elemWrapper.element.setAttributeNS) {\n                    elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',\n                        'href', src);\n                } else {\n                    // could be exporting in IE\n                    // using href throws \"not supported\" in ie7 and under, requries regex shim to fix later\n                    elemWrapper.element.setAttribute('hc-svg-href', src);\n                }\n                return elemWrapper;\n            },\n\n            /**\n             * Draw a symbol out of pre-defined shape paths from {@SVGRenderer#symbols}.\n             * It is used in Highcharts for point makers, which cake a `symbol` option,\n             * and label and button backgrounds like in the tooltip and stock flags.\n             *\n             * @param {Symbol} symbol - The symbol name.\n             * @param {number} x - The X coordinate for the top left position.\n             * @param {number} y - The Y coordinate for the top left position.\n             * @param {number} width - The pixel width.\n             * @param {number} height - The pixel height.\n             * @param {Object} [options] - Additional options, depending on the actual\n             *    symbol drawn. \n             * @param {number} [options.anchorX] - The anchor X position for the\n             *    `callout` symbol. This is where the chevron points to.\n             * @param {number} [options.anchorY] - The anchor Y position for the\n             *    `callout` symbol. This is where the chevron points to.\n             * @param {number} [options.end] - The end angle of an `arc` symbol.\n             * @param {boolean} [options.open] - Whether to draw `arc` symbol open or\n             *    closed.\n             * @param {number} [options.r] - The radius of an `arc` symbol, or the\n             *    border radius for the `callout` symbol.\n             * @param {number} [options.start] - The start angle of an `arc` symbol.\n             */\n            symbol: function(symbol, x, y, width, height, options) {\n\n                var ren = this,\n                    obj,\n                    imageRegex = /^url\\((.*?)\\)$/,\n                    isImage = imageRegex.test(symbol),\n                    sym = !isImage && (this.symbols[symbol] ? symbol : 'circle'),\n\n\n                    // get the symbol definition function\n                    symbolFn = sym && this.symbols[sym],\n\n                    // check if there's a path defined for this symbol\n                    path = defined(x) && symbolFn && symbolFn.call(\n                        this.symbols,\n                        Math.round(x),\n                        Math.round(y),\n                        width,\n                        height,\n                        options\n                    ),\n                    imageSrc,\n                    centerImage;\n\n                if (symbolFn) {\n                    obj = this.path(path);\n\n\n                    obj.attr('fill', 'none');\n\n\n                    // expando properties for use in animate and attr\n                    extend(obj, {\n                        symbolName: sym,\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    });\n                    if (options) {\n                        extend(obj, options);\n                    }\n\n\n                    // Image symbols\n                } else if (isImage) {\n\n\n                    imageSrc = symbol.match(imageRegex)[1];\n\n                    // Create the image synchronously, add attribs async\n                    obj = this.image(imageSrc);\n\n                    // The image width is not always the same as the symbol width. The\n                    // image may be centered within the symbol, as is the case when\n                    // image shapes are used as label backgrounds, for example in flags.\n                    obj.imgwidth = pick(\n                        symbolSizes[imageSrc] && symbolSizes[imageSrc].width,\n                        options && options.width\n                    );\n                    obj.imgheight = pick(\n                        symbolSizes[imageSrc] && symbolSizes[imageSrc].height,\n                        options && options.height\n                    );\n                    /**\n                     * Set the size and position\n                     */\n                    centerImage = function() {\n                        obj.attr({\n                            width: obj.width,\n                            height: obj.height\n                        });\n                    };\n\n                    /**\n                     * Width and height setters that take both the image's physical size\n                     * and the label size into consideration, and translates the image\n                     * to center within the label.\n                     */\n                    each(['width', 'height'], function(key) {\n                        obj[key + 'Setter'] = function(value, key) {\n                            var attribs = {},\n                                imgSize = this['img' + key],\n                                trans = key === 'width' ? 'translateX' : 'translateY';\n                            this[key] = value;\n                            if (defined(imgSize)) {\n                                if (this.element) {\n                                    this.element.setAttribute(key, imgSize);\n                                }\n                                if (!this.alignByTranslate) {\n                                    attribs[trans] = ((this[key] || 0) - imgSize) / 2;\n                                    this.attr(attribs);\n                                }\n                            }\n                        };\n                    });\n\n\n                    if (defined(x)) {\n                        obj.attr({\n                            x: x,\n                            y: y\n                        });\n                    }\n                    obj.isImg = true;\n\n                    if (defined(obj.imgwidth) && defined(obj.imgheight)) {\n                        centerImage();\n                    } else {\n                        // Initialize image to be 0 size so export will still function if there's no cached sizes.\n                        obj.attr({\n                            width: 0,\n                            height: 0\n                        });\n\n                        // Create a dummy JavaScript image to get the width and height. Due to a bug in IE < 8,\n                        // the created element must be assigned to a variable in order to load (#292).\n                        createElement('img', {\n                            onload: function() {\n\n                                var chart = charts[ren.chartIndex];\n\n                                // Special case for SVGs on IE11, the width is not accessible until the image is\n                                // part of the DOM (#2854).\n                                if (this.width === 0) {\n                                    css(this, {\n                                        position: 'absolute',\n                                        top: '-999em'\n                                    });\n                                    doc.body.appendChild(this);\n                                }\n\n                                // Center the image\n                                symbolSizes[imageSrc] = { // Cache for next\t\n                                    width: this.width,\n                                    height: this.height\n                                };\n                                obj.imgwidth = this.width;\n                                obj.imgheight = this.height;\n\n                                if (obj.element) {\n                                    centerImage();\n                                }\n\n                                // Clean up after #2854 workaround.\n                                if (this.parentNode) {\n                                    this.parentNode.removeChild(this);\n                                }\n\n                                // Fire the load event when all external images are loaded\n                                ren.imgCount--;\n                                if (!ren.imgCount && chart && chart.onload) {\n                                    chart.onload();\n                                }\n                            },\n                            src: imageSrc\n                        });\n                        this.imgCount++;\n                    }\n                }\n\n                return obj;\n            },\n\n            /**\n             * @typedef {string} Symbol\n             * \n             * Can be one of `arc`, `callout`, `circle`, `diamond`, `square`,\n             * `triangle`, `triangle-down`. Symbols are used internally for point\n             * markers, button and label borders and backgrounds, or custom shapes.\n             * Extendable by adding to {@link SVGRenderer#symbols}.\n             */\n            /**\n             * An extendable collection of functions for defining symbol paths.\n             */\n            symbols: {\n                'circle': function(x, y, w, h) {\n                    // Return a full arc\n                    return this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {\n                        start: 0,\n                        end: Math.PI * 2,\n                        open: false\n                    });\n                },\n\n                'square': function(x, y, w, h) {\n                    return [\n                        'M', x, y,\n                        'L', x + w, y,\n                        x + w, y + h,\n                        x, y + h,\n                        'Z'\n                    ];\n                },\n\n                'triangle': function(x, y, w, h) {\n                    return [\n                        'M', x + w / 2, y,\n                        'L', x + w, y + h,\n                        x, y + h,\n                        'Z'\n                    ];\n                },\n\n                'triangle-down': function(x, y, w, h) {\n                    return [\n                        'M', x, y,\n                        'L', x + w, y,\n                        x + w / 2, y + h,\n                        'Z'\n                    ];\n                },\n                'diamond': function(x, y, w, h) {\n                    return [\n                        'M', x + w / 2, y,\n                        'L', x + w, y + h / 2,\n                        x + w / 2, y + h,\n                        x, y + h / 2,\n                        'Z'\n                    ];\n                },\n                'arc': function(x, y, w, h, options) {\n                    var start = options.start,\n                        rx = options.r || w,\n                        ry = options.r || h || w,\n                        end = options.end - 0.001, // to prevent cos and sin of start and end from becoming equal on 360 arcs (related: #1561)\n                        innerRadius = options.innerR,\n                        open = options.open,\n                        cosStart = Math.cos(start),\n                        sinStart = Math.sin(start),\n                        cosEnd = Math.cos(end),\n                        sinEnd = Math.sin(end),\n                        longArc = options.end - start < Math.PI ? 0 : 1,\n                        arc;\n\n                    arc = [\n                        'M',\n                        x + rx * cosStart,\n                        y + ry * sinStart,\n                        'A', // arcTo\n                        rx, // x radius\n                        ry, // y radius\n                        0, // slanting\n                        longArc, // long or short arc\n                        1, // clockwise\n                        x + rx * cosEnd,\n                        y + ry * sinEnd\n                    ];\n\n                    if (defined(innerRadius)) {\n                        arc.push(\n                            open ? 'M' : 'L',\n                            x + innerRadius * cosEnd,\n                            y + innerRadius * sinEnd,\n                            'A', // arcTo\n                            innerRadius, // x radius\n                            innerRadius, // y radius\n                            0, // slanting\n                            longArc, // long or short arc\n                            0, // clockwise\n                            x + innerRadius * cosStart,\n                            y + innerRadius * sinStart\n                        );\n                    }\n\n                    arc.push(open ? '' : 'Z'); // close\n                    return arc;\n                },\n\n                /**\n                 * Callout shape used for default tooltips, also used for rounded rectangles in VML\n                 */\n                callout: function(x, y, w, h, options) {\n                    var arrowLength = 6,\n                        halfDistance = 6,\n                        r = Math.min((options && options.r) || 0, w, h),\n                        safeDistance = r + halfDistance,\n                        anchorX = options && options.anchorX,\n                        anchorY = options && options.anchorY,\n                        path;\n\n                    path = [\n                        'M', x + r, y,\n                        'L', x + w - r, y, // top side\n                        'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n                        'L', x + w, y + h - r, // right side\n                        'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-right corner\n                        'L', x + r, y + h, // bottom side\n                        'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n                        'L', x, y + r, // left side\n                        'C', x, y, x, y, x + r, y // top-left corner\n                    ];\n\n                    // Anchor on right side\n                    if (anchorX && anchorX > w) {\n\n                        // Chevron\n                        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {\n                            path.splice(13, 3,\n                                'L', x + w, anchorY - halfDistance,\n                                x + w + arrowLength, anchorY,\n                                x + w, anchorY + halfDistance,\n                                x + w, y + h - r\n                            );\n\n                            // Simple connector\n                        } else {\n                            path.splice(13, 3,\n                                'L', x + w, h / 2,\n                                anchorX, anchorY,\n                                x + w, h / 2,\n                                x + w, y + h - r\n                            );\n                        }\n\n                        // Anchor on left side\n                    } else if (anchorX && anchorX < 0) {\n\n                        // Chevron\n                        if (anchorY > y + safeDistance && anchorY < y + h - safeDistance) {\n                            path.splice(33, 3,\n                                'L', x, anchorY + halfDistance,\n                                x - arrowLength, anchorY,\n                                x, anchorY - halfDistance,\n                                x, y + r\n                            );\n\n                            // Simple connector\n                        } else {\n                            path.splice(33, 3,\n                                'L', x, h / 2,\n                                anchorX, anchorY,\n                                x, h / 2,\n                                x, y + r\n                            );\n                        }\n\n                    } else if (anchorY && anchorY > h && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace bottom\n                        path.splice(23, 3,\n                            'L', anchorX + halfDistance, y + h,\n                            anchorX, y + h + arrowLength,\n                            anchorX - halfDistance, y + h,\n                            x + r, y + h\n                        );\n                    } else if (anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance) { // replace top\n                        path.splice(3, 3,\n                            'L', anchorX - halfDistance, y,\n                            anchorX, y - arrowLength,\n                            anchorX + halfDistance, y,\n                            w - r, y\n                        );\n                    }\n\n                    return path;\n                }\n            },\n\n            /**\n             * @typedef {Highcharts.SVGElement} ClipRect - A clipping rectangle that can be applied\n             * to one or more {@link SVGElement} instances. It is instanciated with the\n             * {@link SVGRenderer#clipRect} function and applied with the {@link \n             * SVGElement#clip} function.\n             *\n             * @example\n             * var circle = renderer.circle(100, 100, 100)\n             *     .attr({ fill: 'red' })\n             *     .add();\n             * var clipRect = renderer.clipRect(100, 100, 100, 100);\n             *\n             * // Leave only the lower right quarter visible\n             * circle.clip(clipRect);\n             */\n            /**\n             * Define a clipping rectangle\n             * @param {String} id\n             * @param {number} x\n             * @param {number} y\n             * @param {number} width\n             * @param {number} height\n             * @returns {ClipRect} A clipping rectangle.\n             */\n            clipRect: function(x, y, width, height) {\n                var wrapper,\n                    id = H.uniqueKey(),\n\n                    clipPath = this.createElement('clipPath').attr({\n                        id: id\n                    }).add(this.defs);\n\n                wrapper = this.rect(x, y, width, height, 0).add(clipPath);\n                wrapper.id = id;\n                wrapper.clipPath = clipPath;\n                wrapper.count = 0;\n\n                return wrapper;\n            },\n\n\n\n\n\n            /**\n             * Draw text. The text can contain a subset of HTML, like spans and anchors\n             * and some basic text styling of these. For more advanced features like\n             * border and background, use {@link Highcharts.SVGRenderer#label} instead.\n             * To update the text after render, run `text.attr({ text: 'New text' })`.\n             * @param  {String} str\n             *         The text of (subset) HTML to draw.\n             * @param  {number} x\n             *         The x position of the text's lower left corner.\n             * @param  {number} y\n             *         The y position of the text's lower left corner.\n             * @param  {Boolean} [useHTML=false]\n             *         Use HTML to render the text.\n             *\n             * @return {Highcharts.SVGElement} The text object.\n             *\n             * @sample highcharts/members/renderer-text-on-chart/\n             *         Annotate the chart freely\n             * @sample highcharts/members/renderer-on-chart/\n             *         Annotate with a border and in response to the data\n             * @sample highcharts/members/renderer-text/\n             *         Formatted text\n             */\n            text: function(str, x, y, useHTML) {\n\n                // declare variables\n                var renderer = this,\n                    fakeSVG = !svg && renderer.forExport,\n                    wrapper,\n                    attribs = {};\n\n                if (useHTML && (renderer.allowHTML || !renderer.forExport)) {\n                    return renderer.html(str, x, y);\n                }\n\n                attribs.x = Math.round(x || 0); // X is always needed for line-wrap logic\n                if (y) {\n                    attribs.y = Math.round(y);\n                }\n                if (str || str === 0) {\n                    attribs.text = str;\n                }\n\n                wrapper = renderer.createElement('text')\n                    .attr(attribs);\n\n                // Prevent wrapping from creating false offsetWidths in export in legacy IE (#1079, #1063)\n                if (fakeSVG) {\n                    wrapper.css({\n                        position: 'absolute'\n                    });\n                }\n\n                if (!useHTML) {\n                    wrapper.xSetter = function(value, key, element) {\n                        var tspans = element.getElementsByTagName('tspan'),\n                            tspan,\n                            parentVal = element.getAttribute(key),\n                            i;\n                        for (i = 0; i < tspans.length; i++) {\n                            tspan = tspans[i];\n                            // If the x values are equal, the tspan represents a linebreak\n                            if (tspan.getAttribute(key) === parentVal) {\n                                tspan.setAttribute(key, value);\n                            }\n                        }\n                        element.setAttribute(key, value);\n                    };\n                }\n\n                return wrapper;\n            },\n\n            /**\n             * Utility to return the baseline offset and total line height from the font\n             * size.\n             *\n             * @param {?string} fontSize The current font size to inspect. If not given,\n             *   the font size will be found from the DOM element.\n             * @param {SVGElement|SVGDOMElement} [elem] The element to inspect for a\n             *   current font size.\n             * @returns {Object} An object containing `h`: the line height, `b`: the\n             * baseline relative to the top of the box, and `f`: the font size.\n             */\n            fontMetrics: function(fontSize, elem) {\n                var lineHeight,\n                    baseline;\n\n\n                fontSize = fontSize ||\n                    // When the elem is a DOM element (#5932)\n                    (elem && elem.style && elem.style.fontSize) ||\n                    // Fall back on the renderer style default\n                    (this.style && this.style.fontSize);\n\n\n\n                // Handle different units\n                if (/px/.test(fontSize)) {\n                    fontSize = pInt(fontSize);\n                } else if (/em/.test(fontSize)) {\n                    // The em unit depends on parent items\n                    fontSize = parseFloat(fontSize) *\n                        (elem ? this.fontMetrics(null, elem.parentNode).f : 16);\n                } else {\n                    fontSize = 12;\n                }\n\n                // Empirical values found by comparing font size and bounding box\n                // height. Applies to the default font family.\n                // http://jsfiddle.net/highcharts/7xvn7/\n                lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);\n                baseline = Math.round(lineHeight * 0.8);\n\n                return {\n                    h: lineHeight,\n                    b: baseline,\n                    f: fontSize\n                };\n            },\n\n            /**\n             * Correct X and Y positioning of a label for rotation (#1764)\n             */\n            rotCorr: function(baseline, rotation, alterY) {\n                var y = baseline;\n                if (rotation && alterY) {\n                    y = Math.max(y * Math.cos(rotation * deg2rad), 4);\n                }\n                return {\n                    x: (-baseline / 3) * Math.sin(rotation * deg2rad),\n                    y: y\n                };\n            },\n\n            /**\n             * Draw a label, which is an extended text element with support for border\n             * and background. Highcharts creates a `g` element with a text and a `path`\n             * or `rect` inside, to make it behave somewhat like a HTML div. Border and\n             * background are set through `stroke`, `stroke-width` and `fill` attributes\n             * using the {@link Highcharts.SVGElement#attr|attr} method. To update the\n             * text after render, run `label.attr({ text: 'New text' })`.\n             * \n             * @param  {string} str\n             *         The initial text string or (subset) HTML to render.\n             * @param  {number} x\n             *         The x position of the label's left side.\n             * @param  {number} y\n             *         The y position of the label's top side or baseline, depending on\n             *         the `baseline` parameter.\n             * @param  {String} shape\n             *         The shape of the label's border/background, if any. Defaults to\n             *         `rect`. Other possible values are `callout` or other shapes\n             *         defined in {@link Highcharts.SVGRenderer#symbols}.\n             * @param  {number} anchorX\n             *         In case the `shape` has a pointer, like a flag, this is the\n             *         coordinates it should be pinned to.\n             * @param  {number} anchorY\n             *         In case the `shape` has a pointer, like a flag, this is the\n             *         coordinates it should be pinned to.\n             * @param  {Boolean} baseline\n             *         Whether to position the label relative to the text baseline,\n             *\t       like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the\n             *\t       upper border of the rectangle.\n             * @param  {String} className\n             *         Class name for the group.\n             *\n             * @return {Highcharts.SVGElement}\n             *         The generated label.\n             *\n             * @sample highcharts/members/renderer-label-on-chart/\n             *         A label on the chart\n             */\n            label: function(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {\n\n                var renderer = this,\n                    wrapper = renderer.g(className !== 'button' && 'label'),\n                    text = wrapper.text = renderer.text('', 0, 0, useHTML)\n                    .attr({\n                        zIndex: 1\n                    }),\n                    box,\n                    bBox,\n                    alignFactor = 0,\n                    padding = 3,\n                    paddingLeft = 0,\n                    width,\n                    height,\n                    wrapperX,\n                    wrapperY,\n                    textAlign,\n                    deferredAttr = {},\n                    strokeWidth,\n                    baselineOffset,\n                    hasBGImage = /^url\\((.*?)\\)$/.test(shape),\n                    needsBox = hasBGImage,\n                    getCrispAdjust,\n                    updateBoxSize,\n                    updateTextPadding,\n                    boxAttr;\n\n                if (className) {\n                    wrapper.addClass('highcharts-' + className);\n                }\n\n\n                needsBox = hasBGImage;\n                getCrispAdjust = function() {\n                    return (strokeWidth || 0) % 2 / 2;\n                };\n\n\n\n                /**\n                 * This function runs after the label is added to the DOM (when the bounding box is\n                 * available), and after the text of the label is updated to detect the new bounding\n                 * box and reflect it in the border box.\n                 */\n                updateBoxSize = function() {\n                    var style = text.element.style,\n                        crispAdjust,\n                        attribs = {};\n\n                    bBox = (width === undefined || height === undefined || textAlign) && defined(text.textStr) &&\n                        text.getBBox(); //#3295 && 3514 box failure when string equals 0\n                    wrapper.width = (width || bBox.width || 0) + 2 * padding + paddingLeft;\n                    wrapper.height = (height || bBox.height || 0) + 2 * padding;\n\n                    // Update the label-scoped y offset\n                    baselineOffset = padding + renderer.fontMetrics(style && style.fontSize, text).b;\n\n\n                    if (needsBox) {\n\n                        // Create the border box if it is not already present\n                        if (!box) {\n                            wrapper.box = box = renderer.symbols[shape] || hasBGImage ? // Symbol definition exists (#5324)\n                                renderer.symbol(shape) :\n                                renderer.rect();\n\n                            box.addClass(\n                                (className === 'button' ? '' : 'highcharts-label-box') + // Don't use label className for buttons\n                                (className ? ' highcharts-' + className + '-box' : '')\n                            );\n\n                            box.add(wrapper);\n\n                            crispAdjust = getCrispAdjust();\n                            attribs.x = crispAdjust;\n                            attribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;\n                        }\n\n                        // Apply the box attributes\n                        attribs.width = Math.round(wrapper.width);\n                        attribs.height = Math.round(wrapper.height);\n\n                        box.attr(extend(attribs, deferredAttr));\n                        deferredAttr = {};\n                    }\n                };\n\n                /**\n                 * This function runs after setting text or padding, but only if padding is changed\n                 */\n                updateTextPadding = function() {\n                    var textX = paddingLeft + padding,\n                        textY;\n\n                    // determin y based on the baseline\n                    textY = baseline ? 0 : baselineOffset;\n\n                    // compensate for alignment\n                    if (defined(width) && bBox && (textAlign === 'center' || textAlign === 'right')) {\n                        textX += {\n                            center: 0.5,\n                            right: 1\n                        }[textAlign] * (width - bBox.width);\n                    }\n\n                    // update if anything changed\n                    if (textX !== text.x || textY !== text.y) {\n                        text.attr('x', textX);\n                        if (textY !== undefined) {\n                            text.attr('y', textY);\n                        }\n                    }\n\n                    // record current values\n                    text.x = textX;\n                    text.y = textY;\n                };\n\n                /**\n                 * Set a box attribute, or defer it if the box is not yet created\n                 * @param {Object} key\n                 * @param {Object} value\n                 */\n                boxAttr = function(key, value) {\n                    if (box) {\n                        box.attr(key, value);\n                    } else {\n                        deferredAttr[key] = value;\n                    }\n                };\n\n                /**\n                 * After the text element is added, get the desired size of the border box\n                 * and add it before the text in the DOM.\n                 */\n                wrapper.onAdd = function() {\n                    text.add(wrapper);\n                    wrapper.attr({\n                        text: (str || str === 0) ? str : '', // alignment is available now // #3295: 0 not rendered if given as a value\n                        x: x,\n                        y: y\n                    });\n\n                    if (box && defined(anchorX)) {\n                        wrapper.attr({\n                            anchorX: anchorX,\n                            anchorY: anchorY\n                        });\n                    }\n                };\n\n                /*\n                 * Add specific attribute setters.\n                 */\n\n                // only change local variables\n                wrapper.widthSetter = function(value) {\n                    width = H.isNumber(value) ? value : null; // width:auto => null\n                };\n                wrapper.heightSetter = function(value) {\n                    height = value;\n                };\n                wrapper['text-alignSetter'] = function(value) {\n                    textAlign = value;\n                };\n                wrapper.paddingSetter = function(value) {\n                    if (defined(value) && value !== padding) {\n                        padding = wrapper.padding = value;\n                        updateTextPadding();\n                    }\n                };\n                wrapper.paddingLeftSetter = function(value) {\n                    if (defined(value) && value !== paddingLeft) {\n                        paddingLeft = value;\n                        updateTextPadding();\n                    }\n                };\n\n\n                // change local variable and prevent setting attribute on the group\n                wrapper.alignSetter = function(value) {\n                    value = {\n                        left: 0,\n                        center: 0.5,\n                        right: 1\n                    }[value];\n                    if (value !== alignFactor) {\n                        alignFactor = value;\n                        if (bBox) { // Bounding box exists, means we're dynamically changing\n                            wrapper.attr({\n                                x: wrapperX\n                            }); // #5134\n                        }\n                    }\n                };\n\n                // apply these to the box and the text alike\n                wrapper.textSetter = function(value) {\n                    if (value !== undefined) {\n                        text.textSetter(value);\n                    }\n                    updateBoxSize();\n                    updateTextPadding();\n                };\n\n                // apply these to the box but not to the text\n                wrapper['stroke-widthSetter'] = function(value, key) {\n                    if (value) {\n                        needsBox = true;\n                    }\n                    strokeWidth = this['stroke-width'] = value;\n                    boxAttr(key, value);\n                };\n\n                wrapper.strokeSetter = wrapper.fillSetter = wrapper.rSetter = function(value, key) {\n                    if (key === 'fill' && value) {\n                        needsBox = true;\n                    }\n                    boxAttr(key, value);\n                };\n\n                wrapper.anchorXSetter = function(value, key) {\n                    anchorX = wrapper.anchorX = value;\n                    boxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);\n                };\n                wrapper.anchorYSetter = function(value, key) {\n                    anchorY = wrapper.anchorY = value;\n                    boxAttr(key, value - wrapperY);\n                };\n\n                // rename attributes\n                wrapper.xSetter = function(value) {\n                    wrapper.x = value; // for animation getter\n                    if (alignFactor) {\n                        value -= alignFactor * ((width || bBox.width) + 2 * padding);\n                    }\n                    wrapperX = Math.round(value);\n                    wrapper.attr('translateX', wrapperX);\n                };\n                wrapper.ySetter = function(value) {\n                    wrapperY = wrapper.y = Math.round(value);\n                    wrapper.attr('translateY', wrapperY);\n                };\n\n                // Redirect certain methods to either the box or the text\n                var baseCss = wrapper.css;\n                return extend(wrapper, {\n                    /**\n                     * Pick up some properties and apply them to the text instead of the\n                     * wrapper.\n                     * @ignore\n                     */\n                    css: function(styles) {\n                        if (styles) {\n                            var textStyles = {};\n                            styles = merge(styles); // create a copy to avoid altering the original object (#537)\n                            each(wrapper.textProps, function(prop) {\n                                if (styles[prop] !== undefined) {\n                                    textStyles[prop] = styles[prop];\n                                    delete styles[prop];\n                                }\n                            });\n                            text.css(textStyles);\n                        }\n                        return baseCss.call(wrapper, styles);\n                    },\n                    /**\n                     * Return the bounding box of the box, not the group.\n                     * @ignore\n                     */\n                    getBBox: function() {\n                        return {\n                            width: bBox.width + 2 * padding,\n                            height: bBox.height + 2 * padding,\n                            x: bBox.x - padding,\n                            y: bBox.y - padding\n                        };\n                    },\n\n                    /**\n                     * Apply the shadow to the box.\n                     * @ignore\n                     */\n                    shadow: function(b) {\n                        if (b) {\n                            updateBoxSize();\n                            if (box) {\n                                box.shadow(b);\n                            }\n                        }\n                        return wrapper;\n                    },\n\n                    /**\n                     * Destroy and release memory.\n                     * @ignore\n                     */\n                    destroy: function() {\n\n                        // Added by button implementation\n                        removeEvent(wrapper.element, 'mouseenter');\n                        removeEvent(wrapper.element, 'mouseleave');\n\n                        if (text) {\n                            text = text.destroy();\n                        }\n                        if (box) {\n                            box = box.destroy();\n                        }\n                        // Call base implementation to destroy the rest\n                        SVGElement.prototype.destroy.call(wrapper);\n\n                        // Release local pointers (#1298)\n                        wrapper = renderer = updateBoxSize = updateTextPadding = boxAttr = null;\n                    }\n                });\n            }\n        }); // end SVGRenderer\n\n\n        // general renderer\n        H.Renderer = SVGRenderer;\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var attr = H.attr,\n            createElement = H.createElement,\n            css = H.css,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            isFirefox = H.isFirefox,\n            isMS = H.isMS,\n            isWebKit = H.isWebKit,\n            pInt = H.pInt,\n            SVGElement = H.SVGElement,\n            SVGRenderer = H.SVGRenderer,\n            win = H.win,\n            wrap = H.wrap;\n\n        // Extend SvgElement for useHTML option\n        extend(SVGElement.prototype, /** @lends SVGElement.prototype */ {\n            /**\n             * Apply CSS to HTML elements. This is used in text within SVG rendering and\n             * by the VML renderer\n             */\n            htmlCss: function(styles) {\n                var wrapper = this,\n                    element = wrapper.element,\n                    textWidth = styles && element.tagName === 'SPAN' && styles.width;\n\n                if (textWidth) {\n                    delete styles.width;\n                    wrapper.textWidth = textWidth;\n                    wrapper.updateTransform();\n                }\n                if (styles && styles.textOverflow === 'ellipsis') {\n                    styles.whiteSpace = 'nowrap';\n                    styles.overflow = 'hidden';\n                }\n                wrapper.styles = extend(wrapper.styles, styles);\n                css(wrapper.element, styles);\n\n                return wrapper;\n            },\n\n            /**\n             * VML and useHTML method for calculating the bounding box based on offsets\n             * @param {Boolean} refresh Whether to force a fresh value from the DOM or to\n             * use the cached value\n             *\n             * @return {Object} A hash containing values for x, y, width and height\n             */\n\n            htmlGetBBox: function() {\n                var wrapper = this,\n                    element = wrapper.element;\n\n                // faking getBBox in exported SVG in legacy IE\n                // faking getBBox in exported SVG in legacy IE (is this a duplicate of the fix for #1079?)\n                if (element.nodeName === 'text') {\n                    element.style.position = 'absolute';\n                }\n\n                return {\n                    x: element.offsetLeft,\n                    y: element.offsetTop,\n                    width: element.offsetWidth,\n                    height: element.offsetHeight\n                };\n            },\n\n            /**\n             * VML override private method to update elements based on internal\n             * properties based on SVG transform\n             */\n            htmlUpdateTransform: function() {\n                // aligning non added elements is expensive\n                if (!this.added) {\n                    this.alignOnAdd = true;\n                    return;\n                }\n\n                var wrapper = this,\n                    renderer = wrapper.renderer,\n                    elem = wrapper.element,\n                    translateX = wrapper.translateX || 0,\n                    translateY = wrapper.translateY || 0,\n                    x = wrapper.x || 0,\n                    y = wrapper.y || 0,\n                    align = wrapper.textAlign || 'left',\n                    alignCorrection = {\n                        left: 0,\n                        center: 0.5,\n                        right: 1\n                    }[align],\n                    styles = wrapper.styles;\n\n                // apply translate\n                css(elem, {\n                    marginLeft: translateX,\n                    marginTop: translateY\n                });\n\n\n                if (wrapper.shadows) { // used in labels/tooltip\n                    each(wrapper.shadows, function(shadow) {\n                        css(shadow, {\n                            marginLeft: translateX + 1,\n                            marginTop: translateY + 1\n                        });\n                    });\n                }\n\n\n                // apply inversion\n                if (wrapper.inverted) { // wrapper is a group\n                    each(elem.childNodes, function(child) {\n                        renderer.invertChild(child, elem);\n                    });\n                }\n\n                if (elem.tagName === 'SPAN') {\n\n                    var rotation = wrapper.rotation,\n                        baseline,\n                        textWidth = pInt(wrapper.textWidth),\n                        whiteSpace = styles && styles.whiteSpace,\n                        currentTextTransform = [rotation, align, elem.innerHTML, wrapper.textWidth, wrapper.textAlign].join(',');\n\n                    if (currentTextTransform !== wrapper.cTT) { // do the calculations and DOM access only if properties changed\n\n\n                        baseline = renderer.fontMetrics(elem.style.fontSize).b;\n\n                        // Renderer specific handling of span rotation\n                        if (defined(rotation)) {\n                            wrapper.setSpanRotation(rotation, alignCorrection, baseline);\n                        }\n\n                        // Reset multiline/ellipsis in order to read width (#4928, #5417)\n                        css(elem, {\n                            width: '',\n                            whiteSpace: whiteSpace || 'nowrap'\n                        });\n\n                        // Update textWidth\n                        if (elem.offsetWidth > textWidth && /[ \\-]/.test(elem.textContent || elem.innerText)) { // #983, #1254\n                            css(elem, {\n                                width: textWidth + 'px',\n                                display: 'block',\n                                whiteSpace: whiteSpace || 'normal' // #3331\n                            });\n                        }\n\n\n                        wrapper.getSpanCorrection(elem.offsetWidth, baseline, alignCorrection, rotation, align);\n                    }\n\n                    // apply position with correction\n                    css(elem, {\n                        left: (x + (wrapper.xCorr || 0)) + 'px',\n                        top: (y + (wrapper.yCorr || 0)) + 'px'\n                    });\n\n                    // force reflow in webkit to apply the left and top on useHTML element (#1249)\n                    if (isWebKit) {\n                        baseline = elem.offsetHeight; // assigned to baseline for lint purpose\n                    }\n\n                    // record current text transform\n                    wrapper.cTT = currentTextTransform;\n                }\n            },\n\n            /**\n             * Set the rotation of an individual HTML span\n             */\n            setSpanRotation: function(rotation, alignCorrection, baseline) {\n                var rotationStyle = {},\n                    cssTransformKey = isMS ? '-ms-transform' : isWebKit ? '-webkit-transform' : isFirefox ? 'MozTransform' : win.opera ? '-o-transform' : '';\n\n                rotationStyle[cssTransformKey] = rotationStyle.transform = 'rotate(' + rotation + 'deg)';\n                rotationStyle[cssTransformKey + (isFirefox ? 'Origin' : '-origin')] = rotationStyle.transformOrigin = (alignCorrection * 100) + '% ' + baseline + 'px';\n                css(this.element, rotationStyle);\n            },\n\n            /**\n             * Get the correction in X and Y positioning as the element is rotated.\n             */\n            getSpanCorrection: function(width, baseline, alignCorrection) {\n                this.xCorr = -width * alignCorrection;\n                this.yCorr = -baseline;\n            }\n        });\n\n        // Extend SvgRenderer for useHTML option.\n        extend(SVGRenderer.prototype, /** @lends SVGRenderer.prototype */ {\n            /**\n             * Create HTML text node. This is used by the VML renderer as well as the SVG\n             * renderer through the useHTML option.\n             *\n             * @param {String} str\n             * @param {Number} x\n             * @param {Number} y\n             */\n            html: function(str, x, y) {\n                var wrapper = this.createElement('span'),\n                    element = wrapper.element,\n                    renderer = wrapper.renderer,\n                    isSVG = renderer.isSVG,\n                    addSetters = function(element, style) {\n                        // These properties are set as attributes on the SVG group, and as\n                        // identical CSS properties on the div. (#3542)\n                        each(['opacity', 'visibility'], function(prop) {\n                            wrap(element, prop + 'Setter', function(proceed, value, key, elem) {\n                                proceed.call(this, value, key, elem);\n                                style[key] = value;\n                            });\n                        });\n                    };\n\n                // Text setter\n                wrapper.textSetter = function(value) {\n                    if (value !== element.innerHTML) {\n                        delete this.bBox;\n                    }\n                    element.innerHTML = this.textStr = value;\n                    wrapper.htmlUpdateTransform();\n                };\n\n                // Add setters for the element itself (#4938)\n                if (isSVG) { // #4938, only for HTML within SVG\n                    addSetters(wrapper, wrapper.element.style);\n                }\n\n                // Various setters which rely on update transform\n                wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function(value, key) {\n                    if (key === 'align') {\n                        key = 'textAlign'; // Do not overwrite the SVGElement.align method. Same as VML.\n                    }\n                    wrapper[key] = value;\n                    wrapper.htmlUpdateTransform();\n                };\n\n                // Set the default attributes\n                wrapper\n                    .attr({\n                        text: str,\n                        x: Math.round(x),\n                        y: Math.round(y)\n                    })\n                    .css({\n\n                        fontFamily: this.style.fontFamily,\n                        fontSize: this.style.fontSize,\n\n                        position: 'absolute'\n                    });\n\n                // Keep the whiteSpace style outside the wrapper.styles collection\n                element.style.whiteSpace = 'nowrap';\n\n                // Use the HTML specific .css method\n                wrapper.css = wrapper.htmlCss;\n\n                // This is specific for HTML within SVG\n                if (isSVG) {\n                    wrapper.add = function(svgGroupWrapper) {\n\n                        var htmlGroup,\n                            container = renderer.box.parentNode,\n                            parentGroup,\n                            parents = [];\n\n                        this.parentGroup = svgGroupWrapper;\n\n                        // Create a mock group to hold the HTML elements\n                        if (svgGroupWrapper) {\n                            htmlGroup = svgGroupWrapper.div;\n                            if (!htmlGroup) {\n\n                                // Read the parent chain into an array and read from top down\n                                parentGroup = svgGroupWrapper;\n                                while (parentGroup) {\n\n                                    parents.push(parentGroup);\n\n                                    // Move up to the next parent group\n                                    parentGroup = parentGroup.parentGroup;\n                                }\n\n                                // Ensure dynamically updating position when any parent is translated\n                                each(parents.reverse(), function(parentGroup) {\n                                    var htmlGroupStyle,\n                                        cls = attr(parentGroup.element, 'class');\n\n                                    if (cls) {\n                                        cls = {\n                                            className: cls\n                                        };\n                                    } // else null\n\n                                    // Create a HTML div and append it to the parent div to emulate\n                                    // the SVG group structure\n                                    htmlGroup = parentGroup.div = parentGroup.div || createElement('div', cls, {\n                                        position: 'absolute',\n                                        left: (parentGroup.translateX || 0) + 'px',\n                                        top: (parentGroup.translateY || 0) + 'px',\n                                        display: parentGroup.display,\n                                        opacity: parentGroup.opacity, // #5075\n                                        pointerEvents: parentGroup.styles && parentGroup.styles.pointerEvents // #5595\n                                    }, htmlGroup || container); // the top group is appended to container\n\n                                    // Shortcut\n                                    htmlGroupStyle = htmlGroup.style;\n\n                                    // Set listeners to update the HTML div's position whenever the SVG group\n                                    // position is changed\n                                    extend(parentGroup, {\n                                        on: function() {\n                                            wrapper.on.apply({\n                                                element: parents[0].div\n                                            }, arguments);\n                                            return parentGroup;\n                                        },\n                                        translateXSetter: function(value, key) {\n                                            htmlGroupStyle.left = value + 'px';\n                                            parentGroup[key] = value;\n                                            parentGroup.doTransform = true;\n                                        },\n                                        translateYSetter: function(value, key) {\n                                            htmlGroupStyle.top = value + 'px';\n                                            parentGroup[key] = value;\n                                            parentGroup.doTransform = true;\n                                        }\n                                    });\n                                    addSetters(parentGroup, htmlGroupStyle);\n                                });\n\n                            }\n                        } else {\n                            htmlGroup = container;\n                        }\n\n                        htmlGroup.appendChild(element);\n\n                        // Shared with VML:\n                        wrapper.added = true;\n                        if (wrapper.alignOnAdd) {\n                            wrapper.htmlUpdateTransform();\n                        }\n\n                        return wrapper;\n                    };\n                }\n                return wrapper;\n            }\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n\n        var VMLRenderer,\n            VMLRendererExtension,\n            VMLElement,\n\n            createElement = H.createElement,\n            css = H.css,\n            defined = H.defined,\n            deg2rad = H.deg2rad,\n            discardElement = H.discardElement,\n            doc = H.doc,\n            each = H.each,\n            erase = H.erase,\n            extend = H.extend,\n            extendClass = H.extendClass,\n            isArray = H.isArray,\n            isNumber = H.isNumber,\n            isObject = H.isObject,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            pInt = H.pInt,\n            svg = H.svg,\n            SVGElement = H.SVGElement,\n            SVGRenderer = H.SVGRenderer,\n            win = H.win;\n\n        /* ****************************************************************************\n         *                                                                            *\n         * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *\n         *                                                                            *\n         * For applications and websites that don't need IE support, like platform    *\n         * targeted mobile apps and web apps, this code can be removed.               *\n         *                                                                            *\n         *****************************************************************************/\n\n        /**\n         * @constructor\n         */\n        if (!svg) {\n\n            /**\n             * The VML element wrapper.\n             */\n            VMLElement = {\n\n                docMode8: doc && doc.documentMode === 8,\n\n                /**\n                 * Initialize a new VML element wrapper. It builds the markup as a string\n                 * to minimize DOM traffic.\n                 * @param {Object} renderer\n                 * @param {Object} nodeName\n                 */\n                init: function(renderer, nodeName) {\n                    var wrapper = this,\n                        markup = ['<', nodeName, ' filled=\"f\" stroked=\"f\"'],\n                        style = ['position: ', 'absolute', ';'],\n                        isDiv = nodeName === 'div';\n\n                    // divs and shapes need size\n                    if (nodeName === 'shape' || isDiv) {\n                        style.push('left:0;top:0;width:1px;height:1px;');\n                    }\n                    style.push('visibility: ', isDiv ? 'hidden' : 'visible');\n\n                    markup.push(' style=\"', style.join(''), '\"/>');\n\n                    // create element with default attributes and style\n                    if (nodeName) {\n                        markup = isDiv || nodeName === 'span' || nodeName === 'img' ?\n                            markup.join('') :\n                            renderer.prepVML(markup);\n                        wrapper.element = createElement(markup);\n                    }\n\n                    wrapper.renderer = renderer;\n                },\n\n                /**\n                 * Add the node to the given parent\n                 * @param {Object} parent\n                 */\n                add: function(parent) {\n                    var wrapper = this,\n                        renderer = wrapper.renderer,\n                        element = wrapper.element,\n                        box = renderer.box,\n                        inverted = parent && parent.inverted,\n\n                        // get the parent node\n                        parentNode = parent ?\n                        parent.element || parent :\n                        box;\n\n                    if (parent) {\n                        this.parentGroup = parent;\n                    }\n\n                    // if the parent group is inverted, apply inversion on all children\n                    if (inverted) { // only on groups\n                        renderer.invertChild(element, parentNode);\n                    }\n\n                    // append it\n                    parentNode.appendChild(element);\n\n                    // align text after adding to be able to read offset\n                    wrapper.added = true;\n                    if (wrapper.alignOnAdd && !wrapper.deferUpdateTransform) {\n                        wrapper.updateTransform();\n                    }\n\n                    // fire an event for internal hooks\n                    if (wrapper.onAdd) {\n                        wrapper.onAdd();\n                    }\n\n                    // IE8 Standards can't set the class name before the element is appended\n                    if (this.className) {\n                        this.attr('class', this.className);\n                    }\n\n                    return wrapper;\n                },\n\n                /**\n                 * VML always uses htmlUpdateTransform\n                 */\n                updateTransform: SVGElement.prototype.htmlUpdateTransform,\n\n                /**\n                 * Set the rotation of a span with oldIE's filter\n                 */\n                setSpanRotation: function() {\n                    // Adjust for alignment and rotation. Rotation of useHTML content is not yet implemented\n                    // but it can probably be implemented for Firefox 3.5+ on user request. FF3.5+\n                    // has support for CSS3 transform. The getBBox method also needs to be updated\n                    // to compensate for the rotation, like it currently does for SVG.\n                    // Test case: http://jsfiddle.net/highcharts/Ybt44/\n\n                    var rotation = this.rotation,\n                        costheta = Math.cos(rotation * deg2rad),\n                        sintheta = Math.sin(rotation * deg2rad);\n\n                    css(this.element, {\n                        filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta,\n                            ', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta,\n                            ', sizingMethod=\\'auto expand\\')'\n                        ].join('') : 'none'\n                    });\n                },\n\n                /**\n                 * Get the positioning correction for the span after rotating.\n                 */\n                getSpanCorrection: function(width, baseline, alignCorrection, rotation, align) {\n\n                    var costheta = rotation ? Math.cos(rotation * deg2rad) : 1,\n                        sintheta = rotation ? Math.sin(rotation * deg2rad) : 0,\n                        height = pick(this.elemHeight, this.element.offsetHeight),\n                        quad,\n                        nonLeft = align && align !== 'left';\n\n                    // correct x and y\n                    this.xCorr = costheta < 0 && -width;\n                    this.yCorr = sintheta < 0 && -height;\n\n                    // correct for baseline and corners spilling out after rotation\n                    quad = costheta * sintheta < 0;\n                    this.xCorr += sintheta * baseline * (quad ? 1 - alignCorrection : alignCorrection);\n                    this.yCorr -= costheta * baseline * (rotation ? (quad ? alignCorrection : 1 - alignCorrection) : 1);\n                    // correct for the length/height of the text\n                    if (nonLeft) {\n                        this.xCorr -= width * alignCorrection * (costheta < 0 ? -1 : 1);\n                        if (rotation) {\n                            this.yCorr -= height * alignCorrection * (sintheta < 0 ? -1 : 1);\n                        }\n                        css(this.element, {\n                            textAlign: align\n                        });\n                    }\n                },\n\n                /**\n                 * Converts a subset of an SVG path definition to its VML counterpart. Takes an array\n                 * as the parameter and returns a string.\n                 */\n                pathToVML: function(value) {\n                    // convert paths\n                    var i = value.length,\n                        path = [];\n\n                    while (i--) {\n\n                        // Multiply by 10 to allow subpixel precision.\n                        // Substracting half a pixel seems to make the coordinates\n                        // align with SVG, but this hasn't been tested thoroughly\n                        if (isNumber(value[i])) {\n                            path[i] = Math.round(value[i] * 10) - 5;\n                        } else if (value[i] === 'Z') { // close the path\n                            path[i] = 'x';\n                        } else {\n                            path[i] = value[i];\n\n                            // When the start X and end X coordinates of an arc are too close,\n                            // they are rounded to the same value above. In this case, substract or\n                            // add 1 from the end X and Y positions. #186, #760, #1371, #1410.\n                            if (value.isArc && (value[i] === 'wa' || value[i] === 'at')) {\n                                // Start and end X\n                                if (path[i + 5] === path[i + 7]) {\n                                    path[i + 7] += value[i + 7] > value[i + 5] ? 1 : -1;\n                                }\n                                // Start and end Y\n                                if (path[i + 6] === path[i + 8]) {\n                                    path[i + 8] += value[i + 8] > value[i + 6] ? 1 : -1;\n                                }\n                            }\n                        }\n                    }\n\n\n                    // Loop up again to handle path shortcuts (#2132)\n                    /*while (i++ < path.length) {\n                    \tif (path[i] === 'H') { // horizontal line to\n                    \t\tpath[i] = 'L';\n                    \t\tpath.splice(i + 2, 0, path[i - 1]);\n                    \t} else if (path[i] === 'V') { // vertical line to\n                    \t\tpath[i] = 'L';\n                    \t\tpath.splice(i + 1, 0, path[i - 2]);\n                    \t}\n                    }*/\n                    return path.join(' ') || 'x';\n                },\n\n                /**\n                 * Set the element's clipping to a predefined rectangle\n                 *\n                 * @param {String} id The id of the clip rectangle\n                 */\n                clip: function(clipRect) {\n                    var wrapper = this,\n                        clipMembers,\n                        cssRet;\n\n                    if (clipRect) {\n                        clipMembers = clipRect.members;\n                        erase(clipMembers, wrapper); // Ensure unique list of elements (#1258)\n                        clipMembers.push(wrapper);\n                        wrapper.destroyClip = function() {\n                            erase(clipMembers, wrapper);\n                        };\n                        cssRet = clipRect.getCSS(wrapper);\n\n                    } else {\n                        if (wrapper.destroyClip) {\n                            wrapper.destroyClip();\n                        }\n                        cssRet = {\n                            clip: wrapper.docMode8 ? 'inherit' : 'rect(auto)'\n                        }; // #1214\n                    }\n\n                    return wrapper.css(cssRet);\n\n                },\n\n                /**\n                 * Set styles for the element\n                 * @param {Object} styles\n                 */\n                css: SVGElement.prototype.htmlCss,\n\n                /**\n                 * Removes a child either by removeChild or move to garbageBin.\n                 * Issue 490; in VML removeChild results in Orphaned nodes according to sIEve, discardElement does not.\n                 */\n                safeRemoveChild: function(element) {\n                    // discardElement will detach the node from its parent before attaching it\n                    // to the garbage bin. Therefore it is important that the node is attached and have parent.\n                    if (element.parentNode) {\n                        discardElement(element);\n                    }\n                },\n\n                /**\n                 * Extend element.destroy by removing it from the clip members array\n                 */\n                destroy: function() {\n                    if (this.destroyClip) {\n                        this.destroyClip();\n                    }\n\n                    return SVGElement.prototype.destroy.apply(this);\n                },\n\n                /**\n                 * Add an event listener. VML override for normalizing event parameters.\n                 * @param {String} eventType\n                 * @param {Function} handler\n                 */\n                on: function(eventType, handler) {\n                    // simplest possible event model for internal use\n                    this.element['on' + eventType] = function() {\n                        var evt = win.event;\n                        evt.target = evt.srcElement;\n                        handler(evt);\n                    };\n                    return this;\n                },\n\n                /**\n                 * In stacked columns, cut off the shadows so that they don't overlap\n                 */\n                cutOffPath: function(path, length) {\n\n                    var len;\n\n                    path = path.split(/[ ,]/); // The extra comma tricks the trailing comma remover in \"gulp scripts\" task\n                    len = path.length;\n\n                    if (len === 9 || len === 11) {\n                        path[len - 4] = path[len - 2] = pInt(path[len - 2]) - 10 * length;\n                    }\n                    return path.join(' ');\n                },\n\n                /**\n                 * Apply a drop shadow by copying elements and giving them different strokes\n                 * @param {Boolean|Object} shadowOptions\n                 */\n                shadow: function(shadowOptions, group, cutOff) {\n                    var shadows = [],\n                        i,\n                        element = this.element,\n                        renderer = this.renderer,\n                        shadow,\n                        elemStyle = element.style,\n                        markup,\n                        path = element.path,\n                        strokeWidth,\n                        modifiedPath,\n                        shadowWidth,\n                        shadowElementOpacity;\n\n                    // some times empty paths are not strings\n                    if (path && typeof path.value !== 'string') {\n                        path = 'x';\n                    }\n                    modifiedPath = path;\n\n                    if (shadowOptions) {\n                        shadowWidth = pick(shadowOptions.width, 3);\n                        shadowElementOpacity = (shadowOptions.opacity || 0.15) / shadowWidth;\n                        for (i = 1; i <= 3; i++) {\n\n                            strokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\n                            // Cut off shadows for stacked column items\n                            if (cutOff) {\n                                modifiedPath = this.cutOffPath(path.value, strokeWidth + 0.5);\n                            }\n\n                            markup = ['<shape isShadow=\"true\" strokeweight=\"', strokeWidth,\n                                '\" filled=\"false\" path=\"', modifiedPath,\n                                '\" coordsize=\"10 10\" style=\"', element.style.cssText, '\" />'\n                            ];\n\n                            shadow = createElement(renderer.prepVML(markup),\n                                null, {\n                                    left: pInt(elemStyle.left) + pick(shadowOptions.offsetX, 1),\n                                    top: pInt(elemStyle.top) + pick(shadowOptions.offsetY, 1)\n                                }\n                            );\n                            if (cutOff) {\n                                shadow.cutOff = strokeWidth + 1;\n                            }\n\n                            // apply the opacity\n                            markup = [\n                                '<stroke color=\"',\n                                shadowOptions.color || '#000000',\n                                '\" opacity=\"', shadowElementOpacity * i, '\"/>'\n                            ];\n                            createElement(renderer.prepVML(markup), null, null, shadow);\n\n\n                            // insert it\n                            if (group) {\n                                group.element.appendChild(shadow);\n                            } else {\n                                element.parentNode.insertBefore(shadow, element);\n                            }\n\n                            // record it\n                            shadows.push(shadow);\n\n                        }\n\n                        this.shadows = shadows;\n                    }\n                    return this;\n                },\n                updateShadows: noop, // Used in SVG only\n\n                setAttr: function(key, value) {\n                    if (this.docMode8) { // IE8 setAttribute bug\n                        this.element[key] = value;\n                    } else {\n                        this.element.setAttribute(key, value);\n                    }\n                },\n                classSetter: function(value) {\n                    // IE8 Standards mode has problems retrieving the className unless set like this.\n                    // IE8 Standards can't set the class name before the element is appended.\n                    (this.added ? this.element : this).className = value;\n                },\n                dashstyleSetter: function(value, key, element) {\n                    var strokeElem = element.getElementsByTagName('stroke')[0] ||\n                        createElement(this.renderer.prepVML(['<stroke/>']), null, null, element);\n                    strokeElem[key] = value || 'solid';\n                    this[key] = value;\n                    /* because changing stroke-width will change the dash length\n\t\t\t\tand cause an epileptic effect */\n                },\n                dSetter: function(value, key, element) {\n                    var i,\n                        shadows = this.shadows;\n                    value = value || [];\n                    this.d = value.join && value.join(' '); // used in getter for animation\n\n                    element.path = value = this.pathToVML(value);\n\n                    // update shadows\n                    if (shadows) {\n                        i = shadows.length;\n                        while (i--) {\n                            shadows[i].path = shadows[i].cutOff ? this.cutOffPath(value, shadows[i].cutOff) : value;\n                        }\n                    }\n                    this.setAttr(key, value);\n                },\n                fillSetter: function(value, key, element) {\n                    var nodeName = element.nodeName;\n                    if (nodeName === 'SPAN') { // text color\n                        element.style.color = value;\n                    } else if (nodeName !== 'IMG') { // #1336\n                        element.filled = value !== 'none';\n                        this.setAttr('fillcolor', this.renderer.color(value, element, key, this));\n                    }\n                },\n                'fill-opacitySetter': function(value, key, element) {\n                    createElement(\n                        this.renderer.prepVML(['<', key.split('-')[0], ' opacity=\"', value, '\"/>']),\n                        null,\n                        null,\n                        element\n                    );\n                },\n                opacitySetter: noop, // Don't bother - animation is too slow and filters introduce artifacts\n                rotationSetter: function(value, key, element) {\n                    var style = element.style;\n                    this[key] = style[key] = value; // style is for #1873\n\n                    // Correction for the 1x1 size of the shape container. Used in gauge needles.\n                    style.left = -Math.round(Math.sin(value * deg2rad) + 1) + 'px';\n                    style.top = Math.round(Math.cos(value * deg2rad)) + 'px';\n                },\n                strokeSetter: function(value, key, element) {\n                    this.setAttr('strokecolor', this.renderer.color(value, element, key, this));\n                },\n                'stroke-widthSetter': function(value, key, element) {\n                    element.stroked = !!value; // VML \"stroked\" attribute\n                    this[key] = value; // used in getter, issue #113\n                    if (isNumber(value)) {\n                        value += 'px';\n                    }\n                    this.setAttr('strokeweight', value);\n                },\n                titleSetter: function(value, key) {\n                    this.setAttr(key, value);\n                },\n                visibilitySetter: function(value, key, element) {\n\n                    // Handle inherited visibility\n                    if (value === 'inherit') {\n                        value = 'visible';\n                    }\n\n                    // Let the shadow follow the main element\n                    if (this.shadows) {\n                        each(this.shadows, function(shadow) {\n                            shadow.style[key] = value;\n                        });\n                    }\n\n                    // Instead of toggling the visibility CSS property, move the div out of the viewport.\n                    // This works around #61 and #586\n                    if (element.nodeName === 'DIV') {\n                        value = value === 'hidden' ? '-999em' : 0;\n\n                        // In order to redraw, IE7 needs the div to be visible when tucked away\n                        // outside the viewport. So the visibility is actually opposite of\n                        // the expected value. This applies to the tooltip only.\n                        if (!this.docMode8) {\n                            element.style[key] = value ? 'visible' : 'hidden';\n                        }\n                        key = 'top';\n                    }\n                    element.style[key] = value;\n                },\n                xSetter: function(value, key, element) {\n                    this[key] = value; // used in getter\n\n                    if (key === 'x') {\n                        key = 'left';\n                    } else if (key === 'y') {\n                        key = 'top';\n                    }\n                    /* else {\n                    \t\t\t\tvalue = Math.max(0, value); // don't set width or height below zero (#311)\n                    \t\t\t}*/\n\n                    // clipping rectangle special\n                    if (this.updateClipping) {\n                        this[key] = value; // the key is now 'left' or 'top' for 'x' and 'y'\n                        this.updateClipping();\n                    } else {\n                        // normal\n                        element.style[key] = value;\n                    }\n                },\n                zIndexSetter: function(value, key, element) {\n                    element.style[key] = value;\n                }\n            };\n            VMLElement['stroke-opacitySetter'] = VMLElement['fill-opacitySetter'];\n            H.VMLElement = VMLElement = extendClass(SVGElement, VMLElement);\n\n            // Some shared setters\n            VMLElement.prototype.ySetter =\n                VMLElement.prototype.widthSetter =\n                VMLElement.prototype.heightSetter =\n                VMLElement.prototype.xSetter;\n\n\n            /**\n             * The VML renderer\n             */\n            VMLRendererExtension = { // inherit SVGRenderer\n\n                Element: VMLElement,\n                isIE8: win.navigator.userAgent.indexOf('MSIE 8.0') > -1,\n\n\n                /**\n                 * Initialize the VMLRenderer\n                 * @param {Object} container\n                 * @param {Number} width\n                 * @param {Number} height\n                 */\n                init: function(container, width, height) {\n                    var renderer = this,\n                        boxWrapper,\n                        box,\n                        css;\n\n                    renderer.alignedObjects = [];\n\n                    boxWrapper = renderer.createElement('div')\n                        .css({\n                            position: 'relative'\n                        });\n                    box = boxWrapper.element;\n                    container.appendChild(boxWrapper.element);\n\n\n                    // generate the containing box\n                    renderer.isVML = true;\n                    renderer.box = box;\n                    renderer.boxWrapper = boxWrapper;\n                    renderer.gradients = {};\n                    renderer.cache = {}; // Cache for numerical bounding boxes\n                    renderer.cacheKeys = [];\n                    renderer.imgCount = 0;\n\n\n                    renderer.setSize(width, height, false);\n\n                    // The only way to make IE6 and IE7 print is to use a global namespace. However,\n                    // with IE8 the only way to make the dynamic shapes visible in screen and print mode\n                    // seems to be to add the xmlns attribute and the behaviour style inline.\n                    if (!doc.namespaces.hcv) {\n\n                        doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');\n\n                        // Setup default CSS (#2153, #2368, #2384)\n                        css = 'hcv\\\\:fill, hcv\\\\:path, hcv\\\\:shape, hcv\\\\:stroke' +\n                            '{ behavior:url(#default#VML); display: inline-block; } ';\n                        try {\n                            doc.createStyleSheet().cssText = css;\n                        } catch (e) {\n                            doc.styleSheets[0].cssText += css;\n                        }\n\n                    }\n                },\n\n\n                /**\n                 * Detect whether the renderer is hidden. This happens when one of the parent elements\n                 * has display: none\n                 */\n                isHidden: function() {\n                    return !this.box.offsetWidth;\n                },\n\n                /**\n                 * Define a clipping rectangle. In VML it is accomplished by storing the values\n                 * for setting the CSS style to all associated members.\n                 *\n                 * @param {Number} x\n                 * @param {Number} y\n                 * @param {Number} width\n                 * @param {Number} height\n                 */\n                clipRect: function(x, y, width, height) {\n\n                    // create a dummy element\n                    var clipRect = this.createElement(),\n                        isObj = isObject(x);\n\n                    // mimic a rectangle with its style object for automatic updating in attr\n                    return extend(clipRect, {\n                        members: [],\n                        count: 0,\n                        left: (isObj ? x.x : x) + 1,\n                        top: (isObj ? x.y : y) + 1,\n                        width: (isObj ? x.width : width) - 1,\n                        height: (isObj ? x.height : height) - 1,\n                        getCSS: function(wrapper) {\n                            var element = wrapper.element,\n                                nodeName = element.nodeName,\n                                isShape = nodeName === 'shape',\n                                inverted = wrapper.inverted,\n                                rect = this,\n                                top = rect.top - (isShape ? element.offsetTop : 0),\n                                left = rect.left,\n                                right = left + rect.width,\n                                bottom = top + rect.height,\n                                ret = {\n                                    clip: 'rect(' +\n                                        Math.round(inverted ? left : top) + 'px,' +\n                                        Math.round(inverted ? bottom : right) + 'px,' +\n                                        Math.round(inverted ? right : bottom) + 'px,' +\n                                        Math.round(inverted ? top : left) + 'px)'\n                                };\n\n                            // issue 74 workaround\n                            if (!inverted && wrapper.docMode8 && nodeName === 'DIV') {\n                                extend(ret, {\n                                    width: right + 'px',\n                                    height: bottom + 'px'\n                                });\n                            }\n                            return ret;\n                        },\n\n                        // used in attr and animation to update the clipping of all members\n                        updateClipping: function() {\n                            each(clipRect.members, function(member) {\n                                // Member.element is falsy on deleted series, like in\n                                // stock/members/series-remove demo. Should be removed\n                                // from members, but this will do.\n                                if (member.element) {\n                                    member.css(clipRect.getCSS(member));\n                                }\n                            });\n                        }\n                    });\n\n                },\n\n\n                /**\n                 * Take a color and return it if it's a string, make it a gradient if it's a\n                 * gradient configuration object, and apply opacity.\n                 *\n                 * @param {Object} color The color or config object\n                 */\n                color: function(color, elem, prop, wrapper) {\n                    var renderer = this,\n                        colorObject,\n                        regexRgba = /^rgba/,\n                        markup,\n                        fillType,\n                        ret = 'none';\n\n                    // Check for linear or radial gradient\n                    if (color && color.linearGradient) {\n                        fillType = 'gradient';\n                    } else if (color && color.radialGradient) {\n                        fillType = 'pattern';\n                    }\n\n\n                    if (fillType) {\n\n                        var stopColor,\n                            stopOpacity,\n                            gradient = color.linearGradient || color.radialGradient,\n                            x1,\n                            y1,\n                            x2,\n                            y2,\n                            opacity1,\n                            opacity2,\n                            color1,\n                            color2,\n                            fillAttr = '',\n                            stops = color.stops,\n                            firstStop,\n                            lastStop,\n                            colors = [],\n                            addFillNode = function() {\n                                // Add the fill subnode. When colors attribute is used, the meanings of opacity and o:opacity2\n                                // are reversed.\n                                markup = ['<fill colors=\"' + colors.join(',') +\n                                    '\" opacity=\"', opacity2, '\" o:opacity2=\"',\n                                    opacity1, '\" type=\"', fillType, '\" ', fillAttr,\n                                    'focus=\"100%\" method=\"any\" />'\n                                ];\n                                createElement(renderer.prepVML(markup), null, null, elem);\n                            };\n\n                        // Extend from 0 to 1\n                        firstStop = stops[0];\n                        lastStop = stops[stops.length - 1];\n                        if (firstStop[0] > 0) {\n                            stops.unshift([\n                                0,\n                                firstStop[1]\n                            ]);\n                        }\n                        if (lastStop[0] < 1) {\n                            stops.push([\n                                1,\n                                lastStop[1]\n                            ]);\n                        }\n\n                        // Compute the stops\n                        each(stops, function(stop, i) {\n                            if (regexRgba.test(stop[1])) {\n                                colorObject = H.color(stop[1]);\n                                stopColor = colorObject.get('rgb');\n                                stopOpacity = colorObject.get('a');\n                            } else {\n                                stopColor = stop[1];\n                                stopOpacity = 1;\n                            }\n\n                            // Build the color attribute\n                            colors.push((stop[0] * 100) + '% ' + stopColor);\n\n                            // Only start and end opacities are allowed, so we use the first and the last\n                            if (!i) {\n                                opacity1 = stopOpacity;\n                                color2 = stopColor;\n                            } else {\n                                opacity2 = stopOpacity;\n                                color1 = stopColor;\n                            }\n                        });\n\n                        // Apply the gradient to fills only.\n                        if (prop === 'fill') {\n\n                            // Handle linear gradient angle\n                            if (fillType === 'gradient') {\n                                x1 = gradient.x1 || gradient[0] || 0;\n                                y1 = gradient.y1 || gradient[1] || 0;\n                                x2 = gradient.x2 || gradient[2] || 0;\n                                y2 = gradient.y2 || gradient[3] || 0;\n                                fillAttr = 'angle=\"' + (90 - Math.atan(\n                                    (y2 - y1) / // y vector\n                                    (x2 - x1) // x vector\n                                ) * 180 / Math.PI) + '\"';\n\n                                addFillNode();\n\n                                // Radial (circular) gradient\n                            } else {\n\n                                var r = gradient.r,\n                                    sizex = r * 2,\n                                    sizey = r * 2,\n                                    cx = gradient.cx,\n                                    cy = gradient.cy,\n                                    radialReference = elem.radialReference,\n                                    bBox,\n                                    applyRadialGradient = function() {\n                                        if (radialReference) {\n                                            bBox = wrapper.getBBox();\n                                            cx += (radialReference[0] - bBox.x) / bBox.width - 0.5;\n                                            cy += (radialReference[1] - bBox.y) / bBox.height - 0.5;\n                                            sizex *= radialReference[2] / bBox.width;\n                                            sizey *= radialReference[2] / bBox.height;\n                                        }\n                                        fillAttr = 'src=\"' + H.getOptions().global.VMLRadialGradientURL + '\" ' +\n                                            'size=\"' + sizex + ',' + sizey + '\" ' +\n                                            'origin=\"0.5,0.5\" ' +\n                                            'position=\"' + cx + ',' + cy + '\" ' +\n                                            'color2=\"' + color2 + '\" ';\n\n                                        addFillNode();\n                                    };\n\n                                // Apply radial gradient\n                                if (wrapper.added) {\n                                    applyRadialGradient();\n                                } else {\n                                    // We need to know the bounding box to get the size and position right\n                                    wrapper.onAdd = applyRadialGradient;\n                                }\n\n                                // The fill element's color attribute is broken in IE8 standards mode, so we\n                                // need to set the parent shape's fillcolor attribute instead.\n                                ret = color1;\n                            }\n\n                            // Gradients are not supported for VML stroke, return the first color. #722.\n                        } else {\n                            ret = stopColor;\n                        }\n\n                        // If the color is an rgba color, split it and add a fill node\n                        // to hold the opacity component\n                    } else if (regexRgba.test(color) && elem.tagName !== 'IMG') {\n\n                        colorObject = H.color(color);\n\n                        wrapper[prop + '-opacitySetter'](colorObject.get('a'), prop, elem);\n\n                        ret = colorObject.get('rgb');\n\n\n                    } else {\n                        var propNodes = elem.getElementsByTagName(prop); // 'stroke' or 'fill' node\n                        if (propNodes.length) {\n                            propNodes[0].opacity = 1;\n                            propNodes[0].type = 'solid';\n                        }\n                        ret = color;\n                    }\n\n                    return ret;\n                },\n\n                /**\n                 * Take a VML string and prepare it for either IE8 or IE6/IE7.\n                 * @param {Array} markup A string array of the VML markup to prepare\n                 */\n                prepVML: function(markup) {\n                    var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',\n                        isIE8 = this.isIE8;\n\n                    markup = markup.join('');\n\n                    if (isIE8) { // add xmlns and style inline\n                        markup = markup.replace('/>', ' xmlns=\"urn:schemas-microsoft-com:vml\" />');\n                        if (markup.indexOf('style=\"') === -1) {\n                            markup = markup.replace('/>', ' style=\"' + vmlStyle + '\" />');\n                        } else {\n                            markup = markup.replace('style=\"', 'style=\"' + vmlStyle);\n                        }\n\n                    } else { // add namespace\n                        markup = markup.replace('<', '<hcv:');\n                    }\n\n                    return markup;\n                },\n\n                /**\n                 * Create rotated and aligned text\n                 * @param {String} str\n                 * @param {Number} x\n                 * @param {Number} y\n                 */\n                text: SVGRenderer.prototype.html,\n\n                /**\n                 * Create and return a path element\n                 * @param {Array} path\n                 */\n                path: function(path) {\n                    var attr = {\n                        // subpixel precision down to 0.1 (width and height = 1px)\n                        coordsize: '10 10'\n                    };\n                    if (isArray(path)) {\n                        attr.d = path;\n                    } else if (isObject(path)) { // attributes\n                        extend(attr, path);\n                    }\n                    // create the shape\n                    return this.createElement('shape').attr(attr);\n                },\n\n                /**\n                 * Create and return a circle element. In VML circles are implemented as\n                 * shapes, which is faster than v:oval\n                 * @param {Number} x\n                 * @param {Number} y\n                 * @param {Number} r\n                 */\n                circle: function(x, y, r) {\n                    var circle = this.symbol('circle');\n                    if (isObject(x)) {\n                        r = x.r;\n                        y = x.y;\n                        x = x.x;\n                    }\n                    circle.isCircle = true; // Causes x and y to mean center (#1682)\n                    circle.r = r;\n                    return circle.attr({\n                        x: x,\n                        y: y\n                    });\n                },\n\n                /**\n                 * Create a group using an outer div and an inner v:group to allow rotating\n                 * and flipping. A simple v:group would have problems with positioning\n                 * child HTML elements and CSS clip.\n                 *\n                 * @param {String} name The name of the group\n                 */\n                g: function(name) {\n                    var wrapper,\n                        attribs;\n\n                    // set the class name\n                    if (name) {\n                        attribs = {\n                            'className': 'highcharts-' + name,\n                            'class': 'highcharts-' + name\n                        };\n                    }\n\n                    // the div to hold HTML and clipping\n                    wrapper = this.createElement('div').attr(attribs);\n\n                    return wrapper;\n                },\n\n                /**\n                 * VML override to create a regular HTML image\n                 * @param {String} src\n                 * @param {Number} x\n                 * @param {Number} y\n                 * @param {Number} width\n                 * @param {Number} height\n                 */\n                image: function(src, x, y, width, height) {\n                    var obj = this.createElement('img')\n                        .attr({\n                            src: src\n                        });\n\n                    if (arguments.length > 1) {\n                        obj.attr({\n                            x: x,\n                            y: y,\n                            width: width,\n                            height: height\n                        });\n                    }\n                    return obj;\n                },\n\n                /**\n                 * For rectangles, VML uses a shape for rect to overcome bugs and rotation problems\n                 */\n                createElement: function(nodeName) {\n                    return nodeName === 'rect' ?\n                        this.symbol(nodeName) :\n                        SVGRenderer.prototype.createElement.call(this, nodeName);\n                },\n\n                /**\n                 * In the VML renderer, each child of an inverted div (group) is inverted\n                 * @param {Object} element\n                 * @param {Object} parentNode\n                 */\n                invertChild: function(element, parentNode) {\n                    var ren = this,\n                        parentStyle = parentNode.style,\n                        imgStyle = element.tagName === 'IMG' && element.style; // #1111\n\n                    css(element, {\n                        flip: 'x',\n                        left: pInt(parentStyle.width) - (imgStyle ? pInt(imgStyle.top) : 1),\n                        top: pInt(parentStyle.height) - (imgStyle ? pInt(imgStyle.left) : 1),\n                        rotation: -90\n                    });\n\n                    // Recursively invert child elements, needed for nested composite\n                    // shapes like box plots and error bars. #1680, #1806.\n                    each(element.childNodes, function(child) {\n                        ren.invertChild(child, element);\n                    });\n                },\n\n                /**\n                 * Symbol definitions that override the parent SVG renderer's symbols\n                 *\n                 */\n                symbols: {\n                    // VML specific arc function\n                    arc: function(x, y, w, h, options) {\n                        var start = options.start,\n                            end = options.end,\n                            radius = options.r || w || h,\n                            innerRadius = options.innerR,\n                            cosStart = Math.cos(start),\n                            sinStart = Math.sin(start),\n                            cosEnd = Math.cos(end),\n                            sinEnd = Math.sin(end),\n                            ret;\n\n                        if (end - start === 0) { // no angle, don't show it.\n                            return ['x'];\n                        }\n\n                        ret = [\n                            'wa', // clockwise arc to\n                            x - radius, // left\n                            y - radius, // top\n                            x + radius, // right\n                            y + radius, // bottom\n                            x + radius * cosStart, // start x\n                            y + radius * sinStart, // start y\n                            x + radius * cosEnd, // end x\n                            y + radius * sinEnd // end y\n                        ];\n\n                        if (options.open && !innerRadius) {\n                            ret.push(\n                                'e',\n                                'M',\n                                x, // - innerRadius,\n                                y // - innerRadius\n                            );\n                        }\n\n                        ret.push(\n                            'at', // anti clockwise arc to\n                            x - innerRadius, // left\n                            y - innerRadius, // top\n                            x + innerRadius, // right\n                            y + innerRadius, // bottom\n                            x + innerRadius * cosEnd, // start x\n                            y + innerRadius * sinEnd, // start y\n                            x + innerRadius * cosStart, // end x\n                            y + innerRadius * sinStart, // end y\n                            'x', // finish path\n                            'e' // close\n                        );\n\n                        ret.isArc = true;\n                        return ret;\n\n                    },\n                    // Add circle symbol path. This performs significantly faster than v:oval.\n                    circle: function(x, y, w, h, wrapper) {\n\n                        if (wrapper && defined(wrapper.r)) {\n                            w = h = 2 * wrapper.r;\n                        }\n\n                        // Center correction, #1682\n                        if (wrapper && wrapper.isCircle) {\n                            x -= w / 2;\n                            y -= h / 2;\n                        }\n\n                        // Return the path\n                        return [\n                            'wa', // clockwisearcto\n                            x, // left\n                            y, // top\n                            x + w, // right\n                            y + h, // bottom\n                            x + w, // start x\n                            y + h / 2, // start y\n                            x + w, // end x\n                            y + h / 2, // end y\n                            //'x', // finish path\n                            'e' // close\n                        ];\n                    },\n                    /**\n                     * Add rectangle symbol path which eases rotation and omits arcsize problems\n                     * compared to the built-in VML roundrect shape. When borders are not rounded,\n                     * use the simpler square path, else use the callout path without the arrow.\n                     */\n                    rect: function(x, y, w, h, options) {\n                        return SVGRenderer.prototype.symbols[!defined(options) || !options.r ? 'square' : 'callout'].call(0, x, y, w, h, options);\n                    }\n                }\n            };\n            H.VMLRenderer = VMLRenderer = function() {\n                this.init.apply(this, arguments);\n            };\n            VMLRenderer.prototype = merge(SVGRenderer.prototype, VMLRendererExtension);\n\n            // general renderer\n            H.Renderer = VMLRenderer;\n        }\n\n        // This method is used with exporting in old IE, when emulating SVG (see #2314)\n        SVGRenderer.prototype.measureSpanWidth = function(text, styles) {\n            var measuringSpan = doc.createElement('span'),\n                offsetWidth,\n                textNode = doc.createTextNode(text);\n\n            measuringSpan.appendChild(textNode);\n            css(measuringSpan, styles);\n            this.box.appendChild(measuringSpan);\n            offsetWidth = measuringSpan.offsetWidth;\n            discardElement(measuringSpan); // #2463\n            return offsetWidth;\n        };\n\n\n        /* ****************************************************************************\n         *                                                                            *\n         * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *\n         *                                                                            *\n         *****************************************************************************/\n\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var color = H.color,\n            each = H.each,\n            getTZOffset = H.getTZOffset,\n            isTouchDevice = H.isTouchDevice,\n            merge = H.merge,\n            pick = H.pick,\n            svg = H.svg,\n            win = H.win;\n\n        /* ****************************************************************************\n         * Handle the options                                                         *\n         *****************************************************************************/\n        H.defaultOptions = {\n\n            colors: '#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1'.split(' '),\n\n            symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],\n            lang: {\n                loading: 'Loading...',\n                months: [\n                    'January', 'February', 'March', 'April', 'May', 'June', 'July',\n                    'August', 'September', 'October', 'November', 'December'\n                ],\n                shortMonths: [\n                    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul',\n                    'Aug', 'Sep', 'Oct', 'Nov', 'Dec'\n                ],\n                weekdays: [\n                    'Sunday', 'Monday', 'Tuesday', 'Wednesday',\n                    'Thursday', 'Friday', 'Saturday'\n                ],\n                // invalidDate: '',\n                decimalPoint: '.',\n                numericSymbols: ['k', 'M', 'G', 'T', 'P', 'E'], // SI prefixes used in axis labels\n                resetZoom: 'Reset zoom',\n                resetZoomTitle: 'Reset zoom level 1:1',\n                thousandsSep: ' '\n            },\n            global: {\n                useUTC: true,\n                //timezoneOffset: 0,\n\n                VMLRadialGradientURL: 'http://code.highcharts.com/5.0.12/gfx/vml-radial-gradient.png'\n\n            },\n            chart: {\n                //animation: true,\n                //alignTicks: false,\n                //reflow: true,\n                //className: null,\n                //events: { load, selection },\n                //margin: [null],\n                //marginTop: null,\n                //marginRight: null,\n                //marginBottom: null,\n                //marginLeft: null,\n                borderRadius: 0,\n\n                defaultSeriesType: 'line',\n                ignoreHiddenSeries: true,\n                //inverted: false,\n                spacing: [10, 10, 15, 10],\n                //spacingTop: 10,\n                //spacingRight: 10,\n                //spacingBottom: 15,\n                //spacingLeft: 10,\n                //zoomType: ''\n                resetZoomButton: {\n                    theme: {\n                        zIndex: 20\n                    },\n                    position: {\n                        align: 'right',\n                        x: -10,\n                        //verticalAlign: 'top',\n                        y: 10\n                    }\n                    // relativeTo: 'plot'\n                },\n                width: null,\n                height: null,\n\n\n                borderColor: '#335cad',\n                //borderWidth: 0,\n                //style: {\n                //\tfontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif', // default font\n                //\tfontSize: '12px'\n                //},\n                backgroundColor: '#ffffff',\n                //plotBackgroundColor: null,\n                plotBorderColor: '#cccccc'\n                //plotBorderWidth: 0,\n                //plotShadow: false\n\n            },\n            title: {\n                text: 'Chart title',\n                align: 'center',\n                // floating: false,\n                margin: 15,\n                // x: 0,\n                // verticalAlign: 'top',\n                // y: null,\n                // style: {}, // defined inline\n                widthAdjust: -44\n\n            },\n            subtitle: {\n                text: '',\n                align: 'center',\n                // floating: false\n                // x: 0,\n                // verticalAlign: 'top',\n                // y: null,\n                // style: {}, // defined inline\n                widthAdjust: -44\n            },\n\n            plotOptions: {},\n            labels: {\n                //items: [],\n                style: {\n                    //font: defaultFont,\n                    position: 'absolute',\n                    color: '#333333'\n                }\n            },\n            legend: {\n                enabled: true,\n                align: 'center',\n                //floating: false,\n                layout: 'horizontal',\n                labelFormatter: function() {\n                    return this.name;\n                },\n                //borderWidth: 0,\n                borderColor: '#999999',\n                borderRadius: 0,\n                navigation: {\n\n                    activeColor: '#003399',\n                    inactiveColor: '#cccccc'\n\n                    // animation: true,\n                    // arrowSize: 12\n                    // style: {} // text styles\n                },\n                // margin: 20,\n                // reversed: false,\n                // backgroundColor: null,\n                /*style: {\n                \tpadding: '5px'\n                },*/\n\n                itemStyle: {\n                    color: '#333333',\n                    fontSize: '12px',\n                    fontWeight: 'bold',\n                    textOverflow: 'ellipsis'\n                },\n                itemHoverStyle: {\n                    //cursor: 'pointer', removed as of #601\n                    color: '#000000'\n                },\n                itemHiddenStyle: {\n                    color: '#cccccc'\n                },\n                shadow: false,\n\n                itemCheckboxStyle: {\n                    position: 'absolute',\n                    width: '13px', // for IE precision\n                    height: '13px'\n                },\n                // itemWidth: undefined,\n                squareSymbol: true,\n                // symbolRadius: 0,\n                // symbolWidth: 16,\n                symbolPadding: 5,\n                verticalAlign: 'bottom',\n                // width: undefined,\n                x: 0,\n                y: 0,\n                title: {\n                    //text: null,\n\n                    style: {\n                        fontWeight: 'bold'\n                    }\n\n                }\n            },\n\n            loading: {\n                // hideDuration: 100,\n                // showDuration: 0,\n\n                labelStyle: {\n                    fontWeight: 'bold',\n                    position: 'relative',\n                    top: '45%'\n                },\n                style: {\n                    position: 'absolute',\n                    backgroundColor: '#ffffff',\n                    opacity: 0.5,\n                    textAlign: 'center'\n                }\n\n            },\n\n            tooltip: {\n                enabled: true,\n                animation: svg,\n                //crosshairs: null,\n                borderRadius: 3,\n                dateTimeLabelFormats: {\n                    millisecond: '%A, %b %e, %H:%M:%S.%L',\n                    second: '%A, %b %e, %H:%M:%S',\n                    minute: '%A, %b %e, %H:%M',\n                    hour: '%A, %b %e, %H:%M',\n                    day: '%A, %b %e, %Y',\n                    week: 'Week from %A, %b %e, %Y',\n                    month: '%B %Y',\n                    year: '%Y'\n                },\n                footerFormat: '',\n                //formatter: defaultFormatter,\n                /* todo: em font-size when finished comparing against HC4\n                headerFormat: '<span style=\"font-size: 0.85em\">{point.key}</span><br/>',\n                */\n                padding: 8,\n\n                //shape: 'callout',\n                //shared: false,\n                snap: isTouchDevice ? 25 : 10,\n\n                backgroundColor: color('#f7f7f7').setOpacity(0.85).get(),\n                borderWidth: 1,\n                headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.y}</b><br/>',\n                shadow: true,\n                style: {\n                    color: '#333333',\n                    cursor: 'default',\n                    fontSize: '12px',\n                    pointerEvents: 'none', // #1686 http://caniuse.com/#feat=pointer-events\n                    whiteSpace: 'nowrap'\n                }\n\n                //xDateFormat: '%A, %b %e, %Y',\n                //valueDecimals: null,\n                //valuePrefix: '',\n                //valueSuffix: ''\n            },\n\n            credits: {\n                enabled: true,\n                href: 'http://www.highcharts.com',\n                position: {\n                    align: 'right',\n                    x: -10,\n                    verticalAlign: 'bottom',\n                    y: -5\n                },\n\n                style: {\n                    cursor: 'pointer',\n                    color: '#999999',\n                    fontSize: '9px'\n                },\n\n                text: 'Highcharts.com'\n            }\n        };\n\n\n\n        /**\n         * Sets the getTimezoneOffset function. If the timezone option is set, a default\n         * getTimezoneOffset function with that timezone is returned. If not, the\n         * specified getTimezoneOffset function is returned. If neither are specified,\n         * undefined is returned.\n         * @return {function} a getTimezoneOffset function or undefined\n         */\n        function getTimezoneOffsetOption() {\n            var globalOptions = H.defaultOptions.global,\n                moment = win.moment;\n\n            if (globalOptions.timezone) {\n                if (!moment) {\n                    // getTimezoneOffset-function stays undefined because it depends on\n                    // Moment.js\n                    H.error(25);\n\n                } else {\n                    return function(timestamp) {\n                        return -moment.tz(\n                            timestamp,\n                            globalOptions.timezone\n                        ).utcOffset();\n                    };\n                }\n            }\n\n            // If not timezone is set, look for the getTimezoneOffset callback\n            return globalOptions.useUTC && globalOptions.getTimezoneOffset;\n        }\n\n        /**\n         * Set the time methods globally based on the useUTC option. Time method can be\n         *   either local time or UTC (default). It is called internally on initiating\n         *   Highcharts and after running `Highcharts.setOptions`.\n         *\n         * @private\n         */\n        function setTimeMethods() {\n            var globalOptions = H.defaultOptions.global,\n                Date,\n                useUTC = globalOptions.useUTC,\n                GET = useUTC ? 'getUTC' : 'get',\n                SET = useUTC ? 'setUTC' : 'set';\n\n            H.Date = Date = globalOptions.Date || win.Date; // Allow using a different Date class\n            Date.hcTimezoneOffset = useUTC && globalOptions.timezoneOffset;\n            Date.hcGetTimezoneOffset = getTimezoneOffsetOption();\n            Date.hcMakeTime = function(year, month, date, hours, minutes, seconds) {\n                var d;\n                if (useUTC) {\n                    d = Date.UTC.apply(0, arguments);\n                    d += getTZOffset(d);\n                } else {\n                    d = new Date(\n                        year,\n                        month,\n                        pick(date, 1),\n                        pick(hours, 0),\n                        pick(minutes, 0),\n                        pick(seconds, 0)\n                    ).getTime();\n                }\n                return d;\n            };\n            each(['Minutes', 'Hours', 'Day', 'Date', 'Month', 'FullYear'], function(s) {\n                Date['hcGet' + s] = GET + s;\n            });\n            each(['Milliseconds', 'Seconds', 'Minutes', 'Hours', 'Date', 'Month', 'FullYear'], function(s) {\n                Date['hcSet' + s] = SET + s;\n            });\n        }\n\n        /**\n         * Merge the default options with custom options and return the new options\n         * structure. Commonly used for defining reusable templates.\n         *\n         * @function #setOptions\n         * @memberOf  Highcharts\n         * @sample highcharts/global/useutc-false Setting a global option\n         * @sample highcharts/members/setoptions Applying a global theme\n         * @param {Object} options The new custom chart options.\n         * @returns {Object} Updated options.\n         */\n        H.setOptions = function(options) {\n\n            // Copy in the default options\n            H.defaultOptions = merge(true, H.defaultOptions, options);\n\n            // Apply UTC\n            setTimeMethods();\n\n            return H.defaultOptions;\n        };\n\n        /**\n         * Get the updated default options. Until 3.0.7, merely exposing defaultOptions for outside modules\n         * wasn't enough because the setOptions method created a new object.\n         */\n        H.getOptions = function() {\n            return H.defaultOptions;\n        };\n\n\n        // Series defaults\n        H.defaultPlotOptions = H.defaultOptions.plotOptions;\n\n        // set the default time methods\n        setTimeMethods();\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var correctFloat = H.correctFloat,\n            defined = H.defined,\n            destroyObjectProperties = H.destroyObjectProperties,\n            isNumber = H.isNumber,\n            merge = H.merge,\n            pick = H.pick,\n            deg2rad = H.deg2rad;\n\n        /**\n         * The Tick class\n         */\n        H.Tick = function(axis, pos, type, noLabel) {\n            this.axis = axis;\n            this.pos = pos;\n            this.type = type || '';\n            this.isNew = true;\n            this.isNewLabel = true;\n\n            if (!type && !noLabel) {\n                this.addLabel();\n            }\n        };\n\n        H.Tick.prototype = {\n            /**\n             * Write the tick label\n             */\n            addLabel: function() {\n                var tick = this,\n                    axis = tick.axis,\n                    options = axis.options,\n                    chart = axis.chart,\n                    categories = axis.categories,\n                    names = axis.names,\n                    pos = tick.pos,\n                    labelOptions = options.labels,\n                    str,\n                    tickPositions = axis.tickPositions,\n                    isFirst = pos === tickPositions[0],\n                    isLast = pos === tickPositions[tickPositions.length - 1],\n                    value = categories ?\n                    pick(categories[pos], names[pos], pos) :\n                    pos,\n                    label = tick.label,\n                    tickPositionInfo = tickPositions.info,\n                    dateTimeLabelFormat;\n\n                // Set the datetime label format. If a higher rank is set for this position, use that. If not,\n                // use the general format.\n                if (axis.isDatetimeAxis && tickPositionInfo) {\n                    dateTimeLabelFormat =\n                        options.dateTimeLabelFormats[\n                            tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName\n                        ];\n                }\n                // set properties for access in render method\n                tick.isFirst = isFirst;\n                tick.isLast = isLast;\n\n                // get the string\n                str = axis.labelFormatter.call({\n                    axis: axis,\n                    chart: chart,\n                    isFirst: isFirst,\n                    isLast: isLast,\n                    dateTimeLabelFormat: dateTimeLabelFormat,\n                    value: axis.isLog ? correctFloat(axis.lin2log(value)) : value\n                });\n\n                // prepare CSS\n                //css = width && { width: Math.max(1, Math.round(width - 2 * (labelOptions.padding || 10))) + 'px' };\n\n                // first call\n                if (!defined(label)) {\n\n                    tick.label = label =\n                        defined(str) && labelOptions.enabled ?\n                        chart.renderer.text(\n                            str,\n                            0,\n                            0,\n                            labelOptions.useHTML\n                        )\n\n                        // without position absolute, IE export sometimes is wrong\n                        .css(merge(labelOptions.style))\n\n                        .add(axis.labelGroup) :\n                        null;\n                    tick.labelLength = label && label.getBBox().width; // Un-rotated length\n                    tick.rotation = 0; // Base value to detect change for new calls to getBBox\n\n                    // update\n                } else if (label) {\n                    label.attr({\n                        text: str\n                    });\n                }\n            },\n\n            /**\n             * Get the offset height or width of the label\n             */\n            getLabelSize: function() {\n                return this.label ?\n                    this.label.getBBox()[this.axis.horiz ? 'height' : 'width'] :\n                    0;\n            },\n\n            /**\n             * Handle the label overflow by adjusting the labels to the left and right edge, or\n             * hide them if they collide into the neighbour label.\n             */\n            handleOverflow: function(xy) {\n                var axis = this.axis,\n                    pxPos = xy.x,\n                    chartWidth = axis.chart.chartWidth,\n                    spacing = axis.chart.spacing,\n                    leftBound = pick(axis.labelLeft, Math.min(axis.pos, spacing[3])),\n                    rightBound = pick(axis.labelRight, Math.max(axis.pos + axis.len, chartWidth - spacing[1])),\n                    label = this.label,\n                    rotation = this.rotation,\n                    factor = {\n                        left: 0,\n                        center: 0.5,\n                        right: 1\n                    }[axis.labelAlign],\n                    labelWidth = label.getBBox().width,\n                    slotWidth = axis.getSlotWidth(),\n                    modifiedSlotWidth = slotWidth,\n                    xCorrection = factor,\n                    goRight = 1,\n                    leftPos,\n                    rightPos,\n                    textWidth,\n                    css = {};\n\n                // Check if the label overshoots the chart spacing box. If it does, move it.\n                // If it now overshoots the slotWidth, add ellipsis.\n                if (!rotation) {\n                    leftPos = pxPos - factor * labelWidth;\n                    rightPos = pxPos + (1 - factor) * labelWidth;\n\n                    if (leftPos < leftBound) {\n                        modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;\n                    } else if (rightPos > rightBound) {\n                        modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;\n                        goRight = -1;\n                    }\n\n                    modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth); // #4177\n                    if (modifiedSlotWidth < slotWidth && axis.labelAlign === 'center') {\n                        xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection *\n                            (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));\n                    }\n                    // If the label width exceeds the available space, set a text width to be\n                    // picked up below. Also, if a width has been set before, we need to set a new\n                    // one because the reported labelWidth will be limited by the box (#3938).\n                    if (labelWidth > modifiedSlotWidth || (axis.autoRotation && (label.styles || {}).width)) {\n                        textWidth = modifiedSlotWidth;\n                    }\n\n                    // Add ellipsis to prevent rotated labels to be clipped against the edge of the chart\n                } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {\n                    textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound);\n                } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {\n                    textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad));\n                }\n\n                if (textWidth) {\n                    css.width = textWidth;\n                    if (!(axis.options.labels.style || {}).textOverflow) {\n                        css.textOverflow = 'ellipsis';\n                    }\n                    label.css(css);\n                }\n            },\n\n            /**\n             * Get the x and y position for ticks and labels\n             */\n            getPosition: function(horiz, pos, tickmarkOffset, old) {\n                var axis = this.axis,\n                    chart = axis.chart,\n                    cHeight = (old && chart.oldChartHeight) || chart.chartHeight;\n\n                return {\n                    x: horiz ?\n                        axis.translate(pos + tickmarkOffset, null, null, old) + axis.transB : axis.left + axis.offset +\n                        (axis.opposite ?\n                            ((old && chart.oldChartWidth) || chart.chartWidth) - axis.right - axis.left :\n                            0\n                        ),\n\n                    y: horiz ?\n                        cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : cHeight - axis.translate(pos + tickmarkOffset, null, null, old) - axis.transB\n                };\n\n            },\n\n            /**\n             * Get the x, y position of the tick label\n             */\n            getLabelPosition: function(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {\n                var axis = this.axis,\n                    transA = axis.transA,\n                    reversed = axis.reversed,\n                    staggerLines = axis.staggerLines,\n                    rotCorr = axis.tickRotCorr || {\n                        x: 0,\n                        y: 0\n                    },\n                    yOffset = labelOptions.y,\n                    line;\n\n                if (!defined(yOffset)) {\n                    if (axis.side === 0) {\n                        yOffset = label.rotation ? -8 : -label.getBBox().height;\n                    } else if (axis.side === 2) {\n                        yOffset = rotCorr.y + 8;\n                    } else {\n                        // #3140, #3140\n                        yOffset = Math.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);\n                    }\n                }\n\n                x = x + labelOptions.x + rotCorr.x - (tickmarkOffset && horiz ?\n                    tickmarkOffset * transA * (reversed ? -1 : 1) : 0);\n                y = y + yOffset - (tickmarkOffset && !horiz ?\n                    tickmarkOffset * transA * (reversed ? 1 : -1) : 0);\n\n                // Correct for staggered labels\n                if (staggerLines) {\n                    line = (index / (step || 1) % staggerLines);\n                    if (axis.opposite) {\n                        line = staggerLines - line - 1;\n                    }\n                    y += line * (axis.labelOffset / staggerLines);\n                }\n\n                return {\n                    x: x,\n                    y: Math.round(y)\n                };\n            },\n\n            /**\n             * Extendible method to return the path of the marker\n             */\n            getMarkPath: function(x, y, tickLength, tickWidth, horiz, renderer) {\n                return renderer.crispLine([\n                    'M',\n                    x,\n                    y,\n                    'L',\n                    x + (horiz ? 0 : -tickLength),\n                    y + (horiz ? tickLength : 0)\n                ], tickWidth);\n            },\n\n            /**\n             * Renders the gridLine.\n             * @param  {Boolean} old         Whether or not the tick is old\n             * @param  {number} opacity      The opacity of the grid line\n             * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1\n             * @return {undefined}\n             */\n            renderGridLine: function(old, opacity, reverseCrisp) {\n                var tick = this,\n                    axis = tick.axis,\n                    options = axis.options,\n                    gridLine = tick.gridLine,\n                    gridLinePath,\n                    attribs = {},\n                    pos = tick.pos,\n                    type = tick.type,\n                    tickmarkOffset = axis.tickmarkOffset,\n                    renderer = axis.chart.renderer;\n\n\n                var gridPrefix = type ? type + 'Grid' : 'grid',\n                    gridLineWidth = options[gridPrefix + 'LineWidth'],\n                    gridLineColor = options[gridPrefix + 'LineColor'],\n                    dashStyle = options[gridPrefix + 'LineDashStyle'];\n\n\n                if (!gridLine) {\n\n                    attribs.stroke = gridLineColor;\n                    attribs['stroke-width'] = gridLineWidth;\n                    if (dashStyle) {\n                        attribs.dashstyle = dashStyle;\n                    }\n\n                    if (!type) {\n                        attribs.zIndex = 1;\n                    }\n                    if (old) {\n                        attribs.opacity = 0;\n                    }\n                    tick.gridLine = gridLine = renderer.path()\n                        .attr(attribs)\n                        .addClass(\n                            'highcharts-' + (type ? type + '-' : '') + 'grid-line'\n                        )\n                        .add(axis.gridGroup);\n                }\n\n                // If the parameter 'old' is set, the current call will be followed\n                // by another call, therefore do not do any animations this time\n                if (!old && gridLine) {\n                    gridLinePath = axis.getPlotLinePath(\n                        pos + tickmarkOffset,\n                        gridLine.strokeWidth() * reverseCrisp,\n                        old, true\n                    );\n                    if (gridLinePath) {\n                        gridLine[tick.isNew ? 'attr' : 'animate']({\n                            d: gridLinePath,\n                            opacity: opacity\n                        });\n                    }\n                }\n            },\n\n            /**\n             * Renders the tick mark.\n             * @param  {Object} xy           The position vector of the mark\n             * @param  {number} xy.x         The x position of the mark\n             * @param  {number} xy.y         The y position of the mark\n             * @param  {number} opacity      The opacity of the mark\n             * @param  {number} reverseCrisp Modifier for avoiding overlapping 1 or -1\n             * @return {undefined}\n             */\n            renderMark: function(xy, opacity, reverseCrisp) {\n                var tick = this,\n                    axis = tick.axis,\n                    options = axis.options,\n                    renderer = axis.chart.renderer,\n                    type = tick.type,\n                    tickPrefix = type ? type + 'Tick' : 'tick',\n                    tickSize = axis.tickSize(tickPrefix),\n                    mark = tick.mark,\n                    isNewMark = !mark,\n                    x = xy.x,\n                    y = xy.y;\n\n\n                var tickWidth = pick(\n                        options[tickPrefix + 'Width'], !type && axis.isXAxis ? 1 : 0\n                    ), // X axis defaults to 1\n                    tickColor = options[tickPrefix + 'Color'];\n\n\n                if (tickSize) {\n\n                    // negate the length\n                    if (axis.opposite) {\n                        tickSize[0] = -tickSize[0];\n                    }\n\n                    // First time, create it\n                    if (isNewMark) {\n                        tick.mark = mark = renderer.path()\n                            .addClass('highcharts-' + (type ? type + '-' : '') + 'tick')\n                            .add(axis.axisGroup);\n\n\n                        mark.attr({\n                            stroke: tickColor,\n                            'stroke-width': tickWidth\n                        });\n\n                    }\n                    mark[isNewMark ? 'attr' : 'animate']({\n                        d: tick.getMarkPath(\n                            x,\n                            y,\n                            tickSize[0],\n                            mark.strokeWidth() * reverseCrisp,\n                            axis.horiz,\n                            renderer),\n                        opacity: opacity\n                    });\n\n                }\n            },\n\n            /**\n             * Renders the tick label.\n             * Note: The label should already be created in init(), so it should only\n             * have to be moved into place.\n             * @param  {Object} xy      The position vector of the label\n             * @param  {number} xy.x    The x position of the label\n             * @param  {number} xy.y    The y position of the label\n             * @param  {Boolean} old    Whether or not the tick is old\n             * @param  {number} opacity The opacity of the label\n             * @param  {number} index   The index of the tick\n             * @return {undefined}\n             */\n            renderLabel: function(xy, old, opacity, index) {\n                var tick = this,\n                    axis = tick.axis,\n                    horiz = axis.horiz,\n                    options = axis.options,\n                    label = tick.label,\n                    labelOptions = options.labels,\n                    step = labelOptions.step,\n                    tickmarkOffset = axis.tickmarkOffset,\n                    show = true,\n                    x = xy.x,\n                    y = xy.y;\n                if (label && isNumber(x)) {\n                    label.xy = xy = tick.getLabelPosition(\n                        x,\n                        y,\n                        label,\n                        horiz,\n                        labelOptions,\n                        tickmarkOffset,\n                        index,\n                        step\n                    );\n\n                    // Apply show first and show last. If the tick is both first and\n                    // last, it is a single centered tick, in which case we show the\n                    // label anyway (#2100).\n                    if (\n                        (\n                            tick.isFirst &&\n                            !tick.isLast &&\n                            !pick(options.showFirstLabel, 1)\n                        ) ||\n                        (\n                            tick.isLast &&\n                            !tick.isFirst &&\n                            !pick(options.showLastLabel, 1)\n                        )\n                    ) {\n                        show = false;\n\n                        // Handle label overflow and show or hide accordingly\n                    } else if (horiz && !axis.isRadial && !labelOptions.step &&\n                        !labelOptions.rotation && !old && opacity !== 0) {\n                        tick.handleOverflow(xy);\n                    }\n\n                    // apply step\n                    if (step && index % step) {\n                        // show those indices dividable by step\n                        show = false;\n                    }\n\n                    // Set the new position, and show or hide\n                    if (show && isNumber(xy.y)) {\n                        xy.opacity = opacity;\n                        label[tick.isNewLabel ? 'attr' : 'animate'](xy);\n                        tick.isNewLabel = false;\n                    } else {\n                        label.attr('y', -9999); // #1338\n                        tick.isNewLabel = true;\n                    }\n                    tick.isNew = false;\n                }\n            },\n\n            /**\n             * Put everything in place\n             *\n             * @param index {Number}\n             * @param old {Boolean} Use old coordinates to prepare an animation into new\n             *                      position\n             */\n            render: function(index, old, opacity) {\n                var tick = this,\n                    axis = tick.axis,\n                    horiz = axis.horiz,\n                    pos = tick.pos,\n                    tickmarkOffset = axis.tickmarkOffset,\n                    xy = tick.getPosition(horiz, pos, tickmarkOffset, old),\n                    x = xy.x,\n                    y = xy.y,\n                    reverseCrisp = ((horiz && x === axis.pos + axis.len) ||\n                        (!horiz && y === axis.pos)) ? -1 : 1; // #1480, #1687\n\n                opacity = pick(opacity, 1);\n                this.isActive = true;\n\n                // Create the grid line\n                this.renderGridLine(old, opacity, reverseCrisp);\n\n                // create the tick mark\n                this.renderMark(xy, opacity, reverseCrisp);\n\n                // the label is created on init - now move it into place\n                this.renderLabel(xy, old, opacity, index);\n            },\n\n            /**\n             * Destructor for the tick prototype\n             */\n            destroy: function() {\n                destroyObjectProperties(this, this.axis);\n            }\n        };\n\n    }(Highcharts));\n    var Axis = (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n\n        var addEvent = H.addEvent,\n            animObject = H.animObject,\n            arrayMax = H.arrayMax,\n            arrayMin = H.arrayMin,\n            color = H.color,\n            correctFloat = H.correctFloat,\n            defaultOptions = H.defaultOptions,\n            defined = H.defined,\n            deg2rad = H.deg2rad,\n            destroyObjectProperties = H.destroyObjectProperties,\n            each = H.each,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            format = H.format,\n            getMagnitude = H.getMagnitude,\n            grep = H.grep,\n            inArray = H.inArray,\n            isArray = H.isArray,\n            isNumber = H.isNumber,\n            isString = H.isString,\n            merge = H.merge,\n            normalizeTickInterval = H.normalizeTickInterval,\n            objectEach = H.objectEach,\n            pick = H.pick,\n            removeEvent = H.removeEvent,\n            splat = H.splat,\n            syncTimeout = H.syncTimeout,\n            Tick = H.Tick;\n\n        /**\n         * Create a new axis object. Called internally when instanciating a new chart or\n         * adding axes by {@link Highcharts.Chart#addAxis}.\n         *\n         * A chart can have from 0 axes (pie chart) to multiples. In a normal, single\n         * series cartesian chart, there is one X axis and one Y axis.\n         * \n         * The X axis or axes are referenced by {@link Highcharts.Chart.xAxis}, which is\n         * an array of Axis objects. If there is only one axis, it can be referenced\n         * through `chart.xAxis[0]`, and multiple axes have increasing indices. The same\n         * pattern goes for Y axes.\n         * \n         * If you need to get the axes from a series object, use the `series.xAxis` and\n         * `series.yAxis` properties. These are not arrays, as one series can only be\n         * associated to one X and one Y axis.\n         * \n         * A third way to reference the axis programmatically is by `id`. Add an `id` in\n         * the axis configuration options, and get the axis by\n         * {@link Highcharts.Chart#get}.\n         * \n         * Configuration options for the axes are given in options.xAxis and\n         * options.yAxis.\n         * \n         * @class Highcharts.Axis\n         * @memberOf Highcharts\n         * @param {Highcharts.Chart} chart - The Chart instance to apply the axis on.\n         * @param {Object} options - Axis options\n         */\n        var Axis = function() {\n            this.init.apply(this, arguments);\n        };\n\n        H.extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {\n\n            /**\n             * Default options for the X axis - the Y axis has extended defaults.\n             *\n             * @private\n             * @type {Object}\n             */\n            defaultOptions: {\n                // allowDecimals: null,\n                // alternateGridColor: null,\n                // categories: [],\n                dateTimeLabelFormats: {\n                    millisecond: '%H:%M:%S.%L',\n                    second: '%H:%M:%S',\n                    minute: '%H:%M',\n                    hour: '%H:%M',\n                    day: '%e. %b',\n                    week: '%e. %b',\n                    month: '%b \\'%y',\n                    year: '%Y'\n                },\n                endOnTick: false,\n                // reversed: false,\n\n                labels: {\n                    enabled: true,\n                    // rotation: 0,\n                    // align: 'center',\n                    // step: null,\n\n                    style: {\n                        color: '#666666',\n                        cursor: 'default',\n                        fontSize: '11px'\n                    },\n\n                    x: 0\n                    //y: undefined\n                    /*formatter: function () {\n                    \treturn this.value;\n                    },*/\n                },\n                //linkedTo: null,\n                //max: undefined,\n                //min: undefined,\n                minPadding: 0.01,\n                maxPadding: 0.01,\n                //minRange: null,\n                //minorTickInterval: null,\n                minorTickLength: 2,\n                minorTickPosition: 'outside', // inside or outside\n                //opposite: false,\n                //offset: 0,\n                //plotBands: [{\n                //\tevents: {},\n                //\tzIndex: 1,\n                //\tlabels: { align, x, verticalAlign, y, style, rotation, textAlign }\n                //}],\n                //plotLines: [{\n                //\tevents: {}\n                //  dashStyle: {}\n                //\tzIndex:\n                //\tlabels: { align, x, verticalAlign, y, style, rotation, textAlign }\n                //}],\n                //reversed: false,\n                // showFirstLabel: true,\n                // showLastLabel: true,\n                startOfWeek: 1,\n                startOnTick: false,\n                //tickInterval: null,\n                tickLength: 10,\n                tickmarkPlacement: 'between', // on or between\n                tickPixelInterval: 100,\n                tickPosition: 'outside',\n                title: {\n                    //text: null,\n                    align: 'middle', // low, middle or high\n                    //margin: 0 for horizontal, 10 for vertical axes,\n                    // reserveSpace: true,\n                    //rotation: 0,\n                    //side: 'outside',\n\n                    style: {\n                        color: '#666666'\n                    }\n\n                    //x: 0,\n                    //y: 0\n                },\n                type: 'linear', // linear, logarithmic or datetime\n                //visible: true\n\n                minorGridLineColor: '#f2f2f2',\n                // minorGridLineDashStyle: null,\n                minorGridLineWidth: 1,\n                minorTickColor: '#999999',\n                //minorTickWidth: 0,\n                lineColor: '#ccd6eb',\n                lineWidth: 1,\n                gridLineColor: '#e6e6e6',\n                // gridLineDashStyle: 'solid',\n                // gridLineWidth: 0,\n                tickColor: '#ccd6eb'\n                // tickWidth: 1\n\n            },\n\n            /**\n             * This options set extends the defaultOptions for Y axes.\n             *\n             * @private\n             * @type {Object}\n             */\n            defaultYAxisOptions: {\n                endOnTick: true,\n                tickPixelInterval: 72,\n                showLastLabel: true,\n                labels: {\n                    x: -8\n                },\n                maxPadding: 0.05,\n                minPadding: 0.05,\n                startOnTick: true,\n                title: {\n                    rotation: 270,\n                    text: 'Values'\n                },\n                stackLabels: {\n                    enabled: false,\n                    //align: dynamic,\n                    //y: dynamic,\n                    //x: dynamic,\n                    //verticalAlign: dynamic,\n                    //textAlign: dynamic,\n                    //rotation: 0,\n                    formatter: function() {\n                        return H.numberFormat(this.total, -1);\n                    },\n\n                    style: {\n                        fontSize: '11px',\n                        fontWeight: 'bold',\n                        color: '#000000',\n                        textOutline: '1px contrast'\n                    }\n\n                },\n\n                gridLineWidth: 1,\n                lineWidth: 0\n                // tickWidth: 0\n\n            },\n\n            /**\n             * These options extend the defaultOptions for left axes.\n             * \n             * @private\n             * @type {Object}\n             */\n            defaultLeftAxisOptions: {\n                labels: {\n                    x: -15\n                },\n                title: {\n                    rotation: 270\n                }\n            },\n\n            /**\n             * These options extend the defaultOptions for right axes.\n             *\n             * @private\n             * @type {Object}\n             */\n            defaultRightAxisOptions: {\n                labels: {\n                    x: 15\n                },\n                title: {\n                    rotation: 90\n                }\n            },\n\n            /**\n             * These options extend the defaultOptions for bottom axes.\n             *\n             * @private\n             * @type {Object}\n             */\n            defaultBottomAxisOptions: {\n                labels: {\n                    autoRotation: [-45],\n                    x: 0\n                    // overflow: undefined,\n                    // staggerLines: null\n                },\n                title: {\n                    rotation: 0\n                }\n            },\n            /**\n             * These options extend the defaultOptions for top axes.\n             *\n             * @private\n             * @type {Object}\n             */\n            defaultTopAxisOptions: {\n                labels: {\n                    autoRotation: [-45],\n                    x: 0\n                    // overflow: undefined\n                    // staggerLines: null\n                },\n                title: {\n                    rotation: 0\n                }\n            },\n\n            /**\n             * Initialize the axis\n             */\n            init: function(chart, userOptions) {\n\n\n                var isXAxis = userOptions.isX,\n                    axis = this;\n\n                axis.chart = chart;\n\n                // Flag, is the axis horizontal\n                axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis;\n\n                // Flag, isXAxis\n                axis.isXAxis = isXAxis;\n                axis.coll = axis.coll || (isXAxis ? 'xAxis' : 'yAxis');\n\n                axis.opposite = userOptions.opposite; // needed in setOptions\n                axis.side = userOptions.side || (axis.horiz ?\n                    (axis.opposite ? 0 : 2) : // top : bottom\n                    (axis.opposite ? 1 : 3)); // right : left\n\n                axis.setOptions(userOptions);\n\n\n                var options = this.options,\n                    type = options.type,\n                    isDatetimeAxis = type === 'datetime';\n\n                axis.labelFormatter = options.labels.formatter ||\n                    axis.defaultLabelFormatter; // can be overwritten by dynamic format\n\n\n                // Flag, stagger lines or not\n                axis.userOptions = userOptions;\n\n                //axis.axisTitleMargin = undefined,// = options.title.margin,\n                axis.minPixelPadding = 0;\n\n                axis.reversed = options.reversed;\n                axis.visible = options.visible !== false;\n                axis.zoomEnabled = options.zoomEnabled !== false;\n\n                // Initial categories\n                axis.hasNames = type === 'category' || options.categories === true;\n                axis.categories = options.categories || axis.hasNames;\n                axis.names = axis.names || []; // Preserve on update (#3830)\n\n                // Elements\n                //axis.axisGroup = undefined;\n                //axis.gridGroup = undefined;\n                //axis.axisTitle = undefined;\n                //axis.axisLine = undefined;\n\n                // Placeholder for plotlines and plotbands groups\n                axis.plotLinesAndBandsGroups = {};\n\n                // Shorthand types\n                axis.isLog = type === 'logarithmic';\n                axis.isDatetimeAxis = isDatetimeAxis;\n                axis.positiveValuesOnly = axis.isLog && !axis.allowNegativeLog;\n\n                // Flag, if axis is linked to another axis\n                axis.isLinked = defined(options.linkedTo);\n                // Linked axis.\n                //axis.linkedParent = undefined;\n\n                // Major ticks\n                axis.ticks = {};\n                axis.labelEdge = [];\n                // Minor ticks\n                axis.minorTicks = {};\n\n                // List of plotLines/Bands\n                axis.plotLinesAndBands = [];\n\n                // Alternate bands\n                axis.alternateBands = {};\n\n                // Axis metrics\n                //axis.left = undefined;\n                //axis.top = undefined;\n                //axis.width = undefined;\n                //axis.height = undefined;\n                //axis.bottom = undefined;\n                //axis.right = undefined;\n                //axis.transA = undefined;\n                //axis.transB = undefined;\n                //axis.oldTransA = undefined;\n                axis.len = 0;\n                //axis.oldMin = undefined;\n                //axis.oldMax = undefined;\n                //axis.oldUserMin = undefined;\n                //axis.oldUserMax = undefined;\n                //axis.oldAxisLength = undefined;\n                axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;\n                axis.range = options.range;\n                axis.offset = options.offset || 0;\n\n\n                // Dictionary for stacks\n                axis.stacks = {};\n                axis.oldStacks = {};\n                axis.stacksTouched = 0;\n\n                // Min and max in the data\n                //axis.dataMin = undefined,\n                //axis.dataMax = undefined,\n\n                // The axis range\n                axis.max = null;\n                axis.min = null;\n\n                // User set min and max\n                //axis.userMin = undefined,\n                //axis.userMax = undefined,\n\n                // Crosshair options\n                axis.crosshair = pick(\n                    options.crosshair,\n                    splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1],\n                    false\n                );\n\n                var events = axis.options.events;\n\n                // Register. Don't add it again on Axis.update().\n                if (inArray(axis, chart.axes) === -1) { // \n                    if (isXAxis) { // #2713\n                        chart.axes.splice(chart.xAxis.length, 0, axis);\n                    } else {\n                        chart.axes.push(axis);\n                    }\n\n                    chart[axis.coll].push(axis);\n                }\n\n                axis.series = axis.series || []; // populated by Series\n\n                // inverted charts have reversed xAxes as default\n                if (chart.inverted && !axis.isZAxis && isXAxis && axis.reversed === undefined) {\n                    axis.reversed = true;\n                }\n\n                // register event listeners\n                objectEach(events, function(event, eventType) {\n                    addEvent(axis, eventType, event);\n                });\n\n                // extend logarithmic axis\n                axis.lin2log = options.linearToLogConverter || axis.lin2log;\n                if (axis.isLog) {\n                    axis.val2lin = axis.log2lin;\n                    axis.lin2val = axis.lin2log;\n                }\n            },\n\n            /**\n             * Merge and set options\n             */\n            setOptions: function(userOptions) {\n                this.options = merge(\n                    this.defaultOptions,\n                    this.coll === 'yAxis' && this.defaultYAxisOptions, [\n                        this.defaultTopAxisOptions,\n                        this.defaultRightAxisOptions,\n                        this.defaultBottomAxisOptions,\n                        this.defaultLeftAxisOptions\n                    ][this.side],\n                    merge(\n                        defaultOptions[this.coll], // if set in setOptions (#1053)\n                        userOptions\n                    )\n                );\n            },\n\n            /**\n             * The default label formatter. The context is a special config object for\n             * the label. In apps, use the {@link\n             * https://api.highcharts.com/highcharts/xAxis.labels.formatter|\n             * labels.formatter} instead except when a modification is needed.\n             *\n             * @private\n             */\n            defaultLabelFormatter: function() {\n                var axis = this.axis,\n                    value = this.value,\n                    categories = axis.categories,\n                    dateTimeLabelFormat = this.dateTimeLabelFormat,\n                    lang = defaultOptions.lang,\n                    numericSymbols = lang.numericSymbols,\n                    numSymMagnitude = lang.numericSymbolMagnitude || 1000,\n                    i = numericSymbols && numericSymbols.length,\n                    multi,\n                    ret,\n                    formatOption = axis.options.labels.format,\n\n                    // make sure the same symbol is added for all labels on a linear\n                    // axis\n                    numericSymbolDetector = axis.isLog ?\n                    Math.abs(value) :\n                    axis.tickInterval;\n\n                if (formatOption) {\n                    ret = format(formatOption, this);\n\n                } else if (categories) {\n                    ret = value;\n\n                } else if (dateTimeLabelFormat) { // datetime axis\n                    ret = H.dateFormat(dateTimeLabelFormat, value);\n\n                } else if (i && numericSymbolDetector >= 1000) {\n                    // Decide whether we should add a numeric symbol like k (thousands)\n                    // or M (millions). If we are to enable this in tooltip or other\n                    // places as well, we can move this logic to the numberFormatter and\n                    // enable it by a parameter.\n                    while (i-- && ret === undefined) {\n                        multi = Math.pow(numSymMagnitude, i + 1);\n                        if (\n                            numericSymbolDetector >= multi &&\n                            (value * 10) % multi === 0 &&\n                            numericSymbols[i] !== null &&\n                            value !== 0\n                        ) { // #5480\n                            ret = H.numberFormat(value / multi, -1) + numericSymbols[i];\n                        }\n                    }\n                }\n\n                if (ret === undefined) {\n                    if (Math.abs(value) >= 10000) { // add thousands separators\n                        ret = H.numberFormat(value, -1);\n                    } else { // small numbers\n                        ret = H.numberFormat(value, -1, undefined, ''); // #2466\n                    }\n                }\n\n                return ret;\n            },\n\n            /**\n             * Get the minimum and maximum for the series of each axis\n             */\n            getSeriesExtremes: function() {\n                var axis = this,\n                    chart = axis.chart;\n                axis.hasVisibleSeries = false;\n\n                // Reset properties in case we're redrawing (#3353)\n                axis.dataMin = axis.dataMax = axis.threshold = null;\n                axis.softThreshold = !axis.isXAxis;\n\n                if (axis.buildStacks) {\n                    axis.buildStacks();\n                }\n\n                // loop through this axis' series\n                each(axis.series, function(series) {\n\n                    if (series.visible || !chart.options.chart.ignoreHiddenSeries) {\n\n                        var seriesOptions = series.options,\n                            xData,\n                            threshold = seriesOptions.threshold,\n                            seriesDataMin,\n                            seriesDataMax;\n\n                        axis.hasVisibleSeries = true;\n\n                        // Validate threshold in logarithmic axes\n                        if (axis.positiveValuesOnly && threshold <= 0) {\n                            threshold = null;\n                        }\n\n                        // Get dataMin and dataMax for X axes\n                        if (axis.isXAxis) {\n                            xData = series.xData;\n                            if (xData.length) {\n                                // If xData contains values which is not numbers, then\n                                // filter them out. To prevent performance hit, we only\n                                // do this after we have already found seriesDataMin\n                                // because in most cases all data is valid. #5234.\n                                seriesDataMin = arrayMin(xData);\n                                if (!isNumber(seriesDataMin) &&\n                                    !(seriesDataMin instanceof Date) // #5010\n                                ) {\n                                    xData = grep(xData, function(x) {\n                                        return isNumber(x);\n                                    });\n                                    seriesDataMin = arrayMin(xData); // Do it again with valid data\n                                }\n\n                                axis.dataMin = Math.min(\n                                    pick(axis.dataMin, xData[0]),\n                                    seriesDataMin\n                                );\n                                axis.dataMax = Math.max(\n                                    pick(axis.dataMax, xData[0]),\n                                    arrayMax(xData)\n                                );\n\n                            }\n\n                            // Get dataMin and dataMax for Y axes, as well as handle\n                            // stacking and processed data\n                        } else {\n\n                            // Get this particular series extremes\n                            series.getExtremes();\n                            seriesDataMax = series.dataMax;\n                            seriesDataMin = series.dataMin;\n\n                            // Get the dataMin and dataMax so far. If percentage is\n                            // used, the min and max are always 0 and 100. If\n                            // seriesDataMin and seriesDataMax is null, then series\n                            // doesn't have active y data, we continue with nulls\n                            if (defined(seriesDataMin) && defined(seriesDataMax)) {\n                                axis.dataMin = Math.min(\n                                    pick(axis.dataMin, seriesDataMin),\n                                    seriesDataMin\n                                );\n                                axis.dataMax = Math.max(\n                                    pick(axis.dataMax, seriesDataMax),\n                                    seriesDataMax\n                                );\n                            }\n\n                            // Adjust to threshold\n                            if (defined(threshold)) {\n                                axis.threshold = threshold;\n                            }\n                            // If any series has a hard threshold, it takes precedence\n                            if (!seriesOptions.softThreshold ||\n                                axis.positiveValuesOnly\n                            ) {\n                                axis.softThreshold = false;\n                            }\n                        }\n                    }\n                });\n            },\n\n            /**\n             * Translate from axis value to pixel position on the chart, or back\n             *\n             */\n            translate: function(val, backwards, cvsCoord, old, handleLog, pointPlacement) {\n                var axis = this.linkedParent || this, // #1417\n                    sign = 1,\n                    cvsOffset = 0,\n                    localA = old ? axis.oldTransA : axis.transA,\n                    localMin = old ? axis.oldMin : axis.min,\n                    returnValue,\n                    minPixelPadding = axis.minPixelPadding,\n                    doPostTranslate = (axis.isOrdinal || axis.isBroken || (axis.isLog && handleLog)) && axis.lin2val;\n\n                if (!localA) {\n                    localA = axis.transA;\n                }\n\n                // In vertical axes, the canvas coordinates start from 0 at the top like in\n                // SVG.\n                if (cvsCoord) {\n                    sign *= -1; // canvas coordinates inverts the value\n                    cvsOffset = axis.len;\n                }\n\n                // Handle reversed axis\n                if (axis.reversed) {\n                    sign *= -1;\n                    cvsOffset -= sign * (axis.sector || axis.len);\n                }\n\n                // From pixels to value\n                if (backwards) { // reverse translation\n\n                    val = val * sign + cvsOffset;\n                    val -= minPixelPadding;\n                    returnValue = val / localA + localMin; // from chart pixel to value\n                    if (doPostTranslate) { // log and ordinal axes\n                        returnValue = axis.lin2val(returnValue);\n                    }\n\n                    // From value to pixels\n                } else {\n                    if (doPostTranslate) { // log and ordinal axes\n                        val = axis.val2lin(val);\n                    }\n                    returnValue = sign * (val - localMin) * localA + cvsOffset +\n                        (sign * minPixelPadding) +\n                        (isNumber(pointPlacement) ? localA * pointPlacement : 0);\n                }\n\n                return returnValue;\n            },\n\n            /**\n             * Translate a value in terms of axis units into pixels within the chart.\n             * \n             * @param  {Number} value\n             *         A value in terms of axis units.\n             * @param  {Boolean} paneCoordinates\n             *         Whether to return the pixel coordinate relative to the chart or\n             *         just the axis/pane itself.\n             * @return {Number} Pixel position of the value on the chart or axis.\n             */\n            toPixels: function(value, paneCoordinates) {\n                return this.translate(value, false, !this.horiz, null, true) +\n                    (paneCoordinates ? 0 : this.pos);\n            },\n\n            /**\n             * Translate a pixel position along the axis to a value in terms of axis\n             * units.\n             * @param  {Number} pixel\n             *         The pixel value coordinate.\n             * @param  {Boolean} paneCoordiantes\n             *         Whether the input pixel is relative to the chart or just the\n             *         axis/pane itself.\n             * @return {Number} The axis value.\n             */\n            toValue: function(pixel, paneCoordinates) {\n                return this.translate(\n                    pixel - (paneCoordinates ? 0 : this.pos),\n                    true, !this.horiz,\n                    null,\n                    true\n                );\n            },\n\n            /**\n             * Create the path for a plot line that goes from the given value on\n             * this axis, across the plot to the opposite side\n             * @param {Number} value\n             * @param {Number} lineWidth Used for calculation crisp line\n             * @param {Number] old Use old coordinates (for resizing and rescaling)\n             */\n            getPlotLinePath: function(value, lineWidth, old, force, translatedValue) {\n                var axis = this,\n                    chart = axis.chart,\n                    axisLeft = axis.left,\n                    axisTop = axis.top,\n                    x1,\n                    y1,\n                    x2,\n                    y2,\n                    cHeight = (old && chart.oldChartHeight) || chart.chartHeight,\n                    cWidth = (old && chart.oldChartWidth) || chart.chartWidth,\n                    skip,\n                    transB = axis.transB,\n                    /**\n                     * Check if x is between a and b. If not, either move to a/b or skip,\n                     * depending on the force parameter.\n                     */\n                    between = function(x, a, b) {\n                        if (x < a || x > b) {\n                            if (force) {\n                                x = Math.min(Math.max(a, x), b);\n                            } else {\n                                skip = true;\n                            }\n                        }\n                        return x;\n                    };\n\n                translatedValue = pick(translatedValue, axis.translate(value, null, null, old));\n                x1 = x2 = Math.round(translatedValue + transB);\n                y1 = y2 = Math.round(cHeight - translatedValue - transB);\n                if (!isNumber(translatedValue)) { // no min or max\n                    skip = true;\n\n                } else if (axis.horiz) {\n                    y1 = axisTop;\n                    y2 = cHeight - axis.bottom;\n                    x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);\n                } else {\n                    x1 = axisLeft;\n                    x2 = cWidth - axis.right;\n                    y1 = y2 = between(y1, axisTop, axisTop + axis.height);\n                }\n                return skip && !force ?\n                    null :\n                    chart.renderer.crispLine(['M', x1, y1, 'L', x2, y2], lineWidth || 1);\n            },\n\n            /**\n             * Internal function to et the tick positions of a linear axis to round\n             * values like whole tens or every five.\n             *\n             * @param  {Number} tickInterval\n             *         The normalized tick interval\n             * @param  {Number} min\n             *         Axis minimum.\n             * @param  {Number} max\n             *         Axis maximum.\n             *\n             * @return {Array.<Number>}\n             *         An array of numbers where ticks should be placed.\n             */\n            getLinearTickPositions: function(tickInterval, min, max) {\n                var pos,\n                    lastPos,\n                    roundedMin = correctFloat(Math.floor(min / tickInterval) * tickInterval),\n                    roundedMax = correctFloat(Math.ceil(max / tickInterval) * tickInterval),\n                    tickPositions = [];\n\n                // For single points, add a tick regardless of the relative position\n                // (#2662, #6274)\n                if (this.single) {\n                    return [min];\n                }\n\n                // Populate the intermediate values\n                pos = roundedMin;\n                while (pos <= roundedMax) {\n\n                    // Place the tick on the rounded value\n                    tickPositions.push(pos);\n\n                    // Always add the raw tickInterval, not the corrected one.\n                    pos = correctFloat(pos + tickInterval);\n\n                    // If the interval is not big enough in the current min - max range to actually increase\n                    // the loop variable, we need to break out to prevent endless loop. Issue #619\n                    if (pos === lastPos) {\n                        break;\n                    }\n\n                    // Record the last value\n                    lastPos = pos;\n                }\n                return tickPositions;\n            },\n\n            /**\n             * Return the minor tick positions. For logarithmic axes, reuse the same logic\n             * as for major ticks.\n             */\n            getMinorTickPositions: function() {\n                var axis = this,\n                    options = axis.options,\n                    tickPositions = axis.tickPositions,\n                    minorTickInterval = axis.minorTickInterval,\n                    minorTickPositions = [],\n                    pos,\n                    pointRangePadding = axis.pointRangePadding || 0,\n                    min = axis.min - pointRangePadding, // #1498\n                    max = axis.max + pointRangePadding, // #1498\n                    range = max - min;\n\n                // If minor ticks get too dense, they are hard to read, and may cause long running script. So we don't draw them.\n                if (range && range / minorTickInterval < axis.len / 3) { // #3875\n\n                    if (axis.isLog) {\n                        // For each interval in the major ticks, compute the minor ticks\n                        // separately.\n                        each(this.paddedTicks, function(pos, i, paddedTicks) {\n                            if (i) {\n                                minorTickPositions.push.apply(\n                                    minorTickPositions,\n                                    axis.getLogTickPositions(\n                                        minorTickInterval,\n                                        paddedTicks[i - 1],\n                                        paddedTicks[i],\n                                        true\n                                    )\n                                );\n                            }\n                        });\n\n                    } else if (axis.isDatetimeAxis && options.minorTickInterval === 'auto') { // #1314\n                        minorTickPositions = minorTickPositions.concat(\n                            axis.getTimeTicks(\n                                axis.normalizeTimeTickInterval(minorTickInterval),\n                                min,\n                                max,\n                                options.startOfWeek\n                            )\n                        );\n                    } else {\n                        for (\n                            pos = min + (tickPositions[0] - min) % minorTickInterval; pos <= max; pos += minorTickInterval\n                        ) {\n                            // Very, very, tight grid lines (#5771)\n                            if (pos === minorTickPositions[0]) {\n                                break;\n                            }\n                            minorTickPositions.push(pos);\n                        }\n                    }\n                }\n\n                if (minorTickPositions.length !== 0) {\n                    axis.trimTicks(minorTickPositions); // #3652 #3743 #1498 #6330\n                }\n                return minorTickPositions;\n            },\n\n            /**\n             * Adjust the min and max for the minimum range. Keep in mind that the series data is\n             * not yet processed, so we don't have information on data cropping and grouping, or\n             * updated axis.pointRange or series.pointRange. The data can't be processed until\n             * we have finally established min and max.\n             *\n             * @private\n             */\n            adjustForMinRange: function() {\n                var axis = this,\n                    options = axis.options,\n                    min = axis.min,\n                    max = axis.max,\n                    zoomOffset,\n                    spaceAvailable,\n                    closestDataRange,\n                    i,\n                    distance,\n                    xData,\n                    loopLength,\n                    minArgs,\n                    maxArgs,\n                    minRange;\n\n                // Set the automatic minimum range based on the closest point distance\n                if (axis.isXAxis && axis.minRange === undefined && !axis.isLog) {\n\n                    if (defined(options.min) || defined(options.max)) {\n                        axis.minRange = null; // don't do this again\n\n                    } else {\n\n                        // Find the closest distance between raw data points, as opposed to\n                        // closestPointRange that applies to processed points (cropped and grouped)\n                        each(axis.series, function(series) {\n                            xData = series.xData;\n                            loopLength = series.xIncrement ? 1 : xData.length - 1;\n                            for (i = loopLength; i > 0; i--) {\n                                distance = xData[i] - xData[i - 1];\n                                if (closestDataRange === undefined || distance < closestDataRange) {\n                                    closestDataRange = distance;\n                                }\n                            }\n                        });\n                        axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);\n                    }\n                }\n\n                // if minRange is exceeded, adjust\n                if (max - min < axis.minRange) {\n\n                    spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;\n                    minRange = axis.minRange;\n                    zoomOffset = (minRange - max + min) / 2;\n\n                    // if min and max options have been set, don't go beyond it\n                    minArgs = [min - zoomOffset, pick(options.min, min - zoomOffset)];\n                    if (spaceAvailable) { // if space is available, stay within the data range\n                        minArgs[2] = axis.isLog ? axis.log2lin(axis.dataMin) : axis.dataMin;\n                    }\n                    min = arrayMax(minArgs);\n\n                    maxArgs = [min + minRange, pick(options.max, min + minRange)];\n                    if (spaceAvailable) { // if space is availabe, stay within the data range\n                        maxArgs[2] = axis.isLog ? axis.log2lin(axis.dataMax) : axis.dataMax;\n                    }\n\n                    max = arrayMin(maxArgs);\n\n                    // now if the max is adjusted, adjust the min back\n                    if (max - min < minRange) {\n                        minArgs[0] = max - minRange;\n                        minArgs[1] = pick(options.min, max - minRange);\n                        min = arrayMax(minArgs);\n                    }\n                }\n\n                // Record modified extremes\n                axis.min = min;\n                axis.max = max;\n            },\n\n            /**\n             * Find the closestPointRange across all series.\n             *\n             * @private\n             */\n            getClosest: function() {\n                var ret;\n\n                if (this.categories) {\n                    ret = 1;\n                } else {\n                    each(this.series, function(series) {\n                        var seriesClosest = series.closestPointRange,\n                            visible = series.visible ||\n                            !series.chart.options.chart.ignoreHiddenSeries;\n\n                        if (!series.noSharedTooltip &&\n                            defined(seriesClosest) &&\n                            visible\n                        ) {\n                            ret = defined(ret) ?\n                                Math.min(ret, seriesClosest) :\n                                seriesClosest;\n                        }\n                    });\n                }\n                return ret;\n            },\n\n            /**\n             * When a point name is given and no x, search for the name in the existing categories,\n             * or if categories aren't provided, search names or create a new category (#2522).\n             */\n            nameToX: function(point) {\n                var explicitCategories = isArray(this.categories),\n                    names = explicitCategories ? this.categories : this.names,\n                    nameX = point.options.x,\n                    x;\n\n                point.series.requireSorting = false;\n\n                if (!defined(nameX)) {\n                    nameX = this.options.uniqueNames === false ?\n                        point.series.autoIncrement() :\n                        inArray(point.name, names);\n                }\n                if (nameX === -1) { // The name is not found in currenct categories\n                    if (!explicitCategories) {\n                        x = names.length;\n                    }\n                } else {\n                    x = nameX;\n                }\n\n                // Write the last point's name to the names array\n                if (x !== undefined) {\n                    this.names[x] = point.name;\n                }\n\n                return x;\n            },\n\n            /**\n             * When changes have been done to series data, update the axis.names.\n             */\n            updateNames: function() {\n                var axis = this;\n\n                if (this.names.length > 0) {\n                    this.names.length = 0;\n                    this.minRange = this.userMinRange; // Reset\n                    each(this.series || [], function(series) {\n\n                        // Reset incrementer (#5928)\n                        series.xIncrement = null;\n\n                        // When adding a series, points are not yet generated\n                        if (!series.points || series.isDirtyData) {\n                            series.processData();\n                            series.generatePoints();\n                        }\n\n                        each(series.points, function(point, i) {\n                            var x;\n                            if (point.options) {\n                                x = axis.nameToX(point);\n                                if (x !== undefined && x !== point.x) {\n                                    point.x = x;\n                                    series.xData[i] = x;\n                                }\n                            }\n                        });\n                    });\n                }\n            },\n\n            /**\n             * Update translation information\n             */\n            setAxisTranslation: function(saveOld) {\n                var axis = this,\n                    range = axis.max - axis.min,\n                    pointRange = axis.axisPointRange || 0,\n                    closestPointRange,\n                    minPointOffset = 0,\n                    pointRangePadding = 0,\n                    linkedParent = axis.linkedParent,\n                    ordinalCorrection,\n                    hasCategories = !!axis.categories,\n                    transA = axis.transA,\n                    isXAxis = axis.isXAxis;\n\n                // Adjust translation for padding. Y axis with categories need to go through the same (#1784).\n                if (isXAxis || hasCategories || pointRange) {\n\n                    // Get the closest points\n                    closestPointRange = axis.getClosest();\n\n                    if (linkedParent) {\n                        minPointOffset = linkedParent.minPointOffset;\n                        pointRangePadding = linkedParent.pointRangePadding;\n                    } else {\n                        each(axis.series, function(series) {\n                            var seriesPointRange = hasCategories ?\n                                1 :\n                                (isXAxis ?\n                                    pick(series.options.pointRange, closestPointRange, 0) :\n                                    (axis.axisPointRange || 0)), // #2806\n                                pointPlacement = series.options.pointPlacement;\n\n                            pointRange = Math.max(pointRange, seriesPointRange);\n\n                            if (!axis.single) {\n                                // minPointOffset is the value padding to the left of the axis in order to make\n                                // room for points with a pointRange, typically columns. When the pointPlacement option\n                                // is 'between' or 'on', this padding does not apply.\n                                minPointOffset = Math.max(\n                                    minPointOffset,\n                                    isString(pointPlacement) ? 0 : seriesPointRange / 2\n                                );\n\n                                // Determine the total padding needed to the length of the axis to make room for the\n                                // pointRange. If the series' pointPlacement is 'on', no padding is added.\n                                pointRangePadding = Math.max(\n                                    pointRangePadding,\n                                    pointPlacement === 'on' ? 0 : seriesPointRange\n                                );\n                            }\n                        });\n                    }\n\n                    // Record minPointOffset and pointRangePadding\n                    ordinalCorrection = axis.ordinalSlope && closestPointRange ? axis.ordinalSlope / closestPointRange : 1; // #988, #1853\n                    axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;\n                    axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;\n\n                    // pointRange means the width reserved for each point, like in a column chart\n                    axis.pointRange = Math.min(pointRange, range);\n\n                    // closestPointRange means the closest distance between points. In columns\n                    // it is mostly equal to pointRange, but in lines pointRange is 0 while closestPointRange\n                    // is some other value\n                    if (isXAxis) {\n                        axis.closestPointRange = closestPointRange;\n                    }\n                }\n\n                // Secondary values\n                if (saveOld) {\n                    axis.oldTransA = transA;\n                }\n                axis.translationSlope = axis.transA = transA =\n                    axis.options.staticScale ||\n                    axis.len / ((range + pointRangePadding) || 1);\n                axis.transB = axis.horiz ? axis.left : axis.bottom; // translation addend\n                axis.minPixelPadding = transA * minPointOffset;\n            },\n\n            minFromRange: function() {\n                return this.max - this.range;\n            },\n\n            /**\n             * Set the tick positions to round values and optionally extend the extremes\n             * to the nearest tick\n             */\n            setTickInterval: function(secondPass) {\n                var axis = this,\n                    chart = axis.chart,\n                    options = axis.options,\n                    isLog = axis.isLog,\n                    log2lin = axis.log2lin,\n                    isDatetimeAxis = axis.isDatetimeAxis,\n                    isXAxis = axis.isXAxis,\n                    isLinked = axis.isLinked,\n                    maxPadding = options.maxPadding,\n                    minPadding = options.minPadding,\n                    length,\n                    linkedParentExtremes,\n                    tickIntervalOption = options.tickInterval,\n                    minTickInterval,\n                    tickPixelIntervalOption = options.tickPixelInterval,\n                    categories = axis.categories,\n                    threshold = axis.threshold,\n                    softThreshold = axis.softThreshold,\n                    thresholdMin,\n                    thresholdMax,\n                    hardMin,\n                    hardMax;\n\n                if (!isDatetimeAxis && !categories && !isLinked) {\n                    this.getTickAmount();\n                }\n\n                // Min or max set either by zooming/setExtremes or initial options\n                hardMin = pick(axis.userMin, options.min);\n                hardMax = pick(axis.userMax, options.max);\n\n                // Linked axis gets the extremes from the parent axis\n                if (isLinked) {\n                    axis.linkedParent = chart[axis.coll][options.linkedTo];\n                    linkedParentExtremes = axis.linkedParent.getExtremes();\n                    axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);\n                    axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);\n                    if (options.type !== axis.linkedParent.options.type) {\n                        H.error(11, 1); // Can't link axes of different type\n                    }\n\n                    // Initial min and max from the extreme data values\n                } else {\n\n                    // Adjust to hard threshold\n                    if (!softThreshold && defined(threshold)) {\n                        if (axis.dataMin >= threshold) {\n                            thresholdMin = threshold;\n                            minPadding = 0;\n                        } else if (axis.dataMax <= threshold) {\n                            thresholdMax = threshold;\n                            maxPadding = 0;\n                        }\n                    }\n\n                    axis.min = pick(hardMin, thresholdMin, axis.dataMin);\n                    axis.max = pick(hardMax, thresholdMax, axis.dataMax);\n\n                }\n\n                if (isLog) {\n                    if (\n                        axis.positiveValuesOnly &&\n                        !secondPass &&\n                        Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0\n                    ) { // #978\n                        H.error(10, 1); // Can't plot negative values on log axis\n                    }\n                    // The correctFloat cures #934, float errors on full tens. But it\n                    // was too aggressive for #4360 because of conversion back to lin,\n                    // therefore use precision 15.\n                    axis.min = correctFloat(log2lin(axis.min), 15);\n                    axis.max = correctFloat(log2lin(axis.max), 15);\n                }\n\n                // handle zoomed range\n                if (axis.range && defined(axis.max)) {\n                    axis.userMin = axis.min = hardMin = Math.max(axis.min, axis.minFromRange()); // #618\n                    axis.userMax = hardMax = axis.max;\n\n                    axis.range = null; // don't use it when running setExtremes\n                }\n\n                // Hook for Highstock Scroller. Consider combining with beforePadding.\n                fireEvent(axis, 'foundExtremes');\n\n                // Hook for adjusting this.min and this.max. Used by bubble series.\n                if (axis.beforePadding) {\n                    axis.beforePadding();\n                }\n\n                // adjust min and max for the minimum range\n                axis.adjustForMinRange();\n\n                // Pad the values to get clear of the chart's edges. To avoid tickInterval taking the padding\n                // into account, we do this after computing tick interval (#1337).\n                if (!categories && !axis.axisPointRange && !axis.usePercentage && !isLinked && defined(axis.min) && defined(axis.max)) {\n                    length = axis.max - axis.min;\n                    if (length) {\n                        if (!defined(hardMin) && minPadding) {\n                            axis.min -= length * minPadding;\n                        }\n                        if (!defined(hardMax) && maxPadding) {\n                            axis.max += length * maxPadding;\n                        }\n                    }\n                }\n\n                // Handle options for floor, ceiling, softMin and softMax (#6359)\n                if (isNumber(options.softMin)) {\n                    axis.min = Math.min(axis.min, options.softMin);\n                }\n                if (isNumber(options.softMax)) {\n                    axis.max = Math.max(axis.max, options.softMax);\n                }\n                if (isNumber(options.floor)) {\n                    axis.min = Math.max(axis.min, options.floor);\n                }\n                if (isNumber(options.ceiling)) {\n                    axis.max = Math.min(axis.max, options.ceiling);\n                }\n\n\n                // When the threshold is soft, adjust the extreme value only if\n                // the data extreme and the padded extreme land on either side of the threshold. For example,\n                // a series of [0, 1, 2, 3] would make the yAxis add a tick for -1 because of the\n                // default minPadding and startOnTick options. This is prevented by the softThreshold\n                // option.\n                if (softThreshold && defined(axis.dataMin)) {\n                    threshold = threshold || 0;\n                    if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {\n                        axis.min = threshold;\n                    } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {\n                        axis.max = threshold;\n                    }\n                }\n\n\n                // get tickInterval\n                if (axis.min === axis.max || axis.min === undefined || axis.max === undefined) {\n                    axis.tickInterval = 1;\n                } else if (isLinked && !tickIntervalOption &&\n                    tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {\n                    axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;\n                } else {\n                    axis.tickInterval = pick(\n                        tickIntervalOption,\n                        this.tickAmount ? ((axis.max - axis.min) / Math.max(this.tickAmount - 1, 1)) : undefined,\n                        categories ? // for categoried axis, 1 is default, for linear axis use tickPix\n                        1 :\n                        // don't let it be more than the data range\n                        (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption)\n                    );\n                }\n\n                // Now we're finished detecting min and max, crop and group series data. This\n                // is in turn needed in order to find tick positions in ordinal axes.\n                if (isXAxis && !secondPass) {\n                    each(axis.series, function(series) {\n                        series.processData(axis.min !== axis.oldMin || axis.max !== axis.oldMax);\n                    });\n                }\n\n                // set the translation factor used in translate function\n                axis.setAxisTranslation(true);\n\n                // hook for ordinal axes and radial axes\n                if (axis.beforeSetTickPositions) {\n                    axis.beforeSetTickPositions();\n                }\n\n                // hook for extensions, used in Highstock ordinal axes\n                if (axis.postProcessTickInterval) {\n                    axis.tickInterval = axis.postProcessTickInterval(axis.tickInterval);\n                }\n\n                // In column-like charts, don't cramp in more ticks than there are points (#1943, #4184)\n                if (axis.pointRange && !tickIntervalOption) {\n                    axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);\n                }\n\n                // Before normalizing the tick interval, handle minimum tick interval. This applies only if tickInterval is not defined.\n                minTickInterval = pick(options.minTickInterval, axis.isDatetimeAxis && axis.closestPointRange);\n                if (!tickIntervalOption && axis.tickInterval < minTickInterval) {\n                    axis.tickInterval = minTickInterval;\n                }\n\n                // for linear axes, get magnitude and normalize the interval\n                if (!isDatetimeAxis && !isLog && !tickIntervalOption) {\n                    axis.tickInterval = normalizeTickInterval(\n                        axis.tickInterval,\n                        null,\n                        getMagnitude(axis.tickInterval),\n                        // If the tick interval is between 0.5 and 5 and the axis max is in the order of\n                        // thousands, chances are we are dealing with years. Don't allow decimals. #3363.\n                        pick(options.allowDecimals, !(axis.tickInterval > 0.5 && axis.tickInterval < 5 && axis.max > 1000 && axis.max < 9999)), !!this.tickAmount\n                    );\n                }\n\n                // Prevent ticks from getting so close that we can't draw the labels\n                if (!this.tickAmount) {\n                    axis.tickInterval = axis.unsquish();\n                }\n\n                this.setTickPositions();\n            },\n\n            /**\n             * Now we have computed the normalized tickInterval, get the tick positions\n             */\n            setTickPositions: function() {\n\n                var options = this.options,\n                    tickPositions,\n                    tickPositionsOption = options.tickPositions,\n                    tickPositioner = options.tickPositioner,\n                    startOnTick = options.startOnTick,\n                    endOnTick = options.endOnTick;\n\n                // Set the tickmarkOffset\n                this.tickmarkOffset = (this.categories && options.tickmarkPlacement === 'between' &&\n                    this.tickInterval === 1) ? 0.5 : 0; // #3202\n\n\n                // get minorTickInterval\n                this.minorTickInterval = options.minorTickInterval === 'auto' && this.tickInterval ?\n                    this.tickInterval / 5 : options.minorTickInterval;\n\n                // When there is only one point, or all points have the same value on\n                // this axis, then min and max are equal and tickPositions.length is 0\n                // or 1. In this case, add some padding in order to center the point,\n                // but leave it with one tick. #1337.\n                this.single =\n                    this.min === this.max &&\n                    defined(this.min) &&\n                    !this.tickAmount &&\n                    (\n                        // Data is on integer (#6563)\n                        parseInt(this.min, 10) === this.min ||\n\n                        // Between integers and decimals are not allowed (#6274)\n                        options.allowDecimals !== false\n                    );\n\n                // Find the tick positions\n                this.tickPositions = tickPositions = tickPositionsOption && tickPositionsOption.slice(); // Work on a copy (#1565)\n                if (!tickPositions) {\n\n                    if (this.isDatetimeAxis) {\n                        tickPositions = this.getTimeTicks(\n                            this.normalizeTimeTickInterval(\n                                this.tickInterval,\n                                options.units\n                            ),\n                            this.min,\n                            this.max,\n                            options.startOfWeek,\n                            this.ordinalPositions,\n                            this.closestPointRange,\n                            true\n                        );\n                    } else if (this.isLog) {\n                        tickPositions = this.getLogTickPositions(\n                            this.tickInterval,\n                            this.min,\n                            this.max\n                        );\n                    } else {\n                        tickPositions = this.getLinearTickPositions(\n                            this.tickInterval,\n                            this.min,\n                            this.max\n                        );\n                    }\n\n                    // Too dense ticks, keep only the first and last (#4477)\n                    if (tickPositions.length > this.len) {\n                        tickPositions = [tickPositions[0], tickPositions.pop()];\n                    }\n\n                    this.tickPositions = tickPositions;\n\n                    // Run the tick positioner callback, that allows modifying auto tick positions.\n                    if (tickPositioner) {\n                        tickPositioner = tickPositioner.apply(this, [this.min, this.max]);\n                        if (tickPositioner) {\n                            this.tickPositions = tickPositions = tickPositioner;\n                        }\n                    }\n\n                }\n\n                // Reset min/max or remove extremes based on start/end on tick\n                this.paddedTicks = tickPositions.slice(0); // Used for logarithmic minor\n                this.trimTicks(tickPositions, startOnTick, endOnTick);\n                if (!this.isLinked) {\n\n                    // Substract half a unit (#2619, #2846, #2515, #3390)\n                    if (this.single) {\n                        this.min -= 0.5;\n                        this.max += 0.5;\n                    }\n                    if (!tickPositionsOption && !tickPositioner) {\n                        this.adjustTickAmount();\n                    }\n                }\n            },\n\n            /**\n             * Handle startOnTick and endOnTick by either adapting to padding min/max or rounded min/max\n             */\n            trimTicks: function(tickPositions, startOnTick, endOnTick) {\n                var roundedMin = tickPositions[0],\n                    roundedMax = tickPositions[tickPositions.length - 1],\n                    minPointOffset = this.minPointOffset || 0;\n\n                if (!this.isLinked) {\n                    if (startOnTick && roundedMin !== -Infinity) { // #6502\n                        this.min = roundedMin;\n                    } else {\n                        while (this.min - minPointOffset > tickPositions[0]) {\n                            tickPositions.shift();\n                        }\n                    }\n\n                    if (endOnTick) {\n                        this.max = roundedMax;\n                    } else {\n                        while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {\n                            tickPositions.pop();\n                        }\n                    }\n\n                    // If no tick are left, set one tick in the middle (#3195)\n                    if (tickPositions.length === 0 && defined(roundedMin)) {\n                        tickPositions.push((roundedMax + roundedMin) / 2);\n                    }\n                }\n            },\n\n            /**\n             * Check if there are multiple axes in the same pane.\n             *\n             * @private\n             * @return {Boolean}\n             *         True if there are other axes.\n             */\n            alignToOthers: function() {\n                var others = {}, // Whether there is another axis to pair with this one\n                    hasOther,\n                    options = this.options;\n\n                if (\n                    // Only if alignTicks is true\n                    this.chart.options.chart.alignTicks !== false &&\n                    options.alignTicks !== false &&\n\n                    // Don't try to align ticks on a log axis, they are not evenly\n                    // spaced (#6021)\n                    !this.isLog\n                ) {\n                    each(this.chart[this.coll], function(axis) {\n                        var otherOptions = axis.options,\n                            horiz = axis.horiz,\n                            key = [\n                                horiz ? otherOptions.left : otherOptions.top,\n                                otherOptions.width,\n                                otherOptions.height,\n                                otherOptions.pane\n                            ].join(',');\n\n\n                        if (axis.series.length) { // #4442\n                            if (others[key]) {\n                                hasOther = true; // #4201\n                            } else {\n                                others[key] = 1;\n                            }\n                        }\n                    });\n                }\n                return hasOther;\n            },\n\n            /**\n             * Set the max ticks of either the x and y axis collection\n             */\n            getTickAmount: function() {\n                var options = this.options,\n                    tickAmount = options.tickAmount,\n                    tickPixelInterval = options.tickPixelInterval;\n\n                if (!defined(options.tickInterval) && this.len < tickPixelInterval && !this.isRadial &&\n                    !this.isLog && options.startOnTick && options.endOnTick) {\n                    tickAmount = 2;\n                }\n\n                if (!tickAmount && this.alignToOthers()) {\n                    // Add 1 because 4 tick intervals require 5 ticks (including first and last)\n                    tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;\n                }\n\n                // For tick amounts of 2 and 3, compute five ticks and remove the intermediate ones. This\n                // prevents the axis from adding ticks that are too far away from the data extremes.\n                if (tickAmount < 4) {\n                    this.finalTickAmt = tickAmount;\n                    tickAmount = 5;\n                }\n\n                this.tickAmount = tickAmount;\n            },\n\n            /**\n             * When using multiple axes, adjust the number of ticks to match the highest\n             * number of ticks in that group.\n             *\n             * @private\n             */\n            adjustTickAmount: function() {\n                var tickInterval = this.tickInterval,\n                    tickPositions = this.tickPositions,\n                    tickAmount = this.tickAmount,\n                    finalTickAmt = this.finalTickAmt,\n                    currentTickAmount = tickPositions && tickPositions.length,\n                    i,\n                    len;\n\n                if (currentTickAmount < tickAmount) {\n                    while (tickPositions.length < tickAmount) {\n                        tickPositions.push(correctFloat(\n                            tickPositions[tickPositions.length - 1] + tickInterval\n                        ));\n                    }\n                    this.transA *= (currentTickAmount - 1) / (tickAmount - 1);\n                    this.max = tickPositions[tickPositions.length - 1];\n\n                    // We have too many ticks, run second pass to try to reduce ticks\n                } else if (currentTickAmount > tickAmount) {\n                    this.tickInterval *= 2;\n                    this.setTickPositions();\n                }\n\n                // The finalTickAmt property is set in getTickAmount\n                if (defined(finalTickAmt)) {\n                    i = len = tickPositions.length;\n                    while (i--) {\n                        if (\n                            (finalTickAmt === 3 && i % 2 === 1) || // Remove every other tick\n                            (finalTickAmt <= 2 && i > 0 && i < len - 1) // Remove all but first and last\n                        ) {\n                            tickPositions.splice(i, 1);\n                        }\n                    }\n                    this.finalTickAmt = undefined;\n                }\n            },\n\n            /**\n             * Set the scale based on data min and max, user set min and max or options\n             *\n             */\n            setScale: function() {\n                var axis = this,\n                    isDirtyData,\n                    isDirtyAxisLength;\n\n                axis.oldMin = axis.min;\n                axis.oldMax = axis.max;\n                axis.oldAxisLength = axis.len;\n\n                // set the new axisLength\n                axis.setAxisSize();\n                //axisLength = horiz ? axisWidth : axisHeight;\n                isDirtyAxisLength = axis.len !== axis.oldAxisLength;\n\n                // is there new data?\n                each(axis.series, function(series) {\n                    if (series.isDirtyData || series.isDirty ||\n                        series.xAxis.isDirty) { // when x axis is dirty, we need new data extremes for y as well\n                        isDirtyData = true;\n                    }\n                });\n\n                // do we really need to go through all this?\n                if (isDirtyAxisLength || isDirtyData || axis.isLinked || axis.forceRedraw ||\n                    axis.userMin !== axis.oldUserMin || axis.userMax !== axis.oldUserMax || axis.alignToOthers()) {\n\n                    if (axis.resetStacks) {\n                        axis.resetStacks();\n                    }\n\n                    axis.forceRedraw = false;\n\n                    // get data extremes if needed\n                    axis.getSeriesExtremes();\n\n                    // get fixed positions based on tickInterval\n                    axis.setTickInterval();\n\n                    // record old values to decide whether a rescale is necessary later on (#540)\n                    axis.oldUserMin = axis.userMin;\n                    axis.oldUserMax = axis.userMax;\n\n                    // Mark as dirty if it is not already set to dirty and extremes have changed. #595.\n                    if (!axis.isDirty) {\n                        axis.isDirty = isDirtyAxisLength || axis.min !== axis.oldMin || axis.max !== axis.oldMax;\n                    }\n                } else if (axis.cleanStacks) {\n                    axis.cleanStacks();\n                }\n            },\n\n            /**\n             * Set the minimum and maximum of the axes after render time. If the\n             * `startOnTick` and `endOnTick` options are true, the minimum and maximum\n             * values are rounded off to the nearest tick. To prevent this, these\n             * options can be set to false before calling setExtremes. Also, setExtremes\n             * will not allow a range lower than the `minRange` option, which by default\n             * is the range of five points.\n             * \n             * @param  {Number} [newMin]\n             *         The new minimum value.\n             * @param  {Number} [newMax]\n             *         The new maximum value.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart or wait for an explicit call to \n             *         {@link Highcharts.Chart#redraw}\n             * @param  {AnimationOptions} [animation=true]\n             *         Enable or modify animations.\n             * @param  {Object} [eventArguments]\n             *         Arguments to be accessed in event handler.\n             *\n             * @sample highcharts/members/axis-setextremes/\n             *         Set extremes from a button\n             * @sample highcharts/members/axis-setextremes-datetime/\n             *         Set extremes on a datetime axis\n             * @sample highcharts/members/axis-setextremes-off-ticks/\n             *         Set extremes off ticks\n             * @sample stock/members/axis-setextremes/\n             *         Set extremes in Highstock\n             * @sample maps/members/axis-setextremes/\n             *         Set extremes in Highmaps\n             */\n            setExtremes: function(newMin, newMax, redraw, animation, eventArguments) {\n                var axis = this,\n                    chart = axis.chart;\n\n                redraw = pick(redraw, true); // defaults to true\n\n                each(axis.series, function(serie) {\n                    delete serie.kdTree;\n                });\n\n                // Extend the arguments with min and max\n                eventArguments = extend(eventArguments, {\n                    min: newMin,\n                    max: newMax\n                });\n\n                // Fire the event\n                fireEvent(axis, 'setExtremes', eventArguments, function() { // the default event handler\n\n                    axis.userMin = newMin;\n                    axis.userMax = newMax;\n                    axis.eventArgs = eventArguments;\n\n                    if (redraw) {\n                        chart.redraw(animation);\n                    }\n                });\n            },\n\n            /**\n             * Overridable method for zooming chart. Pulled out in a separate method to allow overriding\n             * in stock charts.\n             */\n            zoom: function(newMin, newMax) {\n                var dataMin = this.dataMin,\n                    dataMax = this.dataMax,\n                    options = this.options,\n                    min = Math.min(dataMin, pick(options.min, dataMin)),\n                    max = Math.max(dataMax, pick(options.max, dataMax));\n\n                if (newMin !== this.min || newMax !== this.max) { // #5790\n\n                    // Prevent pinch zooming out of range. Check for defined is for #1946. #1734.\n                    if (!this.allowZoomOutside) {\n                        // #6014, sometimes newMax will be smaller than min (or newMin will be larger than max).\n                        if (defined(dataMin)) {\n                            if (newMin < min) {\n                                newMin = min;\n                            }\n                            if (newMin > max) {\n                                newMin = max;\n                            }\n                        }\n                        if (defined(dataMax)) {\n                            if (newMax < min) {\n                                newMax = min;\n                            }\n                            if (newMax > max) {\n                                newMax = max;\n                            }\n                        }\n                    }\n\n                    // In full view, displaying the reset zoom button is not required\n                    this.displayBtn = newMin !== undefined || newMax !== undefined;\n\n                    // Do it\n                    this.setExtremes(\n                        newMin,\n                        newMax,\n                        false,\n                        undefined, {\n                            trigger: 'zoom'\n                        }\n                    );\n                }\n\n                return true;\n            },\n\n            /**\n             * Update the axis metrics\n             */\n            setAxisSize: function() {\n                var chart = this.chart,\n                    options = this.options,\n                    offsets = options.offsets || [0, 0, 0, 0], // top / right / bottom / left\n                    horiz = this.horiz,\n                    width = pick(options.width, chart.plotWidth - offsets[3] + offsets[1]),\n                    height = pick(options.height, chart.plotHeight - offsets[0] + offsets[2]),\n                    top = pick(options.top, chart.plotTop + offsets[0]),\n                    left = pick(options.left, chart.plotLeft + offsets[3]),\n                    percentRegex = /%$/;\n\n                // Check for percentage based input values. Rounding fixes problems with\n                // column overflow and plot line filtering (#4898, #4899)\n                if (percentRegex.test(height)) {\n                    height = Math.round(parseFloat(height) / 100 * chart.plotHeight);\n                }\n                if (percentRegex.test(top)) {\n                    top = Math.round(parseFloat(top) / 100 * chart.plotHeight + chart.plotTop);\n                }\n\n                // Expose basic values to use in Series object and navigator\n                this.left = left;\n                this.top = top;\n                this.width = width;\n                this.height = height;\n                this.bottom = chart.chartHeight - height - top;\n                this.right = chart.chartWidth - width - left;\n\n                // Direction agnostic properties\n                this.len = Math.max(horiz ? width : height, 0); // Math.max fixes #905\n                this.pos = horiz ? left : top; // distance from SVG origin\n            },\n\n            /**\n             * The returned object literal from the {@link Highcharts.Axis#getExtremes}\n             * function. \n             * @typedef {Object} Extremes\n             * @property {Number} dataMax\n             *         The maximum value of the axis' associated series.\n             * @property {Number} dataMin\n             *         The minimum value of the axis' associated series.\n             * @property {Number} max\n             *         The maximum axis value, either automatic or set manually. If the\n             *         `max` option is not set, `maxPadding` is 0 and `endOnTick` is\n             *         false, this value will be the same as `dataMax`.\n             * @property {Number} min\n             *         The minimum axis value, either automatic or set manually. If the\n             *         `min` option is not set, `minPadding` is 0 and `startOnTick` is\n             *         false, this value will be the same as `dataMin`.\n             */\n            /**\n             * Get the current extremes for the axis.\n             *\n             * @returns {Extremes}\n             * An object containing extremes information.\n             * \n             * @sample  members/axis-getextremes/\n             *          Report extremes by click on a button\n             * @sample  maps/members/axis-getextremes/\n             *          Get extremes in Highmaps\n             */\n            getExtremes: function() {\n                var axis = this,\n                    isLog = axis.isLog,\n                    lin2log = axis.lin2log;\n\n                return {\n                    min: isLog ? correctFloat(lin2log(axis.min)) : axis.min,\n                    max: isLog ? correctFloat(lin2log(axis.max)) : axis.max,\n                    dataMin: axis.dataMin,\n                    dataMax: axis.dataMax,\n                    userMin: axis.userMin,\n                    userMax: axis.userMax\n                };\n            },\n\n            /**\n             * Get the zero plane either based on zero or on the min or max value.\n             * Used in bar and area plots\n             */\n            getThreshold: function(threshold) {\n                var axis = this,\n                    isLog = axis.isLog,\n                    lin2log = axis.lin2log,\n                    realMin = isLog ? lin2log(axis.min) : axis.min,\n                    realMax = isLog ? lin2log(axis.max) : axis.max;\n\n                if (threshold === null) {\n                    threshold = realMin;\n                } else if (realMin > threshold) {\n                    threshold = realMin;\n                } else if (realMax < threshold) {\n                    threshold = realMax;\n                }\n\n                return axis.translate(threshold, 0, 1, 0, 1);\n            },\n\n            /**\n             * Compute auto alignment for the axis label based on which side the axis is\n             * on and the given rotation for the label.\n             *\n             * @param  {Number} rotation\n             *         The rotation in degrees as set by either the `rotation` or \n             *         `autoRotation` options.\n             * @private\n             */\n            autoLabelAlign: function(rotation) {\n                var ret,\n                    angle = (pick(rotation, 0) - (this.side * 90) + 720) % 360;\n\n                if (angle > 15 && angle < 165) {\n                    ret = 'right';\n                } else if (angle > 195 && angle < 345) {\n                    ret = 'left';\n                } else {\n                    ret = 'center';\n                }\n                return ret;\n            },\n\n            /**\n             * Get the tick length and width for the axis.\n             * @param   {String} prefix 'tick' or 'minorTick'\n             * @returns {Array}        An array of tickLength and tickWidth\n             */\n            tickSize: function(prefix) {\n                var options = this.options,\n                    tickLength = options[prefix + 'Length'],\n                    tickWidth = pick(options[prefix + 'Width'], prefix === 'tick' && this.isXAxis ? 1 : 0); // X axis defaults to 1\n\n                if (tickWidth && tickLength) {\n                    // Negate the length\n                    if (options[prefix + 'Position'] === 'inside') {\n                        tickLength = -tickLength;\n                    }\n                    return [tickLength, tickWidth];\n                }\n\n            },\n\n            /**\n             * Return the size of the labels\n             */\n            labelMetrics: function() {\n                var index = this.tickPositions && this.tickPositions[0] || 0;\n                return this.chart.renderer.fontMetrics(\n                    this.options.labels.style && this.options.labels.style.fontSize,\n                    this.ticks[index] && this.ticks[index].label\n                );\n            },\n\n            /**\n             * Prevent the ticks from getting so close we can't draw the labels. On a horizontal\n             * axis, this is handled by rotating the labels, removing ticks and adding ellipsis.\n             * On a vertical axis remove ticks and add ellipsis.\n             */\n            unsquish: function() {\n                var labelOptions = this.options.labels,\n                    horiz = this.horiz,\n                    tickInterval = this.tickInterval,\n                    newTickInterval = tickInterval,\n                    slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval),\n                    rotation,\n                    rotationOption = labelOptions.rotation,\n                    labelMetrics = this.labelMetrics(),\n                    step,\n                    bestScore = Number.MAX_VALUE,\n                    autoRotation,\n                    // Return the multiple of tickInterval that is needed to avoid collision\n                    getStep = function(spaceNeeded) {\n                        var step = spaceNeeded / (slotSize || 1);\n                        step = step > 1 ? Math.ceil(step) : 1;\n                        return step * tickInterval;\n                    };\n\n                if (horiz) {\n                    autoRotation = !labelOptions.staggerLines && !labelOptions.step && ( // #3971\n                        defined(rotationOption) ? [rotationOption] :\n                        slotSize < pick(labelOptions.autoRotationLimit, 80) && labelOptions.autoRotation\n                    );\n\n                    if (autoRotation) {\n\n                        // Loop over the given autoRotation options, and determine which gives the best score. The\n                        // best score is that with the lowest number of steps and a rotation closest to horizontal.\n                        each(autoRotation, function(rot) {\n                            var score;\n\n                            if (rot === rotationOption || (rot && rot >= -90 && rot <= 90)) { // #3891\n\n                                step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad * rot)));\n\n                                score = step + Math.abs(rot / 360);\n\n                                if (score < bestScore) {\n                                    bestScore = score;\n                                    rotation = rot;\n                                    newTickInterval = step;\n                                }\n                            }\n                        });\n                    }\n\n                } else if (!labelOptions.step) { // #4411\n                    newTickInterval = getStep(labelMetrics.h);\n                }\n\n                this.autoRotation = autoRotation;\n                this.labelRotation = pick(rotation, rotationOption);\n\n                return newTickInterval;\n            },\n\n            /**\n             * Get the general slot width for this axis. This may change between the pre-render (from Axis.getOffset) \n             * and the final tick rendering and placement (#5086).\n             */\n            getSlotWidth: function() {\n                var chart = this.chart,\n                    horiz = this.horiz,\n                    labelOptions = this.options.labels,\n                    slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n                    marginLeft = chart.margin[3];\n\n                return (\n                    horiz &&\n                    (labelOptions.step || 0) < 2 &&\n                    !labelOptions.rotation && // #4415\n                    ((this.staggerLines || 1) * this.len) / slotCount\n                ) || (!horiz && (\n                    (marginLeft && (marginLeft - chart.spacing[3])) ||\n                    chart.chartWidth * 0.33\n                )); // #1580, #1931\n\n            },\n\n            /**\n             * Render the axis labels and determine whether ellipsis or rotation need to be applied\n             */\n            renderUnsquish: function() {\n                var chart = this.chart,\n                    renderer = chart.renderer,\n                    tickPositions = this.tickPositions,\n                    ticks = this.ticks,\n                    labelOptions = this.options.labels,\n                    horiz = this.horiz,\n                    slotWidth = this.getSlotWidth(),\n                    innerWidth = Math.max(1, Math.round(slotWidth - 2 * (labelOptions.padding || 5))),\n                    attr = {},\n                    labelMetrics = this.labelMetrics(),\n                    textOverflowOption = labelOptions.style && labelOptions.style.textOverflow,\n                    css,\n                    maxLabelLength = 0,\n                    label,\n                    i,\n                    pos;\n\n                // Set rotation option unless it is \"auto\", like in gauges\n                if (!isString(labelOptions.rotation)) {\n                    attr.rotation = labelOptions.rotation || 0; // #4443\n                }\n\n                // Get the longest label length\n                each(tickPositions, function(tick) {\n                    tick = ticks[tick];\n                    if (tick && tick.labelLength > maxLabelLength) {\n                        maxLabelLength = tick.labelLength;\n                    }\n                });\n                this.maxLabelLength = maxLabelLength;\n\n\n                // Handle auto rotation on horizontal axis\n                if (this.autoRotation) {\n\n                    // Apply rotation only if the label is too wide for the slot, and\n                    // the label is wider than its height.\n                    if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {\n                        attr.rotation = this.labelRotation;\n                    } else {\n                        this.labelRotation = 0;\n                    }\n\n                    // Handle word-wrap or ellipsis on vertical axis\n                } else if (slotWidth) {\n                    // For word-wrap or ellipsis\n                    css = {\n                        width: innerWidth + 'px'\n                    };\n\n                    if (!textOverflowOption) {\n                        css.textOverflow = 'clip';\n\n                        // On vertical axis, only allow word wrap if there is room for more lines.\n                        i = tickPositions.length;\n                        while (!horiz && i--) {\n                            pos = tickPositions[i];\n                            label = ticks[pos].label;\n                            if (label) {\n                                // Reset ellipsis in order to get the correct bounding box (#4070)\n                                if (label.styles && label.styles.textOverflow === 'ellipsis') {\n                                    label.css({\n                                        textOverflow: 'clip'\n                                    });\n\n                                    // Set the correct width in order to read the bounding box height (#4678, #5034)\n                                } else if (ticks[pos].labelLength > slotWidth) {\n                                    label.css({\n                                        width: slotWidth + 'px'\n                                    });\n                                }\n\n                                if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {\n                                    label.specCss = {\n                                        textOverflow: 'ellipsis'\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n\n\n                // Add ellipsis if the label length is significantly longer than ideal\n                if (attr.rotation) {\n                    css = {\n                        width: (maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : chart.chartHeight) + 'px'\n                    };\n                    if (!textOverflowOption) {\n                        css.textOverflow = 'ellipsis';\n                    }\n                }\n\n                // Set the explicit or automatic label alignment\n                this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);\n                if (this.labelAlign) {\n                    attr.align = this.labelAlign;\n                }\n\n                // Apply general and specific CSS\n                each(tickPositions, function(pos) {\n                    var tick = ticks[pos],\n                        label = tick && tick.label;\n                    if (label) {\n                        label.attr(attr); // This needs to go before the CSS in old IE (#4502)\n                        if (css) {\n                            label.css(merge(css, label.specCss));\n                        }\n                        delete label.specCss;\n                        tick.rotation = attr.rotation;\n                    }\n                });\n\n                // Note: Why is this not part of getLabelPosition?\n                this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);\n            },\n\n            /**\n             * Return true if the axis has associated data\n             */\n            hasData: function() {\n                return this.hasVisibleSeries || (defined(this.min) && defined(this.max) && !!this.tickPositions);\n            },\n\n            /**\n             * Adds the title defined in axis.options.title.\n             * @param {Boolean} display - whether or not to display the title\n             */\n            addTitle: function(display) {\n                var axis = this,\n                    renderer = axis.chart.renderer,\n                    horiz = axis.horiz,\n                    opposite = axis.opposite,\n                    options = axis.options,\n                    axisTitleOptions = options.title,\n                    textAlign;\n\n                if (!axis.axisTitle) {\n                    textAlign = axisTitleOptions.textAlign;\n                    if (!textAlign) {\n                        textAlign = (horiz ? {\n                            low: 'left',\n                            middle: 'center',\n                            high: 'right'\n                        } : {\n                            low: opposite ? 'right' : 'left',\n                            middle: 'center',\n                            high: opposite ? 'left' : 'right'\n                        })[axisTitleOptions.align];\n                    }\n                    axis.axisTitle = renderer.text(\n                            axisTitleOptions.text,\n                            0,\n                            0,\n                            axisTitleOptions.useHTML\n                        )\n                        .attr({\n                            zIndex: 7,\n                            rotation: axisTitleOptions.rotation || 0,\n                            align: textAlign\n                        })\n                        .addClass('highcharts-axis-title')\n\n                        .css(axisTitleOptions.style)\n\n                        .add(axis.axisGroup);\n                    axis.axisTitle.isNew = true;\n                }\n\n                // hide or show the title depending on whether showEmpty is set\n                axis.axisTitle[display ? 'show' : 'hide'](true);\n            },\n\n            /**\n             * Generates a tick for initial positioning.\n             *\n             * @private\n             * @param  {number} pos\n             *         The tick position in axis values.\n             * @param  {number} i\n             *         The index of the tick in {@link Axis.tickPositions}.\n             */\n            generateTick: function(pos) {\n                var ticks = this.ticks;\n\n                if (!ticks[pos]) {\n                    ticks[pos] = new Tick(this, pos);\n                } else {\n                    ticks[pos].addLabel(); // update labels depending on tick interval\n                }\n            },\n\n            /**\n             * Render the tick labels to a preliminary position to get their sizes\n             */\n            getOffset: function() {\n                var axis = this,\n                    chart = axis.chart,\n                    renderer = chart.renderer,\n                    options = axis.options,\n                    tickPositions = axis.tickPositions,\n                    ticks = axis.ticks,\n                    horiz = axis.horiz,\n                    side = axis.side,\n                    invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side,\n                    hasData,\n                    showAxis,\n                    titleOffset = 0,\n                    titleOffsetOption,\n                    titleMargin = 0,\n                    axisTitleOptions = options.title,\n                    labelOptions = options.labels,\n                    labelOffset = 0, // reset\n                    labelOffsetPadded,\n                    axisOffset = chart.axisOffset,\n                    clipOffset = chart.clipOffset,\n                    clip,\n                    directionFactor = [-1, 1, 1, -1][side],\n                    className = options.className,\n                    axisParent = axis.axisParent, // Used in color axis\n                    lineHeightCorrection,\n                    tickSize = this.tickSize('tick');\n\n                // For reuse in Axis.render\n                hasData = axis.hasData();\n                axis.showAxis = showAxis = hasData || pick(options.showEmpty, true);\n\n                // Set/reset staggerLines\n                axis.staggerLines = axis.horiz && labelOptions.staggerLines;\n\n                // Create the axisGroup and gridGroup elements on first iteration\n                if (!axis.axisGroup) {\n                    axis.gridGroup = renderer.g('grid')\n                        .attr({\n                            zIndex: options.gridZIndex || 1\n                        })\n                        .addClass('highcharts-' + this.coll.toLowerCase() + '-grid ' + (className || ''))\n                        .add(axisParent);\n                    axis.axisGroup = renderer.g('axis')\n                        .attr({\n                            zIndex: options.zIndex || 2\n                        })\n                        .addClass('highcharts-' + this.coll.toLowerCase() + ' ' + (className || ''))\n                        .add(axisParent);\n                    axis.labelGroup = renderer.g('axis-labels')\n                        .attr({\n                            zIndex: labelOptions.zIndex || 7\n                        })\n                        .addClass('highcharts-' + axis.coll.toLowerCase() + '-labels ' + (className || ''))\n                        .add(axisParent);\n                }\n\n                if (hasData || axis.isLinked) {\n\n                    // Generate ticks\n                    each(tickPositions, function(pos, i) {\n                        // i is not used here, but may be used in overrides\n                        axis.generateTick(pos, i);\n                    });\n\n                    axis.renderUnsquish();\n\n\n                    // Left side must be align: right and right side must have align: left for labels\n                    if (labelOptions.reserveSpace !== false && (side === 0 || side === 2 || {\n                            1: 'left',\n                            3: 'right'\n                        }[side] === axis.labelAlign || axis.labelAlign === 'center')) {\n                        each(tickPositions, function(pos) {\n\n                            // get the highest offset\n                            labelOffset = Math.max(\n                                ticks[pos].getLabelSize(),\n                                labelOffset\n                            );\n                        });\n                    }\n\n                    if (axis.staggerLines) {\n                        labelOffset *= axis.staggerLines;\n                        axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);\n                    }\n\n\n                } else { // doesn't have data\n                    objectEach(ticks, function(tick, n) {\n                        tick.destroy();\n                        delete ticks[n];\n                    });\n                }\n\n                if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {\n                    axis.addTitle(showAxis);\n\n                    if (showAxis && axisTitleOptions.reserveSpace !== false) {\n                        axis.titleOffset = titleOffset =\n                            axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];\n                        titleOffsetOption = axisTitleOptions.offset;\n                        titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);\n                    }\n                }\n\n                // Render the axis line\n                axis.renderLine();\n\n                // handle automatic or user set offset\n                axis.offset = directionFactor * pick(options.offset, axisOffset[side]);\n\n                axis.tickRotCorr = axis.tickRotCorr || {\n                    x: 0,\n                    y: 0\n                }; // polar\n                if (side === 0) {\n                    lineHeightCorrection = -axis.labelMetrics().h;\n                } else if (side === 2) {\n                    lineHeightCorrection = axis.tickRotCorr.y;\n                } else {\n                    lineHeightCorrection = 0;\n                }\n\n                // Find the padded label offset\n                labelOffsetPadded = Math.abs(labelOffset) + titleMargin;\n                if (labelOffset) {\n                    labelOffsetPadded -= lineHeightCorrection;\n                    labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);\n                }\n                axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);\n\n                axisOffset[side] = Math.max(\n                    axisOffset[side],\n                    axis.axisTitleMargin + titleOffset + directionFactor * axis.offset,\n                    labelOffsetPadded, // #3027\n                    hasData && tickPositions.length && tickSize ?\n                    tickSize[0] + directionFactor * axis.offset :\n                    0 // #4866\n                );\n\n                // Decide the clipping needed to keep the graph inside the plot area and\n                // axis lines\n                clip = Math.floor(axis.axisLine.strokeWidth() / 2) * 2; // #4308, #4371\n                if (options.offset > 0) {\n                    clip -= options.offset * 2;\n                }\n                clipOffset[invertedSide] = Math.max(\n                    clipOffset[invertedSide] || clip,\n                    clip\n                );\n            },\n\n            /**\n             * Internal function to get the path for the axis line. Extended for polar\n             * charts.\n             *\n             * @param  {Number} lineWidth\n             *         The line width in pixels.\n             * @return {Array}\n             *         The SVG path definition in array form.\n             */\n            getLinePath: function(lineWidth) {\n                var chart = this.chart,\n                    opposite = this.opposite,\n                    offset = this.offset,\n                    horiz = this.horiz,\n                    lineLeft = this.left + (opposite ? this.width : 0) + offset,\n                    lineTop = chart.chartHeight - this.bottom -\n                    (opposite ? this.height : 0) + offset;\n\n                if (opposite) {\n                    lineWidth *= -1; // crispify the other way - #1480, #1687\n                }\n\n                return chart.renderer\n                    .crispLine([\n                        'M',\n                        horiz ?\n                        this.left :\n                        lineLeft,\n                        horiz ?\n                        lineTop :\n                        this.top,\n                        'L',\n                        horiz ?\n                        chart.chartWidth - this.right :\n                        lineLeft,\n                        horiz ?\n                        lineTop :\n                        chart.chartHeight - this.bottom\n                    ], lineWidth);\n            },\n\n            /**\n             * Render the axis line\n             */\n            renderLine: function() {\n                if (!this.axisLine) {\n                    this.axisLine = this.chart.renderer.path()\n                        .addClass('highcharts-axis-line')\n                        .add(this.axisGroup);\n\n\n                    this.axisLine.attr({\n                        stroke: this.options.lineColor,\n                        'stroke-width': this.options.lineWidth,\n                        zIndex: 7\n                    });\n\n                }\n            },\n\n            /**\n             * Position the title\n             */\n            getTitlePosition: function() {\n                // compute anchor points for each of the title align options\n                var horiz = this.horiz,\n                    axisLeft = this.left,\n                    axisTop = this.top,\n                    axisLength = this.len,\n                    axisTitleOptions = this.options.title,\n                    margin = horiz ? axisLeft : axisTop,\n                    opposite = this.opposite,\n                    offset = this.offset,\n                    xOption = axisTitleOptions.x || 0,\n                    yOption = axisTitleOptions.y || 0,\n                    fontSize = this.chart.renderer.fontMetrics(axisTitleOptions.style && axisTitleOptions.style.fontSize, this.axisTitle).f,\n\n                    // the position in the length direction of the axis\n                    alongAxis = {\n                        low: margin + (horiz ? 0 : axisLength),\n                        middle: margin + axisLength / 2,\n                        high: margin + (horiz ? axisLength : 0)\n                    }[axisTitleOptions.align],\n\n                    // the position in the perpendicular direction of the axis\n                    offAxis = (horiz ? axisTop + this.height : axisLeft) +\n                    (horiz ? 1 : -1) * // horizontal axis reverses the margin\n                    (opposite ? -1 : 1) * // so does opposite axes\n                    this.axisTitleMargin +\n                    (this.side === 2 ? fontSize : 0);\n\n                return {\n                    x: horiz ?\n                        alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset + xOption,\n                    y: horiz ?\n                        offAxis + yOption - (opposite ? this.height : 0) + offset : alongAxis + yOption\n                };\n            },\n\n            /**\n             * Render a minor tick into the given position. If a minor tick already \n             * exists in this position, move it.\n             * @param  {number} pos - The position in axis values.\n             */\n            renderMinorTick: function(pos) {\n                var slideInTicks = this.chart.hasRendered && isNumber(this.oldMin),\n                    minorTicks = this.minorTicks;\n\n                if (!minorTicks[pos]) {\n                    minorTicks[pos] = new Tick(this, pos, 'minor');\n                }\n\n                // Render new ticks in old position\n                if (slideInTicks && minorTicks[pos].isNew) {\n                    minorTicks[pos].render(null, true);\n                }\n\n                minorTicks[pos].render(null, false, 1);\n            },\n\n            /**\n             * Render a major tick into the given position. If a tick already exists\n             * in this position, move it.\n             * @param  {number} pos - The position in axis values\n             * @param  {number} i - The tick index\n             */\n            renderTick: function(pos, i) {\n                var isLinked = this.isLinked,\n                    ticks = this.ticks,\n                    slideInTicks = this.chart.hasRendered && isNumber(this.oldMin);\n\n                // Linked axes need an extra check to find out if\n                if (!isLinked || (pos >= this.min && pos <= this.max)) {\n\n                    if (!ticks[pos]) {\n                        ticks[pos] = new Tick(this, pos);\n                    }\n\n                    // render new ticks in old position\n                    if (slideInTicks && ticks[pos].isNew) {\n                        ticks[pos].render(i, true, 0.1);\n                    }\n\n                    ticks[pos].render(i);\n                }\n            },\n\n            /**\n             * Render the axis\n             */\n            render: function() {\n                var axis = this,\n                    chart = axis.chart,\n                    renderer = chart.renderer,\n                    options = axis.options,\n                    isLog = axis.isLog,\n                    lin2log = axis.lin2log,\n                    isLinked = axis.isLinked,\n                    tickPositions = axis.tickPositions,\n                    axisTitle = axis.axisTitle,\n                    ticks = axis.ticks,\n                    minorTicks = axis.minorTicks,\n                    alternateBands = axis.alternateBands,\n                    stackLabelOptions = options.stackLabels,\n                    alternateGridColor = options.alternateGridColor,\n                    tickmarkOffset = axis.tickmarkOffset,\n                    axisLine = axis.axisLine,\n                    showAxis = axis.showAxis,\n                    animation = animObject(renderer.globalAnimation),\n                    from,\n                    to;\n\n                // Reset\n                axis.labelEdge.length = 0;\n                //axis.justifyToPlot = overflow === 'justify';\n                axis.overlap = false;\n\n                // Mark all elements inActive before we go over and mark the active ones\n                each([ticks, minorTicks, alternateBands], function(coll) {\n                    objectEach(coll, function(tick) {\n                        tick.isActive = false;\n                    });\n                });\n\n                // If the series has data draw the ticks. Else only the line and title\n                if (axis.hasData() || isLinked) {\n\n                    // minor ticks\n                    if (axis.minorTickInterval && !axis.categories) {\n                        each(axis.getMinorTickPositions(), function(pos) {\n                            axis.renderMinorTick(pos);\n                        });\n                    }\n\n                    // Major ticks. Pull out the first item and render it last so that\n                    // we can get the position of the neighbour label. #808.\n                    if (tickPositions.length) { // #1300\n                        each(tickPositions, function(pos, i) {\n                            axis.renderTick(pos, i);\n                        });\n                        // In a categorized axis, the tick marks are displayed between labels. So\n                        // we need to add a tick mark and grid line at the left edge of the X axis.\n                        if (tickmarkOffset && (axis.min === 0 || axis.single)) {\n                            if (!ticks[-1]) {\n                                ticks[-1] = new Tick(axis, -1, null, true);\n                            }\n                            ticks[-1].render(-1);\n                        }\n\n                    }\n\n                    // alternate grid color\n                    if (alternateGridColor) {\n                        each(tickPositions, function(pos, i) {\n                            to = tickPositions[i + 1] !== undefined ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;\n                            if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) { // #2248, #4660\n                                if (!alternateBands[pos]) {\n                                    alternateBands[pos] = new H.PlotLineOrBand(axis);\n                                }\n                                from = pos + tickmarkOffset; // #949\n                                alternateBands[pos].options = {\n                                    from: isLog ? lin2log(from) : from,\n                                    to: isLog ? lin2log(to) : to,\n                                    color: alternateGridColor\n                                };\n                                alternateBands[pos].render();\n                                alternateBands[pos].isActive = true;\n                            }\n                        });\n                    }\n\n                    // custom plot lines and bands\n                    if (!axis._addedPlotLB) { // only first time\n                        each((options.plotLines || []).concat(options.plotBands || []), function(plotLineOptions) {\n                            axis.addPlotBandOrLine(plotLineOptions);\n                        });\n                        axis._addedPlotLB = true;\n                    }\n\n                } // end if hasData\n\n                // Remove inactive ticks\n                each([ticks, minorTicks, alternateBands], function(coll) {\n                    var i,\n                        forDestruction = [],\n                        delay = animation.duration,\n                        destroyInactiveItems = function() {\n                            i = forDestruction.length;\n                            while (i--) {\n                                // When resizing rapidly, the same items may be destroyed in different timeouts,\n                                // or the may be reactivated\n                                if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {\n                                    coll[forDestruction[i]].destroy();\n                                    delete coll[forDestruction[i]];\n                                }\n                            }\n\n                        };\n\n                    objectEach(coll, function(tick, pos) {\n                        if (!tick.isActive) {\n                            // Render to zero opacity\n                            tick.render(pos, false, 0);\n                            tick.isActive = false;\n                            forDestruction.push(pos);\n                        }\n                    });\n\n                    // When the objects are finished fading out, destroy them\n                    syncTimeout(\n                        destroyInactiveItems,\n                        coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay\n                    );\n                });\n\n                // Set the axis line path\n                if (axisLine) {\n                    axisLine[axisLine.isPlaced ? 'animate' : 'attr']({\n                        d: this.getLinePath(axisLine.strokeWidth())\n                    });\n                    axisLine.isPlaced = true;\n\n                    // Show or hide the line depending on options.showEmpty\n                    axisLine[showAxis ? 'show' : 'hide'](true);\n                }\n\n                if (axisTitle && showAxis) {\n                    var titleXy = axis.getTitlePosition();\n                    if (isNumber(titleXy.y)) {\n                        axisTitle[axisTitle.isNew ? 'attr' : 'animate'](titleXy);\n                        axisTitle.isNew = false;\n                    } else {\n                        axisTitle.attr('y', -9999);\n                        axisTitle.isNew = true;\n                    }\n                }\n\n                // Stacked totals:\n                if (stackLabelOptions && stackLabelOptions.enabled) {\n                    axis.renderStackTotals();\n                }\n                // End stacked totals\n\n                axis.isDirty = false;\n            },\n\n            /**\n             * Redraw the axis to reflect changes in the data or axis extremes\n             */\n            redraw: function() {\n\n                if (this.visible) {\n                    // render the axis\n                    this.render();\n\n                    // move plot lines and bands\n                    each(this.plotLinesAndBands, function(plotLine) {\n                        plotLine.render();\n                    });\n                }\n\n                // mark associated series as dirty and ready for redraw\n                each(this.series, function(series) {\n                    series.isDirty = true;\n                });\n\n            },\n\n            // Properties to survive after destroy, needed for Axis.update (#4317,\n            // #5773, #5881).\n            keepProps: ['extKey', 'hcEvents', 'names', 'series', 'userMax', 'userMin'],\n\n            /**\n             * Destroys an Axis instance. See {@link Axis#remove} for the API endpoint\n             * to fully remove the axis.\n             *\n             * @private\n             * @param  {Boolean} keepEvents\n             *         Whether to preserve events, used internally in Axis.update.\n             */\n            destroy: function(keepEvents) {\n                var axis = this,\n                    stacks = axis.stacks,\n                    plotLinesAndBands = axis.plotLinesAndBands,\n                    plotGroup,\n                    i;\n\n                // Remove the events\n                if (!keepEvents) {\n                    removeEvent(axis);\n                }\n\n                // Destroy each stack total\n                objectEach(stacks, function(stack, stackKey) {\n                    destroyObjectProperties(stack);\n\n                    stacks[stackKey] = null;\n                });\n\n                // Destroy collections\n                each([axis.ticks, axis.minorTicks, axis.alternateBands], function(coll) {\n                    destroyObjectProperties(coll);\n                });\n                if (plotLinesAndBands) {\n                    i = plotLinesAndBands.length;\n                    while (i--) { // #1975\n                        plotLinesAndBands[i].destroy();\n                    }\n                }\n\n                // Destroy local variables\n                each(['stackTotalGroup', 'axisLine', 'axisTitle', 'axisGroup', 'gridGroup', 'labelGroup', 'cross'], function(prop) {\n                    if (axis[prop]) {\n                        axis[prop] = axis[prop].destroy();\n                    }\n                });\n\n                // Destroy each generated group for plotlines and plotbands\n                for (plotGroup in axis.plotLinesAndBandsGroups) {\n                    axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();\n                }\n\n                // Delete all properties and fall back to the prototype.\n                objectEach(axis, function(val, key) {\n                    if (inArray(key, axis.keepProps) === -1) {\n                        delete axis[key];\n                    }\n                });\n            },\n\n            /**\n             * Internal function to draw a crosshair.\n             *\n             * @param  {PointerEvent} [e]\n             *         The event arguments from the modified pointer event, extended \n             *         with `chartX` and `chartY`\n             * @param  {Point} [point]\n             *         The Point object if the crosshair snaps to points.\n             */\n            drawCrosshair: function(e, point) {\n\n                var path,\n                    options = this.crosshair,\n                    snap = pick(options.snap, true),\n                    pos,\n                    categorized,\n                    graphic = this.cross;\n\n                // Use last available event when updating non-snapped crosshairs without\n                // mouse interaction (#5287)\n                if (!e) {\n                    e = this.cross && this.cross.e;\n                }\n\n                if (\n                    // Disabled in options\n                    !this.crosshair ||\n                    // Snap\n                    ((defined(point) || !snap) === false)\n                ) {\n                    this.hideCrosshair();\n                } else {\n\n                    // Get the path\n                    if (!snap) {\n                        pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);\n                    } else if (defined(point)) {\n                        pos = this.isXAxis ? point.plotX : this.len - point.plotY; // #3834\n                    }\n\n                    if (defined(pos)) {\n                        path = this.getPlotLinePath(\n                            // First argument, value, only used on radial\n                            point && (this.isXAxis ? point.x : pick(point.stackY, point.y)),\n                            null,\n                            null,\n                            null,\n                            pos // Translated position\n                        ) || null; // #3189\n                    }\n\n                    if (!defined(path)) {\n                        this.hideCrosshair();\n                        return;\n                    }\n\n                    categorized = this.categories && !this.isRadial;\n\n                    // Draw the cross\n                    if (!graphic) {\n                        this.cross = graphic = this.chart.renderer\n                            .path()\n                            .addClass('highcharts-crosshair highcharts-crosshair-' +\n                                (categorized ? 'category ' : 'thin ') + options.className)\n                            .attr({\n                                zIndex: pick(options.zIndex, 2)\n                            })\n                            .add();\n\n\n                        // Presentational attributes\n                        graphic.attr({\n                            'stroke': options.color || (categorized ? color('#ccd6eb').setOpacity(0.25).get() : '#cccccc'),\n                            'stroke-width': pick(options.width, 1)\n                        });\n                        if (options.dashStyle) {\n                            graphic.attr({\n                                dashstyle: options.dashStyle\n                            });\n                        }\n\n\n                    }\n\n                    graphic.show().attr({\n                        d: path\n                    });\n\n                    if (categorized && !options.width) {\n                        graphic.attr({\n                            'stroke-width': this.transA\n                        });\n                    }\n                    this.cross.e = e;\n                }\n            },\n\n            /**\n             *\tHide the crosshair.\n             */\n            hideCrosshair: function() {\n                if (this.cross) {\n                    this.cross.hide();\n                }\n            }\n        }); // end Axis\n\n        H.Axis = Axis;\n        return Axis;\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var Axis = H.Axis,\n            Date = H.Date,\n            dateFormat = H.dateFormat,\n            defaultOptions = H.defaultOptions,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            getMagnitude = H.getMagnitude,\n            getTZOffset = H.getTZOffset,\n            normalizeTickInterval = H.normalizeTickInterval,\n            pick = H.pick,\n            timeUnits = H.timeUnits;\n        /**\n         * Set the tick positions to a time unit that makes sense, for example\n         * on the first of each month or on every Monday. Return an array\n         * with the time positions. Used in datetime axes as well as for grouping\n         * data on a datetime axis.\n         *\n         * @param {Object} normalizedInterval The interval in axis values (ms) and the count\n         * @param {Number} min The minimum in axis values\n         * @param {Number} max The maximum in axis values\n         * @param {Number} startOfWeek\n         */\n        Axis.prototype.getTimeTicks = function(normalizedInterval, min, max, startOfWeek) {\n            var tickPositions = [],\n                i,\n                higherRanks = {},\n                useUTC = defaultOptions.global.useUTC,\n                minYear, // used in months and years as a basis for Date.UTC()\n                // When crossing DST, use the max. Resolves #6278.\n                minDate = new Date(min - Math.max(getTZOffset(min), getTZOffset(max))),\n                makeTime = Date.hcMakeTime,\n                interval = normalizedInterval.unitRange,\n                count = normalizedInterval.count,\n                variableDayLength;\n\n            if (defined(min)) { // #1300\n                minDate[Date.hcSetMilliseconds](interval >= timeUnits.second ? 0 : // #3935\n                    count * Math.floor(minDate.getMilliseconds() / count)); // #3652, #3654\n\n                if (interval >= timeUnits.second) { // second\n                    minDate[Date.hcSetSeconds](interval >= timeUnits.minute ? 0 : // #3935\n                        count * Math.floor(minDate.getSeconds() / count));\n                }\n\n                if (interval >= timeUnits.minute) { // minute\n                    minDate[Date.hcSetMinutes](interval >= timeUnits.hour ? 0 :\n                        count * Math.floor(minDate[Date.hcGetMinutes]() / count));\n                }\n\n                if (interval >= timeUnits.hour) { // hour\n                    minDate[Date.hcSetHours](interval >= timeUnits.day ? 0 :\n                        count * Math.floor(minDate[Date.hcGetHours]() / count));\n                }\n\n                if (interval >= timeUnits.day) { // day\n                    minDate[Date.hcSetDate](interval >= timeUnits.month ? 1 :\n                        count * Math.floor(minDate[Date.hcGetDate]() / count));\n                }\n\n                if (interval >= timeUnits.month) { // month\n                    minDate[Date.hcSetMonth](interval >= timeUnits.year ? 0 :\n                        count * Math.floor(minDate[Date.hcGetMonth]() / count));\n                    minYear = minDate[Date.hcGetFullYear]();\n                }\n\n                if (interval >= timeUnits.year) { // year\n                    minYear -= minYear % count;\n                    minDate[Date.hcSetFullYear](minYear);\n                }\n\n                // week is a special case that runs outside the hierarchy\n                if (interval === timeUnits.week) {\n                    // get start of current week, independent of count\n                    minDate[Date.hcSetDate](minDate[Date.hcGetDate]() - minDate[Date.hcGetDay]() +\n                        pick(startOfWeek, 1));\n                }\n\n\n                // Get basics for variable time spans\n                minYear = minDate[Date.hcGetFullYear]();\n                var minMonth = minDate[Date.hcGetMonth](),\n                    minDateDate = minDate[Date.hcGetDate](),\n                    minHours = minDate[Date.hcGetHours]();\n\n\n                // Handle local timezone offset\n                if (Date.hcTimezoneOffset || Date.hcGetTimezoneOffset) {\n\n                    // Detect whether we need to take the DST crossover into\n                    // consideration. If we're crossing over DST, the day length may be\n                    // 23h or 25h and we need to compute the exact clock time for each\n                    // tick instead of just adding hours. This comes at a cost, so first\n                    // we found out if it is needed. #4951.\n                    variableDayLength =\n                        (!useUTC || !!Date.hcGetTimezoneOffset) &&\n                        (\n                            // Long range, assume we're crossing over.\n                            max - min > 4 * timeUnits.month ||\n                            // Short range, check if min and max are in different time \n                            // zones.\n                            getTZOffset(min) !== getTZOffset(max)\n                        );\n\n                    // Adjust minDate to the offset date\n                    minDate = minDate.getTime();\n                    minDate = new Date(minDate + getTZOffset(minDate));\n                }\n\n\n                // Iterate and add tick positions at appropriate values\n                var time = minDate.getTime();\n                i = 1;\n                while (time < max) {\n                    tickPositions.push(time);\n\n                    // if the interval is years, use Date.UTC to increase years\n                    if (interval === timeUnits.year) {\n                        time = makeTime(minYear + i * count, 0);\n\n                        // if the interval is months, use Date.UTC to increase months\n                    } else if (interval === timeUnits.month) {\n                        time = makeTime(minYear, minMonth + i * count);\n\n                        // if we're using global time, the interval is not fixed as it jumps\n                        // one hour at the DST crossover\n                    } else if (variableDayLength && (interval === timeUnits.day || interval === timeUnits.week)) {\n                        time = makeTime(minYear, minMonth, minDateDate +\n                            i * count * (interval === timeUnits.day ? 1 : 7));\n\n                    } else if (variableDayLength && interval === timeUnits.hour) {\n                        time = makeTime(minYear, minMonth, minDateDate, minHours + i * count);\n\n                        // else, the interval is fixed and we use simple addition\n                    } else {\n                        time += interval * count;\n                    }\n\n                    i++;\n                }\n\n                // push the last time\n                tickPositions.push(time);\n\n\n                // Handle higher ranks. Mark new days if the time is on midnight\n                // (#950, #1649, #1760, #3349). Use a reasonable dropout threshold to \n                // prevent looping over dense data grouping (#6156).\n                if (interval <= timeUnits.hour && tickPositions.length < 10000) {\n                    each(tickPositions, function(time) {\n                        if (\n                            // Speed optimization, no need to run dateFormat unless\n                            // we're on a full or half hour\n                            time % 1800000 === 0 &&\n                            // Check for local or global midnight\n                            dateFormat('%H%M%S%L', time) === '000000000'\n                        ) {\n                            higherRanks[time] = 'day';\n                        }\n                    });\n                }\n            }\n\n\n            // record information on the chosen unit - for dynamic label formatter\n            tickPositions.info = extend(normalizedInterval, {\n                higherRanks: higherRanks,\n                totalRange: interval * count\n            });\n\n            return tickPositions;\n        };\n\n        /**\n         * Get a normalized tick interval for dates. Returns a configuration object with\n         * unit range (interval), count and name. Used to prepare data for getTimeTicks.\n         * Previously this logic was part of getTimeTicks, but as getTimeTicks now runs\n         * of segments in stock charts, the normalizing logic was extracted in order to\n         * prevent it for running over again for each segment having the same interval.\n         * #662, #697.\n         */\n        Axis.prototype.normalizeTimeTickInterval = function(tickInterval, unitsOption) {\n            var units = unitsOption || [\n                    [\n                        'millisecond', // unit name\n                        [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples\n                    ],\n                    [\n                        'second', [1, 2, 5, 10, 15, 30]\n                    ],\n                    [\n                        'minute', [1, 2, 5, 10, 15, 30]\n                    ],\n                    [\n                        'hour', [1, 2, 3, 4, 6, 8, 12]\n                    ],\n                    [\n                        'day', [1, 2]\n                    ],\n                    [\n                        'week', [1, 2]\n                    ],\n                    [\n                        'month', [1, 2, 3, 4, 6]\n                    ],\n                    [\n                        'year',\n                        null\n                    ]\n                ],\n                unit = units[units.length - 1], // default unit is years\n                interval = timeUnits[unit[0]],\n                multiples = unit[1],\n                count,\n                i;\n\n            // loop through the units to find the one that best fits the tickInterval\n            for (i = 0; i < units.length; i++) {\n                unit = units[i];\n                interval = timeUnits[unit[0]];\n                multiples = unit[1];\n\n\n                if (units[i + 1]) {\n                    // lessThan is in the middle between the highest multiple and the next unit.\n                    var lessThan = (interval * multiples[multiples.length - 1] +\n                        timeUnits[units[i + 1][0]]) / 2;\n\n                    // break and keep the current unit\n                    if (tickInterval <= lessThan) {\n                        break;\n                    }\n                }\n            }\n\n            // prevent 2.5 years intervals, though 25, 250 etc. are allowed\n            if (interval === timeUnits.year && tickInterval < 5 * interval) {\n                multiples = [1, 2, 5];\n            }\n\n            // get the count\n            count = normalizeTickInterval(\n                tickInterval / interval,\n                multiples,\n                unit[0] === 'year' ? Math.max(getMagnitude(tickInterval / interval), 1) : 1 // #1913, #2360\n            );\n\n            return {\n                unitRange: interval,\n                count: count,\n                unitName: unit[0]\n            };\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var Axis = H.Axis,\n            getMagnitude = H.getMagnitude,\n            map = H.map,\n            normalizeTickInterval = H.normalizeTickInterval,\n            pick = H.pick;\n        /**\n         * Methods defined on the Axis prototype\n         */\n\n        /**\n         * Set the tick positions of a logarithmic axis\n         */\n        Axis.prototype.getLogTickPositions = function(interval, min, max, minor) {\n            var axis = this,\n                options = axis.options,\n                axisLength = axis.len,\n                lin2log = axis.lin2log,\n                log2lin = axis.log2lin,\n                // Since we use this method for both major and minor ticks,\n                // use a local variable and return the result\n                positions = [];\n\n            // Reset\n            if (!minor) {\n                axis._minorAutoInterval = null;\n            }\n\n            // First case: All ticks fall on whole logarithms: 1, 10, 100 etc.\n            if (interval >= 0.5) {\n                interval = Math.round(interval);\n                positions = axis.getLinearTickPositions(interval, min, max);\n\n                // Second case: We need intermediary ticks. For example\n                // 1, 2, 4, 6, 8, 10, 20, 40 etc.\n            } else if (interval >= 0.08) {\n                var roundedMin = Math.floor(min),\n                    intermediate,\n                    i,\n                    j,\n                    len,\n                    pos,\n                    lastPos,\n                    break2;\n\n                if (interval > 0.3) {\n                    intermediate = [1, 2, 4];\n                } else if (interval > 0.15) { // 0.2 equals five minor ticks per 1, 10, 100 etc\n                    intermediate = [1, 2, 4, 6, 8];\n                } else { // 0.1 equals ten minor ticks per 1, 10, 100 etc\n                    intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n                }\n\n                for (i = roundedMin; i < max + 1 && !break2; i++) {\n                    len = intermediate.length;\n                    for (j = 0; j < len && !break2; j++) {\n                        pos = log2lin(lin2log(i) * intermediate[j]);\n                        if (pos > min && (!minor || lastPos <= max) && lastPos !== undefined) { // #1670, lastPos is #3113\n                            positions.push(lastPos);\n                        }\n\n                        if (lastPos > max) {\n                            break2 = true;\n                        }\n                        lastPos = pos;\n                    }\n                }\n\n                // Third case: We are so deep in between whole logarithmic values that\n                // we might as well handle the tick positions like a linear axis. For\n                // example 1.01, 1.02, 1.03, 1.04.\n            } else {\n                var realMin = lin2log(min),\n                    realMax = lin2log(max),\n                    tickIntervalOption = options[minor ? 'minorTickInterval' : 'tickInterval'],\n                    filteredTickIntervalOption = tickIntervalOption === 'auto' ? null : tickIntervalOption,\n                    tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1),\n                    totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;\n\n                interval = pick(\n                    filteredTickIntervalOption,\n                    axis._minorAutoInterval,\n                    (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1)\n                );\n\n                interval = normalizeTickInterval(\n                    interval,\n                    null,\n                    getMagnitude(interval)\n                );\n\n                positions = map(axis.getLinearTickPositions(\n                    interval,\n                    realMin,\n                    realMax\n                ), log2lin);\n\n                if (!minor) {\n                    axis._minorAutoInterval = interval / 5;\n                }\n            }\n\n            // Set the axis-level tickInterval variable\n            if (!minor) {\n                axis.tickInterval = interval;\n            }\n            return positions;\n        };\n\n        Axis.prototype.log2lin = function(num) {\n            return Math.log(num) / Math.LN10;\n        };\n\n        Axis.prototype.lin2log = function(num) {\n            return Math.pow(10, num);\n        };\n\n    }(Highcharts));\n    (function(H, Axis) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var arrayMax = H.arrayMax,\n            arrayMin = H.arrayMin,\n            defined = H.defined,\n            destroyObjectProperties = H.destroyObjectProperties,\n            each = H.each,\n            erase = H.erase,\n            merge = H.merge,\n            pick = H.pick;\n        /*\n         * The object wrapper for plot lines and plot bands\n         * @param {Object} options\n         */\n        H.PlotLineOrBand = function(axis, options) {\n            this.axis = axis;\n\n            if (options) {\n                this.options = options;\n                this.id = options.id;\n            }\n        };\n\n        H.PlotLineOrBand.prototype = {\n\n            /**\n             * Render the plot line or plot band. If it is already existing,\n             * move it.\n             */\n            render: function() {\n                var plotLine = this,\n                    axis = plotLine.axis,\n                    horiz = axis.horiz,\n                    options = plotLine.options,\n                    optionsLabel = options.label,\n                    label = plotLine.label,\n                    to = options.to,\n                    from = options.from,\n                    value = options.value,\n                    isBand = defined(from) && defined(to),\n                    isLine = defined(value),\n                    svgElem = plotLine.svgElem,\n                    isNew = !svgElem,\n                    path = [],\n                    color = options.color,\n                    zIndex = pick(options.zIndex, 0),\n                    events = options.events,\n                    attribs = {\n                        'class': 'highcharts-plot-' + (isBand ? 'band ' : 'line ') + (options.className || '')\n                    },\n                    groupAttribs = {},\n                    renderer = axis.chart.renderer,\n                    groupName = isBand ? 'bands' : 'lines',\n                    group,\n                    log2lin = axis.log2lin;\n\n                // logarithmic conversion\n                if (axis.isLog) {\n                    from = log2lin(from);\n                    to = log2lin(to);\n                    value = log2lin(value);\n                }\n\n\n                // Set the presentational attributes\n                if (isLine) {\n                    attribs = {\n                        stroke: color,\n                        'stroke-width': options.width\n                    };\n                    if (options.dashStyle) {\n                        attribs.dashstyle = options.dashStyle;\n                    }\n\n                } else if (isBand) { // plot band\n                    if (color) {\n                        attribs.fill = color;\n                    }\n                    if (options.borderWidth) {\n                        attribs.stroke = options.borderColor;\n                        attribs['stroke-width'] = options.borderWidth;\n                    }\n                }\n\n\n                // Grouping and zIndex\n                groupAttribs.zIndex = zIndex;\n                groupName += '-' + zIndex;\n\n                group = axis.plotLinesAndBandsGroups[groupName];\n                if (!group) {\n                    axis.plotLinesAndBandsGroups[groupName] = group = renderer.g('plot-' + groupName)\n                        .attr(groupAttribs).add();\n                }\n\n                // Create the path\n                if (isNew) {\n                    plotLine.svgElem = svgElem =\n                        renderer\n                        .path()\n                        .attr(attribs).add(group);\n                }\n\n\n                // Set the path or return\n                if (isLine) {\n                    path = axis.getPlotLinePath(value, svgElem.strokeWidth());\n                } else if (isBand) { // plot band\n                    path = axis.getPlotBandPath(from, to, options);\n                } else {\n                    return;\n                }\n\n\n                // common for lines and bands\n                if (isNew && path && path.length) {\n                    svgElem.attr({\n                        d: path\n                    });\n\n                    // events\n                    if (events) {\n                        H.objectEach(events, function(event, eventType) {\n                            svgElem.on(eventType, function(e) {\n                                events[eventType].apply(plotLine, [e]);\n                            });\n                        });\n                    }\n                } else if (svgElem) {\n                    if (path) {\n                        svgElem.show();\n                        svgElem.animate({\n                            d: path\n                        });\n                    } else {\n                        svgElem.hide();\n                        if (label) {\n                            plotLine.label = label = label.destroy();\n                        }\n                    }\n                }\n\n                // the plot band/line label\n                if (optionsLabel && defined(optionsLabel.text) && path && path.length &&\n                    axis.width > 0 && axis.height > 0 && !path.flat) {\n                    // apply defaults\n                    optionsLabel = merge({\n                        align: horiz && isBand && 'center',\n                        x: horiz ? !isBand && 4 : 10,\n                        verticalAlign: !horiz && isBand && 'middle',\n                        y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,\n                        rotation: horiz && !isBand && 90\n                    }, optionsLabel);\n\n                    this.renderLabel(optionsLabel, path, isBand, zIndex);\n\n                } else if (label) { // move out of sight\n                    label.hide();\n                }\n\n                // chainable\n                return plotLine;\n            },\n\n            /**\n             * Render and align label for plot line or band.\n             */\n            renderLabel: function(optionsLabel, path, isBand, zIndex) {\n                var plotLine = this,\n                    label = plotLine.label,\n                    renderer = plotLine.axis.chart.renderer,\n                    attribs,\n                    xs,\n                    ys,\n                    x,\n                    y;\n\n                // add the SVG element\n                if (!label) {\n                    attribs = {\n                        align: optionsLabel.textAlign || optionsLabel.align,\n                        rotation: optionsLabel.rotation,\n                        'class': 'highcharts-plot-' + (isBand ? 'band' : 'line') + '-label ' + (optionsLabel.className || '')\n                    };\n\n                    attribs.zIndex = zIndex;\n\n                    plotLine.label = label = renderer.text(\n                            optionsLabel.text,\n                            0,\n                            0,\n                            optionsLabel.useHTML\n                        )\n                        .attr(attribs)\n                        .add();\n\n\n                    label.css(optionsLabel.style);\n\n                }\n\n                // get the bounding box and align the label\n                // #3000 changed to better handle choice between plotband or plotline\n                xs = [path[1], path[4], (isBand ? path[6] : path[1])];\n                ys = [path[2], path[5], (isBand ? path[7] : path[2])];\n                x = arrayMin(xs);\n                y = arrayMin(ys);\n\n                label.align(optionsLabel, false, {\n                    x: x,\n                    y: y,\n                    width: arrayMax(xs) - x,\n                    height: arrayMax(ys) - y\n                });\n                label.show();\n            },\n\n            /**\n             * Remove the plot line or band\n             */\n            destroy: function() {\n                // remove it from the lookup\n                erase(this.axis.plotLinesAndBands, this);\n\n                delete this.axis;\n                destroyObjectProperties(this);\n            }\n        };\n\n        /**\n         * Object with members for extending the Axis prototype\n         * @todo Extend directly instead of adding object to Highcharts first\n         */\n\n        H.extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {\n\n            /**\n             * Create the path for a plot band\n             */\n            getPlotBandPath: function(from, to) {\n                var toPath = this.getPlotLinePath(to, null, null, true),\n                    path = this.getPlotLinePath(from, null, null, true),\n                    // #4964 check if chart is inverted or plotband is on yAxis \n                    horiz = this.horiz,\n                    plus = 1,\n                    outside =\n                    (from < this.min && to < this.min) ||\n                    (from > this.max && to > this.max);\n\n                if (path && toPath) {\n\n                    // Flat paths don't need labels (#3836)\n                    if (outside) {\n                        path.flat = path.toString() === toPath.toString();\n                        plus = 0;\n                    }\n\n                    // Add 1 pixel, when coordinates are the same\n                    path.push(\n                        horiz && toPath[4] === path[4] ? toPath[4] + plus : toPath[4], !horiz && toPath[5] === path[5] ? toPath[5] + plus : toPath[5],\n                        horiz && toPath[1] === path[1] ? toPath[1] + plus : toPath[1], !horiz && toPath[2] === path[2] ? toPath[2] + plus : toPath[2]\n                    );\n                } else { // outside the axis area\n                    path = null;\n                }\n\n                return path;\n            },\n\n            /**\n             * Add a plot band after render time.\n             *\n             * @param  {AxisPlotBandsOptions} options\n             *         A configuration object for the plot band, as defined in {@link\n             *         https://api.highcharts.com/highcharts/xAxis.plotBands|\n             *         xAxis.plotBands}.\n             * @return {Object}\n             *         The added plot band.\n             * @sample highcharts/members/axis-addplotband/\n             *         Toggle the plot band from a button\n             */\n            addPlotBand: function(options) {\n                return this.addPlotBandOrLine(options, 'plotBands');\n            },\n\n            /**\n             * Add a plot line after render time.\n             * \n             * @param  {AxisPlotLinesOptions} options\n             *         A configuration object for the plot line, as defined in {@link\n             *         https://api.highcharts.com/highcharts/xAxis.plotLines|\n             *         xAxis.plotLines}.\n             * @return {Object}\n             *         The added plot line.\n             * @sample highcharts/members/axis-addplotline/\n             *         Toggle the plot line from a button\n             */\n            addPlotLine: function(options) {\n                return this.addPlotBandOrLine(options, 'plotLines');\n            },\n\n            /**\n             * Add a plot band or plot line after render time. Called from addPlotBand\n             * and addPlotLine internally.\n             *\n             * @private\n             * @param  options {AxisPlotLinesOptions|AxisPlotBandsOptions}\n             *         The plotBand or plotLine configuration object.\n             */\n            addPlotBandOrLine: function(options, coll) {\n                var obj = new H.PlotLineOrBand(this, options).render(),\n                    userOptions = this.userOptions;\n\n                if (obj) { // #2189\n                    // Add it to the user options for exporting and Axis.update\n                    if (coll) {\n                        userOptions[coll] = userOptions[coll] || [];\n                        userOptions[coll].push(options);\n                    }\n                    this.plotLinesAndBands.push(obj);\n                }\n\n                return obj;\n            },\n\n            /**\n             * Remove a plot band or plot line from the chart by id. Called internally\n             * from `removePlotBand` and `removePlotLine`.\n             *\n             * @private\n             * @param {String} id\n             */\n            removePlotBandOrLine: function(id) {\n                var plotLinesAndBands = this.plotLinesAndBands,\n                    options = this.options,\n                    userOptions = this.userOptions,\n                    i = plotLinesAndBands.length;\n                while (i--) {\n                    if (plotLinesAndBands[i].id === id) {\n                        plotLinesAndBands[i].destroy();\n                    }\n                }\n                each([\n                    options.plotLines || [],\n                    userOptions.plotLines || [],\n                    options.plotBands || [],\n                    userOptions.plotBands || []\n                ], function(arr) {\n                    i = arr.length;\n                    while (i--) {\n                        if (arr[i].id === id) {\n                            erase(arr, arr[i]);\n                        }\n                    }\n                });\n            },\n\n            /**\n             * Remove a plot band by its id.\n             * \n             * @param  {String} id\n             *         The plot band's `id` as given in the original configuration\n             *         object or in the `addPlotBand` option.\n             * @sample highcharts/members/axis-removeplotband/\n             *         Remove plot band by id\n             * @sample highcharts/members/axis-addplotband/\n             *         Toggle the plot band from a button\n             */\n            removePlotBand: function(id) {\n                this.removePlotBandOrLine(id);\n            },\n\n            /**\n             * Remove a plot line by its id.\n             * @param  {String} id\n             *         The plot line's `id` as given in the original configuration\n             *         object or in the `addPlotLine` option.\n             * @sample highcharts/xaxis/plotlines-id/\n             *         Remove plot line by id\n             * @sample highcharts/members/axis-addplotline/\n             *         Toggle the plot line from a button\n             */\n            removePlotLine: function(id) {\n                this.removePlotBandOrLine(id);\n            }\n        });\n\n    }(Highcharts, Axis));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var dateFormat = H.dateFormat,\n            each = H.each,\n            extend = H.extend,\n            format = H.format,\n            isNumber = H.isNumber,\n            map = H.map,\n            merge = H.merge,\n            pick = H.pick,\n            splat = H.splat,\n            syncTimeout = H.syncTimeout,\n            timeUnits = H.timeUnits;\n        /**\n         * The tooltip object\n         * @param {Object} chart The chart instance\n         * @param {Object} options Tooltip options\n         */\n        H.Tooltip = function() {\n            this.init.apply(this, arguments);\n        };\n\n        H.Tooltip.prototype = {\n\n            init: function(chart, options) {\n\n                // Save the chart and options\n                this.chart = chart;\n                this.options = options;\n\n                // Keep track of the current series\n                //this.currentSeries = undefined;\n\n                // List of crosshairs\n                this.crosshairs = [];\n\n                // Current values of x and y when animating\n                this.now = {\n                    x: 0,\n                    y: 0\n                };\n\n                // The tooltip is initially hidden\n                this.isHidden = true;\n\n\n\n                // Public property for getting the shared state.\n                this.split = options.split && !chart.inverted;\n                this.shared = options.shared || this.split;\n\n            },\n\n            /**\n             * Destroy the single tooltips in a split tooltip.\n             * If the tooltip is active then it is not destroyed, unless forced to.\n             * @param  {boolean} force Force destroy all tooltips.\n             * @return {undefined}\n             */\n            cleanSplit: function(force) {\n                each(this.chart.series, function(series) {\n                    var tt = series && series.tt;\n                    if (tt) {\n                        if (!tt.isActive || force) {\n                            series.tt = tt.destroy();\n                        } else {\n                            tt.isActive = false;\n                        }\n                    }\n                });\n            },\n\n\n\n\n            /**\n             * Create the Tooltip label element if it doesn't exist, then return the\n             * label.\n             */\n            getLabel: function() {\n\n                var renderer = this.chart.renderer,\n                    options = this.options;\n\n                if (!this.label) {\n                    // Create the label\n                    if (this.split) {\n                        this.label = renderer.g('tooltip');\n                    } else {\n                        this.label = renderer.label(\n                                '',\n                                0,\n                                0,\n                                options.shape || 'callout',\n                                null,\n                                null,\n                                options.useHTML,\n                                null,\n                                'tooltip'\n                            )\n                            .attr({\n                                padding: options.padding,\n                                r: options.borderRadius\n                            });\n\n\n                        this.label\n                            .attr({\n                                'fill': options.backgroundColor,\n                                'stroke-width': options.borderWidth\n                            })\n                            // #2301, #2657\n                            .css(options.style)\n                            .shadow(options.shadow);\n\n                    }\n\n\n\n                    this.label\n                        .attr({\n                            zIndex: 8\n                        })\n                        .add();\n                }\n                return this.label;\n            },\n\n            update: function(options) {\n                this.destroy();\n                // Update user options (#6218)\n                merge(true, this.chart.options.tooltip.userOptions, options);\n                this.init(this.chart, merge(true, this.options, options));\n            },\n\n            /**\n             * Destroy the tooltip and its elements.\n             */\n            destroy: function() {\n                // Destroy and clear local variables\n                if (this.label) {\n                    this.label = this.label.destroy();\n                }\n                if (this.split && this.tt) {\n                    this.cleanSplit(this.chart, true);\n                    this.tt = this.tt.destroy();\n                }\n                clearTimeout(this.hideTimer);\n                clearTimeout(this.tooltipTimeout);\n            },\n\n            /**\n             * Provide a soft movement for the tooltip\n             *\n             * @param {Number} x\n             * @param {Number} y\n             * @private\n             */\n            move: function(x, y, anchorX, anchorY) {\n                var tooltip = this,\n                    now = tooltip.now,\n                    animate = tooltip.options.animation !== false && !tooltip.isHidden &&\n                    // When we get close to the target position, abort animation and land on the right place (#3056)\n                    (Math.abs(x - now.x) > 1 || Math.abs(y - now.y) > 1),\n                    skipAnchor = tooltip.followPointer || tooltip.len > 1;\n\n                // Get intermediate values for animation\n                extend(now, {\n                    x: animate ? (2 * now.x + x) / 3 : x,\n                    y: animate ? (now.y + y) / 2 : y,\n                    anchorX: skipAnchor ? undefined : animate ? (2 * now.anchorX + anchorX) / 3 : anchorX,\n                    anchorY: skipAnchor ? undefined : animate ? (now.anchorY + anchorY) / 2 : anchorY\n                });\n\n                // Move to the intermediate value\n                tooltip.getLabel().attr(now);\n\n\n                // Run on next tick of the mouse tracker\n                if (animate) {\n\n                    // Never allow two timeouts\n                    clearTimeout(this.tooltipTimeout);\n\n                    // Set the fixed interval ticking for the smooth tooltip\n                    this.tooltipTimeout = setTimeout(function() {\n                        // The interval function may still be running during destroy,\n                        // so check that the chart is really there before calling.\n                        if (tooltip) {\n                            tooltip.move(x, y, anchorX, anchorY);\n                        }\n                    }, 32);\n\n                }\n            },\n\n            /**\n             * Hide the tooltip\n             */\n            hide: function(delay) {\n                var tooltip = this;\n                clearTimeout(this.hideTimer); // disallow duplicate timers (#1728, #1766)\n                delay = pick(delay, this.options.hideDelay, 500);\n                if (!this.isHidden) {\n                    this.hideTimer = syncTimeout(function() {\n                        tooltip.getLabel()[delay ? 'fadeOut' : 'hide']();\n                        tooltip.isHidden = true;\n                    }, delay);\n                }\n            },\n\n            /**\n             * Extendable method to get the anchor position of the tooltip\n             * from a point or set of points\n             */\n            getAnchor: function(points, mouseEvent) {\n                var ret,\n                    chart = this.chart,\n                    inverted = chart.inverted,\n                    plotTop = chart.plotTop,\n                    plotLeft = chart.plotLeft,\n                    plotX = 0,\n                    plotY = 0,\n                    yAxis,\n                    xAxis;\n\n                points = splat(points);\n\n                // Pie uses a special tooltipPos\n                ret = points[0].tooltipPos;\n\n                // When tooltip follows mouse, relate the position to the mouse\n                if (this.followPointer && mouseEvent) {\n                    if (mouseEvent.chartX === undefined) {\n                        mouseEvent = chart.pointer.normalize(mouseEvent);\n                    }\n                    ret = [\n                        mouseEvent.chartX - chart.plotLeft,\n                        mouseEvent.chartY - plotTop\n                    ];\n                }\n                // When shared, use the average position\n                if (!ret) {\n                    each(points, function(point) {\n                        yAxis = point.series.yAxis;\n                        xAxis = point.series.xAxis;\n                        plotX += point.plotX + (!inverted && xAxis ? xAxis.left - plotLeft : 0);\n                        plotY += (point.plotLow ? (point.plotLow + point.plotHigh) / 2 : point.plotY) +\n                            (!inverted && yAxis ? yAxis.top - plotTop : 0); // #1151\n                    });\n\n                    plotX /= points.length;\n                    plotY /= points.length;\n\n                    ret = [\n                        inverted ? chart.plotWidth - plotY : plotX,\n                        this.shared && !inverted && points.length > 1 && mouseEvent ?\n                        mouseEvent.chartY - plotTop : // place shared tooltip next to the mouse (#424)\n                        inverted ? chart.plotHeight - plotX : plotY\n                    ];\n                }\n\n                return map(ret, Math.round);\n            },\n\n            /**\n             * Place the tooltip in a chart without spilling over\n             * and not covering the point it self.\n             */\n            getPosition: function(boxWidth, boxHeight, point) {\n\n                var chart = this.chart,\n                    distance = this.distance,\n                    ret = {},\n                    h = point.h || 0, // #4117\n                    swapped,\n                    first = ['y', chart.chartHeight, boxHeight,\n                        point.plotY + chart.plotTop, chart.plotTop,\n                        chart.plotTop + chart.plotHeight\n                    ],\n                    second = ['x', chart.chartWidth, boxWidth,\n                        point.plotX + chart.plotLeft, chart.plotLeft,\n                        chart.plotLeft + chart.plotWidth\n                    ],\n                    // The far side is right or bottom\n                    preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === !!point.negative), // #4984\n                    /**\n                     * Handle the preferred dimension. When the preferred dimension is tooltip\n                     * on top or bottom of the point, it will look for space there.\n                     */\n                    firstDimension = function(dim, outerSize, innerSize, point, min, max) {\n                        var roomLeft = innerSize < point - distance,\n                            roomRight = point + distance + innerSize < outerSize,\n                            alignedLeft = point - distance - innerSize,\n                            alignedRight = point + distance;\n\n                        if (preferFarSide && roomRight) {\n                            ret[dim] = alignedRight;\n                        } else if (!preferFarSide && roomLeft) {\n                            ret[dim] = alignedLeft;\n                        } else if (roomLeft) {\n                            ret[dim] = Math.min(max - innerSize, alignedLeft - h < 0 ? alignedLeft : alignedLeft - h);\n                        } else if (roomRight) {\n                            ret[dim] = Math.max(\n                                min,\n                                alignedRight + h + innerSize > outerSize ?\n                                alignedRight :\n                                alignedRight + h\n                            );\n                        } else {\n                            return false;\n                        }\n                    },\n                    /**\n                     * Handle the secondary dimension. If the preferred dimension is tooltip\n                     * on top or bottom of the point, the second dimension is to align the tooltip\n                     * above the point, trying to align center but allowing left or right\n                     * align within the chart box.\n                     */\n                    secondDimension = function(dim, outerSize, innerSize, point) {\n                        var retVal;\n\n                        // Too close to the edge, return false and swap dimensions\n                        if (point < distance || point > outerSize - distance) {\n                            retVal = false;\n                            // Align left/top\n                        } else if (point < innerSize / 2) {\n                            ret[dim] = 1;\n                            // Align right/bottom\n                        } else if (point > outerSize - innerSize / 2) {\n                            ret[dim] = outerSize - innerSize - 2;\n                            // Align center\n                        } else {\n                            ret[dim] = point - innerSize / 2;\n                        }\n                        return retVal;\n                    },\n                    /**\n                     * Swap the dimensions\n                     */\n                    swap = function(count) {\n                        var temp = first;\n                        first = second;\n                        second = temp;\n                        swapped = count;\n                    },\n                    run = function() {\n                        if (firstDimension.apply(0, first) !== false) {\n                            if (secondDimension.apply(0, second) === false && !swapped) {\n                                swap(true);\n                                run();\n                            }\n                        } else if (!swapped) {\n                            swap(true);\n                            run();\n                        } else {\n                            ret.x = ret.y = 0;\n                        }\n                    };\n\n                // Under these conditions, prefer the tooltip on the side of the point\n                if (chart.inverted || this.len > 1) {\n                    swap();\n                }\n                run();\n\n                return ret;\n\n            },\n\n            /**\n             * In case no user defined formatter is given, this will be used. Note that the context\n             * here is an object holding point, series, x, y etc.\n             *\n             * @returns {String|Array<String>}\n             */\n            defaultFormatter: function(tooltip) {\n                var items = this.points || splat(this),\n                    s;\n\n                // Build the header\n                s = [tooltip.tooltipFooterHeaderFormatter(items[0])];\n\n                // build the values\n                s = s.concat(tooltip.bodyFormatter(items));\n\n                // footer\n                s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));\n\n                return s;\n            },\n\n            /**\n             * Refresh the tooltip's text and position.\n             * @param {Object|Array} pointOrPoints Rither a point or an array of points\n             */\n            refresh: function(pointOrPoints, mouseEvent) {\n                var tooltip = this,\n                    label,\n                    options = tooltip.options,\n                    x,\n                    y,\n                    point = pointOrPoints,\n                    anchor,\n                    textConfig = {},\n                    text,\n                    pointConfig = [],\n                    formatter = options.formatter || tooltip.defaultFormatter,\n                    shared = tooltip.shared,\n                    currentSeries;\n\n                clearTimeout(this.hideTimer);\n\n                // get the reference point coordinates (pie charts use tooltipPos)\n                tooltip.followPointer = splat(point)[0].series.tooltipOptions.followPointer;\n                anchor = tooltip.getAnchor(point, mouseEvent);\n                x = anchor[0];\n                y = anchor[1];\n\n                // shared tooltip, array is sent over\n                if (shared && !(point.series && point.series.noSharedTooltip)) {\n                    each(point, function(item) {\n                        item.setState('hover');\n\n                        pointConfig.push(item.getLabelConfig());\n                    });\n\n                    textConfig = {\n                        x: point[0].category,\n                        y: point[0].y\n                    };\n                    textConfig.points = pointConfig;\n                    point = point[0];\n\n                    // single point tooltip\n                } else {\n                    textConfig = point.getLabelConfig();\n                }\n                this.len = pointConfig.length; // #6128\n                text = formatter.call(textConfig, tooltip);\n\n                // register the current series\n                currentSeries = point.series;\n                this.distance = pick(currentSeries.tooltipOptions.distance, 16);\n\n                // update the inner HTML\n                if (text === false) {\n                    this.hide();\n                } else {\n\n                    label = tooltip.getLabel();\n\n                    // show it\n                    if (tooltip.isHidden) {\n                        label.attr({\n                            opacity: 1\n                        }).show();\n                    }\n\n                    // update text\n                    if (tooltip.split) {\n                        this.renderSplit(text, pointOrPoints);\n                    } else {\n\n                        // Prevent the tooltip from flowing over the chart box (#6659)\n\n                        if (!options.style.width) {\n\n                            label.css({\n                                width: this.chart.spacingBox.width\n                            });\n\n                        }\n\n\n                        label.attr({\n                            text: text && text.join ? text.join('') : text\n                        });\n\n                        // Set the stroke color of the box to reflect the point\n                        label.removeClass(/highcharts-color-[\\d]+/g)\n                            .addClass('highcharts-color-' + pick(point.colorIndex, currentSeries.colorIndex));\n\n\n                        label.attr({\n                            stroke: options.borderColor || point.color || currentSeries.color || '#666666'\n                        });\n\n\n                        tooltip.updatePosition({\n                            plotX: x,\n                            plotY: y,\n                            negative: point.negative,\n                            ttBelow: point.ttBelow,\n                            h: anchor[2] || 0\n                        });\n                    }\n\n                    this.isHidden = false;\n                }\n            },\n\n            /**\n             * Render the split tooltip. Loops over each point's text and adds\n             * a label next to the point, then uses the distribute function to \n             * find best non-overlapping positions.\n             */\n            renderSplit: function(labels, points) {\n                var tooltip = this,\n                    boxes = [],\n                    chart = this.chart,\n                    ren = chart.renderer,\n                    rightAligned = true,\n                    options = this.options,\n                    headerHeight,\n                    tooltipLabel = this.getLabel();\n\n                // Create the individual labels for header and points, ignore footer\n                each(labels.slice(0, points.length + 1), function(str, i) {\n                    var point = points[i - 1] ||\n                        // Item 0 is the header. Instead of this, we could also use the crosshair label\n                        {\n                            isHeader: true,\n                            plotX: points[0].plotX\n                        },\n                        owner = point.series || tooltip,\n                        tt = owner.tt,\n                        series = point.series || {},\n                        colorClass = 'highcharts-color-' + pick(point.colorIndex, series.colorIndex, 'none'),\n                        target,\n                        x,\n                        bBox,\n                        boxWidth;\n\n                    // Store the tooltip referance on the series\n                    if (!tt) {\n                        owner.tt = tt = ren.label(null, null, null, 'callout')\n                            .addClass('highcharts-tooltip-box ' + colorClass)\n                            .attr({\n                                'padding': options.padding,\n                                'r': options.borderRadius,\n\n                                'fill': options.backgroundColor,\n                                'stroke': point.color || series.color || '#333333',\n                                'stroke-width': options.borderWidth\n\n                            })\n                            .add(tooltipLabel);\n                    }\n\n                    tt.isActive = true;\n                    tt.attr({\n                        text: str\n                    });\n\n                    tt.css(options.style);\n\n\n                    // Get X position now, so we can move all to the other side in case of overflow\n                    bBox = tt.getBBox();\n                    boxWidth = bBox.width + tt.strokeWidth();\n                    if (point.isHeader) {\n                        headerHeight = bBox.height;\n                        x = Math.max(\n                            0, // No left overflow\n                            Math.min(\n                                point.plotX + chart.plotLeft - boxWidth / 2,\n                                chart.chartWidth - boxWidth // No right overflow (#5794)\n                            )\n                        );\n                    } else {\n                        x = point.plotX + chart.plotLeft - pick(options.distance, 16) -\n                            boxWidth;\n                    }\n\n\n                    // If overflow left, we don't use this x in the next loop\n                    if (x < 0) {\n                        rightAligned = false;\n                    }\n\n                    // Prepare for distribution\n                    target = (point.series && point.series.yAxis && point.series.yAxis.pos) + (point.plotY || 0);\n                    target -= chart.plotTop;\n                    boxes.push({\n                        target: point.isHeader ? chart.plotHeight + headerHeight : target,\n                        rank: point.isHeader ? 1 : 0,\n                        size: owner.tt.getBBox().height + 1,\n                        point: point,\n                        x: x,\n                        tt: tt\n                    });\n                });\n\n                // Clean previous run (for missing points)\n                this.cleanSplit();\n\n                // Distribute and put in place\n                H.distribute(boxes, chart.plotHeight + headerHeight);\n                each(boxes, function(box) {\n                    var point = box.point,\n                        series = point.series;\n\n                    // Put the label in place\n                    box.tt.attr({\n                        visibility: box.pos === undefined ? 'hidden' : 'inherit',\n                        x: (rightAligned || point.isHeader ?\n                            box.x :\n                            point.plotX + chart.plotLeft + pick(options.distance, 16)),\n                        y: box.pos + chart.plotTop,\n                        anchorX: point.isHeader ?\n                            point.plotX + chart.plotLeft : point.plotX + series.xAxis.pos,\n                        anchorY: point.isHeader ?\n                            box.pos + chart.plotTop - 15 : point.plotY + series.yAxis.pos\n                    });\n                });\n            },\n\n            /**\n             * Find the new position and perform the move\n             */\n            updatePosition: function(point) {\n                var chart = this.chart,\n                    label = this.getLabel(),\n                    pos = (this.options.positioner || this.getPosition).call(\n                        this,\n                        label.width,\n                        label.height,\n                        point\n                    );\n\n                // do the move\n                this.move(\n                    Math.round(pos.x),\n                    Math.round(pos.y || 0), // can be undefined (#3977) \n                    point.plotX + chart.plotLeft,\n                    point.plotY + chart.plotTop\n                );\n            },\n\n            /**\n             * Get the optimal date format for a point, based on a range.\n             * @param  {number} range - The time range\n             * @param  {number|Date} date - The date of the point in question\n             * @param  {number} startOfWeek - An integer representing the first day of\n             * the week, where 0 is Sunday\n             * @param  {Object} dateTimeLabelFormats - A map of time units to formats\n             * @return {string} - the optimal date format for a point\n             */\n            getDateFormat: function(range, date, startOfWeek, dateTimeLabelFormats) {\n                var dateStr = dateFormat('%m-%d %H:%M:%S.%L', date),\n                    format,\n                    n,\n                    blank = '01-01 00:00:00.000',\n                    strpos = {\n                        millisecond: 15,\n                        second: 12,\n                        minute: 9,\n                        hour: 6,\n                        day: 3\n                    },\n                    lastN = 'millisecond'; // for sub-millisecond data, #4223\n                for (n in timeUnits) {\n\n                    // If the range is exactly one week and we're looking at a Sunday/Monday, go for the week format\n                    if (range === timeUnits.week && +dateFormat('%w', date) === startOfWeek &&\n                        dateStr.substr(6) === blank.substr(6)) {\n                        n = 'week';\n                        break;\n                    }\n\n                    // The first format that is too great for the range\n                    if (timeUnits[n] > range) {\n                        n = lastN;\n                        break;\n                    }\n\n                    // If the point is placed every day at 23:59, we need to show\n                    // the minutes as well. #2637.\n                    if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {\n                        break;\n                    }\n\n                    // Weeks are outside the hierarchy, only apply them on Mondays/Sundays like in the first condition\n                    if (n !== 'week') {\n                        lastN = n;\n                    }\n                }\n\n                if (n) {\n                    format = dateTimeLabelFormats[n];\n                }\n\n                return format;\n            },\n\n            /**\n             * Get the best X date format based on the closest point range on the axis.\n             */\n            getXDateFormat: function(point, options, xAxis) {\n                var xDateFormat,\n                    dateTimeLabelFormats = options.dateTimeLabelFormats,\n                    closestPointRange = xAxis && xAxis.closestPointRange;\n\n                if (closestPointRange) {\n                    xDateFormat = this.getDateFormat(\n                        closestPointRange,\n                        point.x,\n                        xAxis.options.startOfWeek,\n                        dateTimeLabelFormats\n                    );\n                } else {\n                    xDateFormat = dateTimeLabelFormats.day;\n                }\n\n                return xDateFormat || dateTimeLabelFormats.year; // #2546, 2581\n            },\n\n            /**\n             * Format the footer/header of the tooltip\n             * #3397: abstraction to enable formatting of footer and header\n             */\n            tooltipFooterHeaderFormatter: function(labelConfig, isFooter) {\n                var footOrHead = isFooter ? 'footer' : 'header',\n                    series = labelConfig.series,\n                    tooltipOptions = series.tooltipOptions,\n                    xDateFormat = tooltipOptions.xDateFormat,\n                    xAxis = series.xAxis,\n                    isDateTime = xAxis && xAxis.options.type === 'datetime' && isNumber(labelConfig.key),\n                    formatString = tooltipOptions[footOrHead + 'Format'];\n\n                // Guess the best date format based on the closest point distance (#568, #3418)\n                if (isDateTime && !xDateFormat) {\n                    xDateFormat = this.getXDateFormat(labelConfig, tooltipOptions, xAxis);\n                }\n\n                // Insert the footer date format if any\n                if (isDateTime && xDateFormat) {\n                    formatString = formatString.replace('{point.key}', '{point.key:' + xDateFormat + '}');\n                }\n\n                return format(formatString, {\n                    point: labelConfig,\n                    series: series\n                });\n            },\n\n            /**\n             * Build the body (lines) of the tooltip by iterating over the items and returning one entry for each item,\n             * abstracting this functionality allows to easily overwrite and extend it.\n             */\n            bodyFormatter: function(items) {\n                return map(items, function(item) {\n                    var tooltipOptions = item.series.tooltipOptions;\n                    return (tooltipOptions.pointFormatter || item.point.tooltipFormatter)\n                        .call(item.point, tooltipOptions.pointFormat);\n                });\n            }\n\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            attr = H.attr,\n            charts = H.charts,\n            color = H.color,\n            css = H.css,\n            defined = H.defined,\n            doc = H.doc,\n            each = H.each,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            offset = H.offset,\n            pick = H.pick,\n            removeEvent = H.removeEvent,\n            splat = H.splat,\n            Tooltip = H.Tooltip,\n            win = H.win;\n\n        /**\n         * The mouse tracker object. All methods starting with \"on\" are primary DOM\n         * event handlers. Subsequent methods should be named differently from what they\n         * are doing.\n         *\n         * @constructor Pointer\n         * @param {Object} chart The Chart instance\n         * @param {Object} options The root options object\n         */\n        H.Pointer = function(chart, options) {\n            this.init(chart, options);\n        };\n\n        H.Pointer.prototype = {\n            /**\n             * Initialize Pointer\n             */\n            init: function(chart, options) {\n\n                // Store references\n                this.options = options;\n                this.chart = chart;\n\n                // Do we need to handle click on a touch device?\n                this.runChartClick = options.chart.events && !!options.chart.events.click;\n\n                this.pinchDown = [];\n                this.lastValidTouch = {};\n\n                if (Tooltip && options.tooltip.enabled) {\n                    chart.tooltip = new Tooltip(chart, options.tooltip);\n                    this.followTouchMove = pick(options.tooltip.followTouchMove, true);\n                }\n\n                this.setDOMEvents();\n            },\n\n            /**\n             * Resolve the zoomType option, this is reset on all touch start and mouse\n             * down events.\n             */\n            zoomOption: function(e) {\n                var chart = this.chart,\n                    options = chart.options.chart,\n                    zoomType = options.zoomType || '',\n                    inverted = chart.inverted,\n                    zoomX,\n                    zoomY;\n\n                // Look for the pinchType option\n                if (/touch/.test(e.type)) {\n                    zoomType = pick(options.pinchType, zoomType);\n                }\n\n                this.zoomX = zoomX = /x/.test(zoomType);\n                this.zoomY = zoomY = /y/.test(zoomType);\n                this.zoomHor = (zoomX && !inverted) || (zoomY && inverted);\n                this.zoomVert = (zoomY && !inverted) || (zoomX && inverted);\n                this.hasZoom = zoomX || zoomY;\n            },\n\n            /**\n             * @typedef  {Object} PointerEvent\n             *           A native browser mouse or touch event, extended with position\n             *           information relative to the {@link Chart.container}.\n             * @property {Number} chartX\n             *           The X coordinate of the pointer interaction relative to the\n             *           chart.\n             * @property {Number} chartY\n             *           The Y coordinate of the pointer interaction relative to the \n             *           chart.\n             * \n             */\n            /**\n             * Add crossbrowser support for chartX and chartY.\n             * \n             * @param  {Object} e\n             *         The event object in standard browsers.\n             *\n             * @return {PointerEvent}\n             *         A browser event with extended properties `chartX` and `chartY`\n             */\n            normalize: function(e, chartPosition) {\n                var chartX,\n                    chartY,\n                    ePos;\n\n                // IE normalizing\n                e = e || win.event;\n                if (!e.target) {\n                    e.target = e.srcElement;\n                }\n\n                // iOS (#2757)\n                ePos = e.touches ? (e.touches.length ? e.touches.item(0) : e.changedTouches[0]) : e;\n\n                // Get mouse position\n                if (!chartPosition) {\n                    this.chartPosition = chartPosition = offset(this.chart.container);\n                }\n\n                // chartX and chartY\n                if (ePos.pageX === undefined) { // IE < 9. #886.\n                    chartX = Math.max(e.x, e.clientX - chartPosition.left); // #2005, #2129: the second case is \n                    // for IE10 quirks mode within framesets\n                    chartY = e.y;\n                } else {\n                    chartX = ePos.pageX - chartPosition.left;\n                    chartY = ePos.pageY - chartPosition.top;\n                }\n\n                return extend(e, {\n                    chartX: Math.round(chartX),\n                    chartY: Math.round(chartY)\n                });\n            },\n\n            /**\n             * Get the click position in terms of axis values.\n             *\n             * @param {Object} e A pointer event\n             */\n            getCoordinates: function(e) {\n                var coordinates = {\n                    xAxis: [],\n                    yAxis: []\n                };\n\n                each(this.chart.axes, function(axis) {\n                    coordinates[axis.isXAxis ? 'xAxis' : 'yAxis'].push({\n                        axis: axis,\n                        value: axis.toValue(e[axis.horiz ? 'chartX' : 'chartY'])\n                    });\n                });\n                return coordinates;\n            },\n            /**\n             * Collects the points closest to a mouseEvent\n             * @param  {Array} series Array of series to gather points from\n             * @param  {Boolean} shared True if shared tooltip, otherwise false\n             * @param  {Object} e Mouse event which possess a position to compare against\n             * @return {Array} KDPoints sorted by distance\n             */\n            getKDPoints: function(series, shared, e) {\n                var kdpoints = [],\n                    noSharedTooltip,\n                    directTouch,\n                    kdpointT,\n                    i;\n\n                // Find nearest points on all series\n                each(series, function(s) {\n                    // Skip hidden series\n                    noSharedTooltip = s.noSharedTooltip && shared;\n                    directTouch = !shared && s.directTouch;\n                    if (s.visible && !directTouch && pick(s.options.enableMouseTracking, true)) { // #3821\n                        // #3828\n                        kdpointT = s.searchPoint(\n                            e, !noSharedTooltip && s.options.findNearestPointBy.indexOf('y') < 0\n                        );\n                        if (kdpointT && kdpointT.series) { // Point.series becomes null when reset and before redraw (#5197)\n                            kdpoints.push(kdpointT);\n                        }\n                    }\n                });\n\n                // Sort kdpoints by distance to mouse pointer\n                kdpoints.sort(function(p1, p2) {\n                    var isCloserX = p1.distX - p2.distX,\n                        isCloser = p1.dist - p2.dist,\n                        isAbove =\n                        (p2.series.group && p2.series.group.zIndex) -\n                        (p1.series.group && p1.series.group.zIndex),\n                        result;\n\n                    // We have two points which are not in the same place on xAxis and shared tooltip:\n                    if (isCloserX !== 0 && shared) { // #5721\n                        result = isCloserX;\n                        // Points are not exactly in the same place on x/yAxis:\n                    } else if (isCloser !== 0) {\n                        result = isCloser;\n                        // The same xAxis and yAxis position, sort by z-index:\n                    } else if (isAbove !== 0) {\n                        result = isAbove;\n                        // The same zIndex, sort by array index:\n                    } else {\n                        result = p1.series.index > p2.series.index ? -1 : 1;\n                    }\n                    return result;\n                });\n\n                // Remove points with different x-positions, required for shared tooltip and crosshairs (#4645):\n                if (shared && kdpoints[0] && !kdpoints[0].series.noSharedTooltip) {\n                    i = kdpoints.length;\n                    while (i--) {\n                        if (kdpoints[i].x !== kdpoints[0].x || kdpoints[i].series.noSharedTooltip) {\n                            kdpoints.splice(i, 1);\n                        }\n                    }\n                }\n                return kdpoints;\n            },\n            getPointFromEvent: function(e) {\n                var target = e.target,\n                    point;\n\n                while (target && !point) {\n                    point = target.point;\n                    target = target.parentNode;\n                }\n                return point;\n            },\n\n            getChartCoordinatesFromPoint: function(point, inverted) {\n                var series = point.series,\n                    xAxis = series.xAxis,\n                    yAxis = series.yAxis;\n\n                if (xAxis && yAxis) {\n                    return inverted ? {\n                        chartX: xAxis.len + xAxis.pos - point.clientX,\n                        chartY: yAxis.len + yAxis.pos - point.plotY\n                    } : {\n                        chartX: point.clientX + xAxis.pos,\n                        chartY: point.plotY + yAxis.pos\n                    };\n                }\n            },\n\n            /**\n             * Calculates what is the current hovered point/points and series.\n             *\n             * @private\n             *\n             * @param  {undefined|Point} existingHoverPoint\n             *         The point currrently beeing hovered.\n             * @param  {undefined|Series} existingHoverSeries\n             *         The series currently beeing hovered.\n             * @param  {Array<.Series>} series\n             *         All the series in the chart.\n             * @param  {boolean} isDirectTouch\n             *         Is the pointer directly hovering the point.\n             * @param  {boolean} shared\n             *         Whether it is a shared tooltip or not.\n             * @param  {object} coordinates\n             *         Chart coordinates of the pointer.\n             * @param  {number} coordinates.chartX\n             * @param  {number} coordinates.chartY\n             * \n             * @return {object}\n             *         Object containing resulting hover data.\n             */\n            getHoverData: function(\n                existingHoverPoint,\n                existingHoverSeries,\n                series,\n                isDirectTouch,\n                shared,\n                coordinates\n            ) {\n                var hoverPoint = existingHoverPoint,\n                    hoverSeries = existingHoverSeries,\n                    searchSeries = shared ? series : [hoverSeries],\n                    useExisting = !!(isDirectTouch && existingHoverPoint),\n                    notSticky = hoverSeries && !hoverSeries.stickyTracking,\n                    isHoverPoint = function(point, i) {\n                        return i === 0;\n                    },\n                    hoverPoints;\n\n                // If there is a hoverPoint and its series requires direct touch (like\n                // columns, #3899), or we're on a noSharedTooltip series among shared\n                // tooltip series (#4546), use the existing hoverPoint.\n                if (useExisting) {\n                    isHoverPoint = function(p) {\n                        return p === existingHoverPoint;\n                    };\n                } else if (notSticky) {\n                    isHoverPoint = function(p) {\n                        return p.series === hoverSeries;\n                    };\n                } else {\n                    // Avoid series with stickyTracking false\n                    searchSeries = H.grep(series, function(s) {\n                        return s.stickyTracking;\n                    });\n                }\n                hoverPoints = (useExisting && !shared) ?\n                    // Non-shared tooltips with directTouch don't use the k-d-tree\n                    [existingHoverPoint] :\n                    this.getKDPoints(searchSeries, shared, coordinates);\n                hoverPoint = H.find(hoverPoints, isHoverPoint);\n                hoverSeries = hoverPoint && hoverPoint.series;\n\n                // In this case we could only look for the hoverPoint in series with\n                // stickyTracking, but we should still include all series in the shared\n                // tooltip.\n                if (!useExisting && !notSticky && shared) {\n                    hoverPoints = this.getKDPoints(series, shared, coordinates);\n                }\n                // Keep the order of series in tooltip\n                // Must be done after assigning of hoverPoint\n                hoverPoints.sort(function(p1, p2) {\n                    return p1.series.index - p2.series.index;\n                });\n\n                return {\n                    hoverPoint: hoverPoint,\n                    hoverSeries: hoverSeries,\n                    hoverPoints: hoverPoints\n                };\n            },\n            /**\n             * With line type charts with a single tracker, get the point closest to the mouse.\n             * Run Point.onMouseOver and display tooltip for the point or points.\n             */\n            runPointActions: function(e, p) {\n                var pointer = this,\n                    chart = pointer.chart,\n                    series = chart.series,\n                    tooltip = chart.tooltip,\n                    shared = tooltip ? tooltip.shared : false,\n                    hoverPoint = p || chart.hoverPoint,\n                    hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries,\n                    // onMouseOver or already hovering a series with directTouch\n                    isDirectTouch = !!p || (\n                        (hoverSeries && hoverSeries.directTouch) &&\n                        pointer.isDirectTouch\n                    ),\n                    hoverData = this.getHoverData(\n                        hoverPoint,\n                        hoverSeries,\n                        series,\n                        isDirectTouch,\n                        shared,\n                        e\n                    ),\n                    useSharedTooltip,\n                    followPointer,\n                    anchor,\n                    points;\n                // Update variables from hoverData.\n                hoverPoint = hoverData.hoverPoint;\n                hoverSeries = hoverData.hoverSeries;\n                followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer;\n                useSharedTooltip = (\n                    shared &&\n                    hoverPoint &&\n                    !hoverPoint.series.noSharedTooltip\n                );\n                points = (useSharedTooltip ?\n                    hoverData.hoverPoints :\n                    (hoverPoint ? [hoverPoint] : [])\n                );\n                // Refresh tooltip for kdpoint if new hover point or tooltip was hidden\n                // #3926, #4200\n                if (\n                    hoverPoint &&\n                    // !(hoverSeries && hoverSeries.directTouch) &&\n                    (hoverPoint !== chart.hoverPoint || (tooltip && tooltip.isHidden))\n                ) {\n                    each(chart.hoverPoints || [], function(p) {\n                        if (H.inArray(p, points) === -1) {\n                            p.setState();\n                        }\n                    });\n                    // Do mouseover on all points (#3919, #3985, #4410, #5622)\n                    each(points || [], function(p) {\n                        p.setState('hover');\n                    });\n                    // set normal state to previous series\n                    if (chart.hoverSeries !== hoverSeries) {\n                        hoverSeries.onMouseOver();\n                    }\n\n                    // If tracking is on series in stead of on each point, \n                    // fire mouseOver on hover point. // #4448\n                    if (chart.hoverPoint) {\n                        chart.hoverPoint.firePointEvent('mouseOut');\n                    }\n                    hoverPoint.firePointEvent('mouseOver');\n                    chart.hoverPoints = points;\n                    chart.hoverPoint = hoverPoint;\n                    // Draw tooltip if necessary\n                    if (tooltip) {\n                        tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);\n                    }\n                    // Update positions (regardless of kdpoint or hoverPoint)\n                } else if (followPointer && tooltip && !tooltip.isHidden) {\n                    anchor = tooltip.getAnchor([{}], e);\n                    tooltip.updatePosition({\n                        plotX: anchor[0],\n                        plotY: anchor[1]\n                    });\n                }\n\n                // Start the event listener to pick up the tooltip and crosshairs\n                if (!pointer.unDocMouseMove) {\n                    pointer.unDocMouseMove = addEvent(doc, 'mousemove', function(e) {\n                        var chart = charts[H.hoverChartIndex];\n                        if (chart) {\n                            chart.pointer.onDocumentMouseMove(e);\n                        }\n                    });\n                }\n\n                // Issues related to crosshair #4927, #5269 #5066, #5658\n                each(chart.axes, function drawAxisCrosshair(axis) {\n                    var snap = pick(axis.crosshair.snap, true);\n                    if (!snap) {\n                        axis.drawCrosshair(e);\n\n                        // Axis has snapping crosshairs, and one of the hover points belongs\n                        // to axis\n                    } else if (H.find(points, function(p) {\n                            return p.series[axis.coll] === axis;\n                        })) {\n                        axis.drawCrosshair(e, hoverPoint);\n                        // Axis has snapping crosshairs, but no hover point belongs to axis\n                    } else {\n                        axis.hideCrosshair();\n                    }\n                });\n            },\n\n            /**\n             * Reset the tracking by hiding the tooltip, the hover series state and the\n             * hover point\n             *\n             * @param allowMove {Boolean}\n             *        Instead of destroying the tooltip altogether, allow moving it if\n             *        possible\n             */\n            reset: function(allowMove, delay) {\n                var pointer = this,\n                    chart = pointer.chart,\n                    hoverSeries = chart.hoverSeries,\n                    hoverPoint = chart.hoverPoint,\n                    hoverPoints = chart.hoverPoints,\n                    tooltip = chart.tooltip,\n                    tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;\n\n                // Check if the points have moved outside the plot area (#1003, #4736, #5101)\n                if (allowMove && tooltipPoints) {\n                    each(splat(tooltipPoints), function(point) {\n                        if (point.series.isCartesian && point.plotX === undefined) {\n                            allowMove = false;\n                        }\n                    });\n                }\n\n                // Just move the tooltip, #349\n                if (allowMove) {\n                    if (tooltip && tooltipPoints) {\n                        tooltip.refresh(tooltipPoints);\n                        if (hoverPoint) { // #2500\n                            hoverPoint.setState(hoverPoint.state, true);\n                            each(chart.axes, function(axis) {\n                                if (axis.crosshair) {\n                                    axis.drawCrosshair(null, hoverPoint);\n                                }\n                            });\n                        }\n                    }\n\n                    // Full reset\n                } else {\n\n                    if (hoverPoint) {\n                        hoverPoint.onMouseOut();\n                    }\n\n                    if (hoverPoints) {\n                        each(hoverPoints, function(point) {\n                            point.setState();\n                        });\n                    }\n\n                    if (hoverSeries) {\n                        hoverSeries.onMouseOut();\n                    }\n\n                    if (tooltip) {\n                        tooltip.hide(delay);\n                    }\n\n                    if (pointer.unDocMouseMove) {\n                        pointer.unDocMouseMove = pointer.unDocMouseMove();\n                    }\n\n                    // Remove crosshairs\n                    each(chart.axes, function(axis) {\n                        axis.hideCrosshair();\n                    });\n\n                    pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;\n                }\n            },\n\n            /**\n             * Scale series groups to a certain scale and translation\n             */\n            scaleGroups: function(attribs, clip) {\n\n                var chart = this.chart,\n                    seriesAttribs;\n\n                // Scale each series\n                each(chart.series, function(series) {\n                    seriesAttribs = attribs || series.getPlotBox(); // #1701\n                    if (series.xAxis && series.xAxis.zoomEnabled && series.group) {\n                        series.group.attr(seriesAttribs);\n                        if (series.markerGroup) {\n                            series.markerGroup.attr(seriesAttribs);\n                            series.markerGroup.clip(clip ? chart.clipRect : null);\n                        }\n                        if (series.dataLabelsGroup) {\n                            series.dataLabelsGroup.attr(seriesAttribs);\n                        }\n                    }\n                });\n\n                // Clip\n                chart.clipRect.attr(clip || chart.clipBox);\n            },\n\n            /**\n             * Start a drag operation\n             */\n            dragStart: function(e) {\n                var chart = this.chart;\n\n                // Record the start position\n                chart.mouseIsDown = e.type;\n                chart.cancelClick = false;\n                chart.mouseDownX = this.mouseDownX = e.chartX;\n                chart.mouseDownY = this.mouseDownY = e.chartY;\n            },\n\n            /**\n             * Perform a drag operation in response to a mousemove event while the mouse is down\n             */\n            drag: function(e) {\n\n                var chart = this.chart,\n                    chartOptions = chart.options.chart,\n                    chartX = e.chartX,\n                    chartY = e.chartY,\n                    zoomHor = this.zoomHor,\n                    zoomVert = this.zoomVert,\n                    plotLeft = chart.plotLeft,\n                    plotTop = chart.plotTop,\n                    plotWidth = chart.plotWidth,\n                    plotHeight = chart.plotHeight,\n                    clickedInside,\n                    size,\n                    selectionMarker = this.selectionMarker,\n                    mouseDownX = this.mouseDownX,\n                    mouseDownY = this.mouseDownY,\n                    panKey = chartOptions.panKey && e[chartOptions.panKey + 'Key'];\n\n                // If the device supports both touch and mouse (like IE11), and we are touch-dragging\n                // inside the plot area, don't handle the mouse event. #4339.\n                if (selectionMarker && selectionMarker.touch) {\n                    return;\n                }\n\n                // If the mouse is outside the plot area, adjust to cooordinates\n                // inside to prevent the selection marker from going outside\n                if (chartX < plotLeft) {\n                    chartX = plotLeft;\n                } else if (chartX > plotLeft + plotWidth) {\n                    chartX = plotLeft + plotWidth;\n                }\n\n                if (chartY < plotTop) {\n                    chartY = plotTop;\n                } else if (chartY > plotTop + plotHeight) {\n                    chartY = plotTop + plotHeight;\n                }\n\n                // determine if the mouse has moved more than 10px\n                this.hasDragged = Math.sqrt(\n                    Math.pow(mouseDownX - chartX, 2) +\n                    Math.pow(mouseDownY - chartY, 2)\n                );\n\n                if (this.hasDragged > 10) {\n                    clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop);\n\n                    // make a selection\n                    if (chart.hasCartesianSeries && (this.zoomX || this.zoomY) && clickedInside && !panKey) {\n                        if (!selectionMarker) {\n                            this.selectionMarker = selectionMarker = chart.renderer.rect(\n                                    plotLeft,\n                                    plotTop,\n                                    zoomHor ? 1 : plotWidth,\n                                    zoomVert ? 1 : plotHeight,\n                                    0\n                                )\n                                .attr({\n\n                                    fill: chartOptions.selectionMarkerFill || color('#335cad').setOpacity(0.25).get(),\n\n                                    'class': 'highcharts-selection-marker',\n                                    'zIndex': 7\n                                })\n                                .add();\n                        }\n                    }\n\n                    // adjust the width of the selection marker\n                    if (selectionMarker && zoomHor) {\n                        size = chartX - mouseDownX;\n                        selectionMarker.attr({\n                            width: Math.abs(size),\n                            x: (size > 0 ? 0 : size) + mouseDownX\n                        });\n                    }\n                    // adjust the height of the selection marker\n                    if (selectionMarker && zoomVert) {\n                        size = chartY - mouseDownY;\n                        selectionMarker.attr({\n                            height: Math.abs(size),\n                            y: (size > 0 ? 0 : size) + mouseDownY\n                        });\n                    }\n\n                    // panning\n                    if (clickedInside && !selectionMarker && chartOptions.panning) {\n                        chart.pan(e, chartOptions.panning);\n                    }\n                }\n            },\n\n            /**\n             * On mouse up or touch end across the entire document, drop the selection.\n             */\n            drop: function(e) {\n                var pointer = this,\n                    chart = this.chart,\n                    hasPinched = this.hasPinched;\n\n                if (this.selectionMarker) {\n                    var selectionData = {\n                            originalEvent: e, // #4890\n                            xAxis: [],\n                            yAxis: []\n                        },\n                        selectionBox = this.selectionMarker,\n                        selectionLeft = selectionBox.attr ? selectionBox.attr('x') : selectionBox.x,\n                        selectionTop = selectionBox.attr ? selectionBox.attr('y') : selectionBox.y,\n                        selectionWidth = selectionBox.attr ? selectionBox.attr('width') : selectionBox.width,\n                        selectionHeight = selectionBox.attr ? selectionBox.attr('height') : selectionBox.height,\n                        runZoom;\n\n                    // a selection has been made\n                    if (this.hasDragged || hasPinched) {\n\n                        // record each axis' min and max\n                        each(chart.axes, function(axis) {\n                            if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{\n                                    xAxis: 'zoomX',\n                                    yAxis: 'zoomY'\n                                }[axis.coll]])) { // #859, #3569\n                                var horiz = axis.horiz,\n                                    minPixelPadding = e.type === 'touchend' ? axis.minPixelPadding : 0, // #1207, #3075\n                                    selectionMin = axis.toValue((horiz ? selectionLeft : selectionTop) + minPixelPadding),\n                                    selectionMax = axis.toValue((horiz ? selectionLeft + selectionWidth : selectionTop + selectionHeight) - minPixelPadding);\n\n                                selectionData[axis.coll].push({\n                                    axis: axis,\n                                    min: Math.min(selectionMin, selectionMax), // for reversed axes\n                                    max: Math.max(selectionMin, selectionMax)\n                                });\n                                runZoom = true;\n                            }\n                        });\n                        if (runZoom) {\n                            fireEvent(chart, 'selection', selectionData, function(args) {\n                                chart.zoom(extend(args, hasPinched ? {\n                                    animation: false\n                                } : null));\n                            });\n                        }\n\n                    }\n                    this.selectionMarker = this.selectionMarker.destroy();\n\n                    // Reset scaling preview\n                    if (hasPinched) {\n                        this.scaleGroups();\n                    }\n                }\n\n                // Reset all\n                if (chart) { // it may be destroyed on mouse up - #877\n                    css(chart.container, {\n                        cursor: chart._cursor\n                    });\n                    chart.cancelClick = this.hasDragged > 10; // #370\n                    chart.mouseIsDown = this.hasDragged = this.hasPinched = false;\n                    this.pinchDown = [];\n                }\n            },\n\n            onContainerMouseDown: function(e) {\n\n                e = this.normalize(e);\n\n                this.zoomOption(e);\n\n                // issue #295, dragging not always working in Firefox\n                if (e.preventDefault) {\n                    e.preventDefault();\n                }\n\n                this.dragStart(e);\n            },\n\n\n\n            onDocumentMouseUp: function(e) {\n                if (charts[H.hoverChartIndex]) {\n                    charts[H.hoverChartIndex].pointer.drop(e);\n                }\n            },\n\n            /**\n             * Special handler for mouse move that will hide the tooltip when the mouse leaves the plotarea.\n             * Issue #149 workaround. The mouseleave event does not always fire.\n             */\n            onDocumentMouseMove: function(e) {\n                var chart = this.chart,\n                    chartPosition = this.chartPosition;\n\n                e = this.normalize(e, chartPosition);\n\n                // If we're outside, hide the tooltip\n                if (chartPosition && !this.inClass(e.target, 'highcharts-tracker') &&\n                    !chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) {\n                    this.reset();\n                }\n            },\n\n            /**\n             * When mouse leaves the container, hide the tooltip.\n             */\n            onContainerMouseLeave: function(e) {\n                var chart = charts[H.hoverChartIndex];\n                if (chart && (e.relatedTarget || e.toElement)) { // #4886, MS Touch end fires mouseleave but with no related target\n                    chart.pointer.reset();\n                    chart.pointer.chartPosition = null; // also reset the chart position, used in #149 fix\n                }\n            },\n\n            // The mousemove, touchmove and touchstart event handler\n            onContainerMouseMove: function(e) {\n\n                var chart = this.chart;\n\n                if (!defined(H.hoverChartIndex) || !charts[H.hoverChartIndex] || !charts[H.hoverChartIndex].mouseIsDown) {\n                    H.hoverChartIndex = chart.index;\n                }\n\n                e = this.normalize(e);\n                e.returnValue = false; // #2251, #3224\n\n                if (chart.mouseIsDown === 'mousedown') {\n                    this.drag(e);\n                }\n\n                // Show the tooltip and run mouse over events (#977)\n                if ((this.inClass(e.target, 'highcharts-tracker') ||\n                        chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop)) && !chart.openMenu) {\n                    this.runPointActions(e);\n                }\n            },\n\n            /**\n             * Utility to detect whether an element has, or has a parent with, a specific\n             * class name. Used on detection of tracker objects and on deciding whether\n             * hovering the tooltip should cause the active series to mouse out.\n             */\n            inClass: function(element, className) {\n                var elemClassName;\n                while (element) {\n                    elemClassName = attr(element, 'class');\n                    if (elemClassName) {\n                        if (elemClassName.indexOf(className) !== -1) {\n                            return true;\n                        }\n                        if (elemClassName.indexOf('highcharts-container') !== -1) {\n                            return false;\n                        }\n                    }\n                    element = element.parentNode;\n                }\n            },\n\n            onTrackerMouseOut: function(e) {\n                var series = this.chart.hoverSeries,\n                    relatedTarget = e.relatedTarget || e.toElement;\n                this.isDirectTouch = false;\n                if (series && relatedTarget && !series.stickyTracking &&\n                    !this.inClass(relatedTarget, 'highcharts-tooltip') &&\n                    (!this.inClass(relatedTarget, 'highcharts-series-' + series.index) || // #2499, #4465\n                        !this.inClass(relatedTarget, 'highcharts-tracker') // #5553\n                    )\n                ) {\n                    series.onMouseOut();\n                }\n            },\n\n            onContainerClick: function(e) {\n                var chart = this.chart,\n                    hoverPoint = chart.hoverPoint,\n                    plotLeft = chart.plotLeft,\n                    plotTop = chart.plotTop;\n\n                e = this.normalize(e);\n\n                if (!chart.cancelClick) {\n\n                    // On tracker click, fire the series and point events. #783, #1583\n                    if (hoverPoint && this.inClass(e.target, 'highcharts-tracker')) {\n\n                        // the series click event\n                        fireEvent(hoverPoint.series, 'click', extend(e, {\n                            point: hoverPoint\n                        }));\n\n                        // the point click event\n                        if (chart.hoverPoint) { // it may be destroyed (#1844)\n                            hoverPoint.firePointEvent('click', e);\n                        }\n\n                        // When clicking outside a tracker, fire a chart event\n                    } else {\n                        extend(e, this.getCoordinates(e));\n\n                        // fire a click event in the chart\n                        if (chart.isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {\n                            fireEvent(chart, 'click', e);\n                        }\n                    }\n\n\n                }\n            },\n\n            /**\n             * Set the JS DOM events on the container and document. This method should contain\n             * a one-to-one assignment between methods and their handlers. Any advanced logic should\n             * be moved to the handler reflecting the event's name.\n             */\n            setDOMEvents: function() {\n\n                var pointer = this,\n                    container = pointer.chart.container;\n\n                container.onmousedown = function(e) {\n                    pointer.onContainerMouseDown(e);\n                };\n                container.onmousemove = function(e) {\n                    pointer.onContainerMouseMove(e);\n                };\n                container.onclick = function(e) {\n                    pointer.onContainerClick(e);\n                };\n                addEvent(container, 'mouseleave', pointer.onContainerMouseLeave);\n                if (H.chartCount === 1) {\n                    addEvent(doc, 'mouseup', pointer.onDocumentMouseUp);\n                }\n                if (H.hasTouch) {\n                    container.ontouchstart = function(e) {\n                        pointer.onContainerTouchStart(e);\n                    };\n                    container.ontouchmove = function(e) {\n                        pointer.onContainerTouchMove(e);\n                    };\n                    if (H.chartCount === 1) {\n                        addEvent(doc, 'touchend', pointer.onDocumentTouchEnd);\n                    }\n                }\n\n            },\n\n            /**\n             * Destroys the Pointer object and disconnects DOM events.\n             */\n            destroy: function() {\n                var pointer = this;\n\n                if (pointer.unDocMouseMove) {\n                    pointer.unDocMouseMove();\n                }\n\n                removeEvent(\n                    pointer.chart.container,\n                    'mouseleave',\n                    pointer.onContainerMouseLeave\n                );\n                if (!H.chartCount) {\n                    removeEvent(doc, 'mouseup', pointer.onDocumentMouseUp);\n                    removeEvent(doc, 'touchend', pointer.onDocumentTouchEnd);\n                }\n\n                // memory and CPU leak\n                clearInterval(pointer.tooltipTimeout);\n\n                H.objectEach(pointer, function(val, prop) {\n                    pointer[prop] = null;\n                });\n            }\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var charts = H.charts,\n            each = H.each,\n            extend = H.extend,\n            map = H.map,\n            noop = H.noop,\n            pick = H.pick,\n            Pointer = H.Pointer;\n\n        /* Support for touch devices */\n        extend(Pointer.prototype, /** @lends Pointer.prototype */ {\n\n            /**\n             * Run translation operations\n             */\n            pinchTranslate: function(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {\n                if (this.zoomHor) {\n                    this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n                }\n                if (this.zoomVert) {\n                    this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n                }\n            },\n\n            /**\n             * Run translation operations for each direction (horizontal and vertical) independently\n             */\n            pinchTranslateDirection: function(horiz, pinchDown, touches, transform,\n                selectionMarker, clip, lastValidTouch, forcedScale) {\n                var chart = this.chart,\n                    xy = horiz ? 'x' : 'y',\n                    XY = horiz ? 'X' : 'Y',\n                    sChartXY = 'chart' + XY,\n                    wh = horiz ? 'width' : 'height',\n                    plotLeftTop = chart['plot' + (horiz ? 'Left' : 'Top')],\n                    selectionWH,\n                    selectionXY,\n                    clipXY,\n                    scale = forcedScale || 1,\n                    inverted = chart.inverted,\n                    bounds = chart.bounds[horiz ? 'h' : 'v'],\n                    singleTouch = pinchDown.length === 1,\n                    touch0Start = pinchDown[0][sChartXY],\n                    touch0Now = touches[0][sChartXY],\n                    touch1Start = !singleTouch && pinchDown[1][sChartXY],\n                    touch1Now = !singleTouch && touches[1][sChartXY],\n                    outOfBounds,\n                    transformScale,\n                    scaleKey,\n                    setScale = function() {\n                        // Don't zoom if fingers are too close on this axis\n                        if (!singleTouch && Math.abs(touch0Start - touch1Start) > 20) {\n                            scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start);\n                        }\n\n                        clipXY = ((plotLeftTop - touch0Now) / scale) + touch0Start;\n                        selectionWH = chart['plot' + (horiz ? 'Width' : 'Height')] / scale;\n                    };\n\n                // Set the scale, first pass\n                setScale();\n\n                selectionXY = clipXY; // the clip position (x or y) is altered if out of bounds, the selection position is not\n\n                // Out of bounds\n                if (selectionXY < bounds.min) {\n                    selectionXY = bounds.min;\n                    outOfBounds = true;\n                } else if (selectionXY + selectionWH > bounds.max) {\n                    selectionXY = bounds.max - selectionWH;\n                    outOfBounds = true;\n                }\n\n                // Is the chart dragged off its bounds, determined by dataMin and dataMax?\n                if (outOfBounds) {\n\n                    // Modify the touchNow position in order to create an elastic drag movement. This indicates\n                    // to the user that the chart is responsive but can't be dragged further.\n                    touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);\n                    if (!singleTouch) {\n                        touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);\n                    }\n\n                    // Set the scale, second pass to adapt to the modified touchNow positions\n                    setScale();\n\n                } else {\n                    lastValidTouch[xy] = [touch0Now, touch1Now];\n                }\n\n                // Set geometry for clipping, selection and transformation\n                if (!inverted) {\n                    clip[xy] = clipXY - plotLeftTop;\n                    clip[wh] = selectionWH;\n                }\n                scaleKey = inverted ? (horiz ? 'scaleY' : 'scaleX') : 'scale' + XY;\n                transformScale = inverted ? 1 / scale : scale;\n\n                selectionMarker[wh] = selectionWH;\n                selectionMarker[xy] = selectionXY;\n                transform[scaleKey] = scale;\n                transform['translate' + XY] = (transformScale * plotLeftTop) + (touch0Now - (transformScale * touch0Start));\n            },\n\n            /**\n             * Handle touch events with two touches\n             */\n            pinch: function(e) {\n\n                var self = this,\n                    chart = self.chart,\n                    pinchDown = self.pinchDown,\n                    touches = e.touches,\n                    touchesLength = touches.length,\n                    lastValidTouch = self.lastValidTouch,\n                    hasZoom = self.hasZoom,\n                    selectionMarker = self.selectionMarker,\n                    transform = {},\n                    fireClickEvent = touchesLength === 1 && ((self.inClass(e.target, 'highcharts-tracker') &&\n                        chart.runTrackerClick) || self.runChartClick),\n                    clip = {};\n\n                // Don't initiate panning until the user has pinched. This prevents us from\n                // blocking page scrolling as users scroll down a long page (#4210).\n                if (touchesLength > 1) {\n                    self.initiated = true;\n                }\n\n                // On touch devices, only proceed to trigger click if a handler is defined\n                if (hasZoom && self.initiated && !fireClickEvent) {\n                    e.preventDefault();\n                }\n\n                // Normalize each touch\n                map(touches, function(e) {\n                    return self.normalize(e);\n                });\n\n                // Register the touch start position\n                if (e.type === 'touchstart') {\n                    each(touches, function(e, i) {\n                        pinchDown[i] = {\n                            chartX: e.chartX,\n                            chartY: e.chartY\n                        };\n                    });\n                    lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];\n                    lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];\n\n                    // Identify the data bounds in pixels\n                    each(chart.axes, function(axis) {\n                        if (axis.zoomEnabled) {\n                            var bounds = chart.bounds[axis.horiz ? 'h' : 'v'],\n                                minPixelPadding = axis.minPixelPadding,\n                                min = axis.toPixels(pick(axis.options.min, axis.dataMin)),\n                                max = axis.toPixels(pick(axis.options.max, axis.dataMax)),\n                                absMin = Math.min(min, max),\n                                absMax = Math.max(min, max);\n\n                            // Store the bounds for use in the touchmove handler\n                            bounds.min = Math.min(axis.pos, absMin - minPixelPadding);\n                            bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);\n                        }\n                    });\n                    self.res = true; // reset on next move\n\n                    // Optionally move the tooltip on touchmove\n                } else if (self.followTouchMove && touchesLength === 1) {\n                    this.runPointActions(self.normalize(e));\n\n                    // Event type is touchmove, handle panning and pinching\n                } else if (pinchDown.length) { // can be 0 when releasing, if touchend fires first\n\n\n                    // Set the marker\n                    if (!selectionMarker) {\n                        self.selectionMarker = selectionMarker = extend({\n                            destroy: noop,\n                            touch: true\n                        }, chart.plotBox);\n                    }\n\n                    self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);\n\n                    self.hasPinched = hasZoom;\n\n                    // Scale and translate the groups to provide visual feedback during pinching\n                    self.scaleGroups(transform, clip);\n\n                    if (self.res) {\n                        self.res = false;\n                        this.reset(false, 0);\n                    }\n                }\n            },\n\n            /**\n             * General touch handler shared by touchstart and touchmove.\n             */\n            touch: function(e, start) {\n                var chart = this.chart,\n                    hasMoved,\n                    pinchDown,\n                    isInside;\n\n                if (chart.index !== H.hoverChartIndex) {\n                    this.onContainerMouseLeave({\n                        relatedTarget: true\n                    });\n                }\n                H.hoverChartIndex = chart.index;\n\n                if (e.touches.length === 1) {\n\n                    e = this.normalize(e);\n\n                    isInside = chart.isInsidePlot(\n                        e.chartX - chart.plotLeft,\n                        e.chartY - chart.plotTop\n                    );\n                    if (isInside && !chart.openMenu) {\n\n                        // Run mouse events and display tooltip etc\n                        if (start) {\n                            this.runPointActions(e);\n                        }\n\n                        // Android fires touchmove events after the touchstart even if the\n                        // finger hasn't moved, or moved only a pixel or two. In iOS however,\n                        // the touchmove doesn't fire unless the finger moves more than ~4px.\n                        // So we emulate this behaviour in Android by checking how much it\n                        // moved, and cancelling on small distances. #3450.\n                        if (e.type === 'touchmove') {\n                            pinchDown = this.pinchDown;\n                            hasMoved = pinchDown[0] ? Math.sqrt( // #5266\n                                Math.pow(pinchDown[0].chartX - e.chartX, 2) +\n                                Math.pow(pinchDown[0].chartY - e.chartY, 2)\n                            ) >= 4 : false;\n                        }\n\n                        if (pick(hasMoved, true)) {\n                            this.pinch(e);\n                        }\n\n                    } else if (start) {\n                        // Hide the tooltip on touching outside the plot area (#1203)\n                        this.reset();\n                    }\n\n                } else if (e.touches.length === 2) {\n                    this.pinch(e);\n                }\n            },\n\n            onContainerTouchStart: function(e) {\n                this.zoomOption(e);\n                this.touch(e, true);\n            },\n\n            onContainerTouchMove: function(e) {\n                this.touch(e);\n            },\n\n            onDocumentTouchEnd: function(e) {\n                if (charts[H.hoverChartIndex]) {\n                    charts[H.hoverChartIndex].pointer.drop(e);\n                }\n            }\n\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            charts = H.charts,\n            css = H.css,\n            doc = H.doc,\n            extend = H.extend,\n            hasTouch = H.hasTouch,\n            noop = H.noop,\n            Pointer = H.Pointer,\n            removeEvent = H.removeEvent,\n            win = H.win,\n            wrap = H.wrap;\n\n        if (!hasTouch && (win.PointerEvent || win.MSPointerEvent)) {\n\n            // The touches object keeps track of the points being touched at all times\n            var touches = {},\n                hasPointerEvent = !!win.PointerEvent,\n                getWebkitTouches = function() {\n                    var fake = [];\n                    fake.item = function(i) {\n                        return this[i];\n                    };\n                    H.objectEach(touches, function(touch) {\n                        fake.push({\n                            pageX: touch.pageX,\n                            pageY: touch.pageY,\n                            target: touch.target\n                        });\n                    });\n                    return fake;\n                },\n                translateMSPointer = function(e, method, wktype, func) {\n                    var p;\n                    if ((e.pointerType === 'touch' || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && charts[H.hoverChartIndex]) {\n                        func(e);\n                        p = charts[H.hoverChartIndex].pointer;\n                        p[method]({\n                            type: wktype,\n                            target: e.currentTarget,\n                            preventDefault: noop,\n                            touches: getWebkitTouches()\n                        });\n                    }\n                };\n\n            /**\n             * Extend the Pointer prototype with methods for each event handler and more\n             */\n            extend(Pointer.prototype, /** @lends Pointer.prototype */ {\n                onContainerPointerDown: function(e) {\n                    translateMSPointer(e, 'onContainerTouchStart', 'touchstart', function(e) {\n                        touches[e.pointerId] = {\n                            pageX: e.pageX,\n                            pageY: e.pageY,\n                            target: e.currentTarget\n                        };\n                    });\n                },\n                onContainerPointerMove: function(e) {\n                    translateMSPointer(e, 'onContainerTouchMove', 'touchmove', function(e) {\n                        touches[e.pointerId] = {\n                            pageX: e.pageX,\n                            pageY: e.pageY\n                        };\n                        if (!touches[e.pointerId].target) {\n                            touches[e.pointerId].target = e.currentTarget;\n                        }\n                    });\n                },\n                onDocumentPointerUp: function(e) {\n                    translateMSPointer(e, 'onDocumentTouchEnd', 'touchend', function(e) {\n                        delete touches[e.pointerId];\n                    });\n                },\n\n                /**\n                 * Add or remove the MS Pointer specific events\n                 */\n                batchMSEvents: function(fn) {\n                    fn(this.chart.container, hasPointerEvent ? 'pointerdown' : 'MSPointerDown', this.onContainerPointerDown);\n                    fn(this.chart.container, hasPointerEvent ? 'pointermove' : 'MSPointerMove', this.onContainerPointerMove);\n                    fn(doc, hasPointerEvent ? 'pointerup' : 'MSPointerUp', this.onDocumentPointerUp);\n                }\n            });\n\n            // Disable default IE actions for pinch and such on chart element\n            wrap(Pointer.prototype, 'init', function(proceed, chart, options) {\n                proceed.call(this, chart, options);\n                if (this.hasZoom) { // #4014\n                    css(chart.container, {\n                        '-ms-touch-action': 'none',\n                        'touch-action': 'none'\n                    });\n                }\n            });\n\n            // Add IE specific touch events to chart\n            wrap(Pointer.prototype, 'setDOMEvents', function(proceed) {\n                proceed.apply(this);\n                if (this.hasZoom || this.followTouchMove) {\n                    this.batchMSEvents(addEvent);\n                }\n            });\n            // Destroy MS events also\n            wrap(Pointer.prototype, 'destroy', function(proceed) {\n                this.batchMSEvents(removeEvent);\n                proceed.call(this);\n            });\n        }\n\n    }(Highcharts));\n    (function(Highcharts) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var H = Highcharts,\n\n            addEvent = H.addEvent,\n            css = H.css,\n            discardElement = H.discardElement,\n            defined = H.defined,\n            each = H.each,\n            isFirefox = H.isFirefox,\n            marginNames = H.marginNames,\n            merge = H.merge,\n            pick = H.pick,\n            setAnimation = H.setAnimation,\n            stableSort = H.stableSort,\n            win = H.win,\n            wrap = H.wrap;\n\n        /**\n         * The overview of the chart's series. The legend object is instanciated\n         * internally in the chart constructor, and available from `chart.legend`. Each\n         * chart has only one legend.\n         * \n         * @class\n         */\n        Highcharts.Legend = function(chart, options) {\n            this.init(chart, options);\n        };\n\n        Highcharts.Legend.prototype = {\n\n            /**\n             * Initialize the legend\n             */\n            init: function(chart, options) {\n\n                this.chart = chart;\n\n                this.setOptions(options);\n\n                if (options.enabled) {\n\n                    // Render it\n                    this.render();\n\n                    // move checkboxes\n                    addEvent(this.chart, 'endResize', function() {\n                        this.legend.positionCheckboxes();\n                    });\n                }\n            },\n\n            setOptions: function(options) {\n\n                var padding = pick(options.padding, 8);\n\n                this.options = options;\n\n\n                this.itemStyle = options.itemStyle;\n                this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle);\n\n                this.itemMarginTop = options.itemMarginTop || 0;\n                this.padding = padding;\n                this.initialItemY = padding - 5; // 5 is pixels above the text\n                this.maxItemWidth = 0;\n                this.itemHeight = 0;\n                this.symbolWidth = pick(options.symbolWidth, 16);\n                this.pages = [];\n\n            },\n\n            /**\n             * Update the legend with new options. Equivalent to running `chart.update`\n             * with a legend configuration option.\n             * @param  {LegendOptions} options\n             *         Legend options.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart.\n             *\n             * @sample highcharts/legend/legend-update/\n             *         Legend update\n             */\n            update: function(options, redraw) {\n                var chart = this.chart;\n\n                this.setOptions(merge(true, this.options, options));\n                this.destroy();\n                chart.isDirtyLegend = chart.isDirtyBox = true;\n                if (pick(redraw, true)) {\n                    chart.redraw();\n                }\n            },\n\n            /**\n             * Set the colors for the legend item\n             * @param {Object} item A Series or Point instance\n             * @param {Object} visible Dimmed or colored\n             */\n            colorizeItem: function(item, visible) {\n                item.legendGroup[visible ? 'removeClass' : 'addClass'](\n                    'highcharts-legend-item-hidden'\n                );\n\n\n                var legend = this,\n                    options = legend.options,\n                    legendItem = item.legendItem,\n                    legendLine = item.legendLine,\n                    legendSymbol = item.legendSymbol,\n                    hiddenColor = legend.itemHiddenStyle.color,\n                    textColor = visible ? options.itemStyle.color : hiddenColor,\n                    symbolColor = visible ? (item.color || hiddenColor) : hiddenColor,\n                    markerOptions = item.options && item.options.marker,\n                    symbolAttr = {\n                        fill: symbolColor\n                    };\n\n                if (legendItem) {\n                    legendItem.css({\n                        fill: textColor,\n                        color: textColor // #1553, oldIE\n                    });\n                }\n                if (legendLine) {\n                    legendLine.attr({\n                        stroke: symbolColor\n                    });\n                }\n\n                if (legendSymbol) {\n\n                    // Apply marker options\n                    if (markerOptions && legendSymbol.isMarker) { // #585\n                        //symbolAttr.stroke = symbolColor;\n                        symbolAttr = item.pointAttribs();\n                        if (!visible) {\n                            H.objectEach(symbolAttr, function(val, key) {\n                                symbolAttr[key] = hiddenColor;\n                            });\n                        }\n                    }\n\n                    legendSymbol.attr(symbolAttr);\n                }\n\n            },\n\n            /**\n             * Position the legend item\n             * @param {Object} item A Series or Point instance\n             */\n            positionItem: function(item) {\n                var legend = this,\n                    options = legend.options,\n                    symbolPadding = options.symbolPadding,\n                    ltr = !options.rtl,\n                    legendItemPos = item._legendItemPos,\n                    itemX = legendItemPos[0],\n                    itemY = legendItemPos[1],\n                    checkbox = item.checkbox,\n                    legendGroup = item.legendGroup;\n\n                if (legendGroup && legendGroup.element) {\n                    legendGroup.translate(\n                        ltr ?\n                        itemX :\n                        legend.legendWidth - itemX - 2 * symbolPadding - 4,\n                        itemY\n                    );\n                }\n\n                if (checkbox) {\n                    checkbox.x = itemX;\n                    checkbox.y = itemY;\n                }\n            },\n\n            /**\n             * Destroy a single legend item\n             * @param {Object} item The series or point\n             */\n            destroyItem: function(item) {\n                var checkbox = item.checkbox;\n\n                // destroy SVG elements\n                each(\n                    ['legendItem', 'legendLine', 'legendSymbol', 'legendGroup'],\n                    function(key) {\n                        if (item[key]) {\n                            item[key] = item[key].destroy();\n                        }\n                    }\n                );\n\n                if (checkbox) {\n                    discardElement(item.checkbox);\n                }\n            },\n\n            /**\n             * Destroys the legend.\n             */\n            destroy: function() {\n                function destroyItems(key) {\n                    if (this[key]) {\n                        this[key] = this[key].destroy();\n                    }\n                }\n\n                // Destroy items\n                each(this.getAllItems(), function(item) {\n                    each(['legendItem', 'legendGroup'], destroyItems, item);\n                });\n\n                // Destroy legend elements\n                each([\n                    'clipRect',\n                    'up',\n                    'down',\n                    'pager',\n                    'nav',\n                    'box',\n                    'title',\n                    'group'\n                ], destroyItems, this);\n                this.display = null; // Reset in .render on update.\n            },\n\n            /**\n             * Position the checkboxes after the width is determined\n             */\n            positionCheckboxes: function(scrollOffset) {\n                var alignAttr = this.group && this.group.alignAttr,\n                    translateY,\n                    clipHeight = this.clipHeight || this.legendHeight,\n                    titleHeight = this.titleHeight;\n\n                if (alignAttr) {\n                    translateY = alignAttr.translateY;\n                    each(this.allItems, function(item) {\n                        var checkbox = item.checkbox,\n                            top;\n\n                        if (checkbox) {\n                            top = translateY + titleHeight + checkbox.y +\n                                (scrollOffset || 0) + 3;\n                            css(checkbox, {\n                                left: (alignAttr.translateX + item.checkboxOffset +\n                                    checkbox.x - 20) + 'px',\n                                top: top + 'px',\n                                display: top > translateY - 6 && top < translateY +\n                                    clipHeight - 6 ? '' : 'none'\n                            });\n                        }\n                    });\n                }\n            },\n\n            /**\n             * Render the legend title on top of the legend\n             */\n            renderTitle: function() {\n                var options = this.options,\n                    padding = this.padding,\n                    titleOptions = options.title,\n                    titleHeight = 0,\n                    bBox;\n\n                if (titleOptions.text) {\n                    if (!this.title) {\n                        this.title = this.chart.renderer.label(\n                                titleOptions.text,\n                                padding - 3,\n                                padding - 4,\n                                null,\n                                null,\n                                null,\n                                options.useHTML,\n                                null,\n                                'legend-title'\n                            )\n                            .attr({\n                                zIndex: 1\n                            })\n\n                            .css(titleOptions.style)\n\n                            .add(this.group);\n                    }\n                    bBox = this.title.getBBox();\n                    titleHeight = bBox.height;\n                    this.offsetWidth = bBox.width; // #1717\n                    this.contentGroup.attr({\n                        translateY: titleHeight\n                    });\n                }\n                this.titleHeight = titleHeight;\n            },\n\n            /**\n             * Set the legend item text\n             */\n            setText: function(item) {\n                var options = this.options;\n                item.legendItem.attr({\n                    text: options.labelFormat ?\n                        H.format(options.labelFormat, item) : options.labelFormatter.call(item)\n                });\n            },\n\n            /**\n             * Render a single specific legend item\n             * @param {Object} item A series or point\n             */\n            renderItem: function(item) {\n                var legend = this,\n                    chart = legend.chart,\n                    renderer = chart.renderer,\n                    options = legend.options,\n                    horizontal = options.layout === 'horizontal',\n                    symbolWidth = legend.symbolWidth,\n                    symbolPadding = options.symbolPadding,\n\n                    itemStyle = legend.itemStyle,\n                    itemHiddenStyle = legend.itemHiddenStyle,\n\n                    padding = legend.padding,\n                    itemDistance = horizontal ? pick(options.itemDistance, 20) : 0,\n                    ltr = !options.rtl,\n                    itemHeight,\n                    widthOption = options.width,\n                    itemMarginBottom = options.itemMarginBottom || 0,\n                    itemMarginTop = legend.itemMarginTop,\n                    bBox,\n                    itemWidth,\n                    li = item.legendItem,\n                    isSeries = !item.series,\n                    series = !isSeries && item.series.drawLegendSymbol ?\n                    item.series :\n                    item,\n                    seriesOptions = series.options,\n                    showCheckbox = legend.createCheckboxForItem &&\n                    seriesOptions &&\n                    seriesOptions.showCheckbox,\n                    // full width minus text width\n                    itemExtraWidth = symbolWidth + symbolPadding + itemDistance +\n                    (showCheckbox ? 20 : 0),\n                    useHTML = options.useHTML,\n                    fontSize = 12,\n                    itemClassName = item.options.className;\n\n                if (!li) { // generate it once, later move it\n\n                    // Generate the group box, a group to hold the symbol and text. Text\n                    // is to be appended in Legend class.\n                    item.legendGroup = renderer.g('legend-item')\n                        .addClass(\n                            'highcharts-' + series.type + '-series ' +\n                            'highcharts-color-' + item.colorIndex +\n                            (itemClassName ? ' ' + itemClassName : '') +\n                            (isSeries ? ' highcharts-series-' + item.index : '')\n                        )\n                        .attr({\n                            zIndex: 1\n                        })\n                        .add(legend.scrollGroup);\n\n                    // Generate the list item text and add it to the group\n                    item.legendItem = li = renderer.text(\n                            '',\n                            ltr ? symbolWidth + symbolPadding : -symbolPadding,\n                            legend.baseline || 0,\n                            useHTML\n                        )\n\n                        // merge to prevent modifying original (#1021)\n                        .css(merge(item.visible ? itemStyle : itemHiddenStyle))\n\n                        .attr({\n                            align: ltr ? 'left' : 'right',\n                            zIndex: 2\n                        })\n                        .add(item.legendGroup);\n\n                    // Get the baseline for the first item - the font size is equal for\n                    // all\n                    if (!legend.baseline) {\n\n                        fontSize = itemStyle.fontSize;\n\n                        legend.fontMetrics = renderer.fontMetrics(\n                            fontSize,\n                            li\n                        );\n                        legend.baseline = legend.fontMetrics.f + 3 + itemMarginTop;\n                        li.attr('y', legend.baseline);\n                    }\n\n                    // Draw the legend symbol inside the group box\n                    legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;\n                    series.drawLegendSymbol(legend, item);\n\n                    if (legend.setItemEvents) {\n                        legend.setItemEvents(item, li, useHTML);\n                    }\n\n                    // add the HTML checkbox on top\n                    if (showCheckbox) {\n                        legend.createCheckboxForItem(item);\n                    }\n                }\n\n                // Colorize the items\n                legend.colorizeItem(item, item.visible);\n\n                // Take care of max width and text overflow (#6659)\n\n                if (!itemStyle.width) {\n\n                    li.css({\n                        width: (options.itemWidth || chart.spacingBox.width) -\n                            itemExtraWidth\n                    });\n\n                }\n\n\n                // Always update the text\n                legend.setText(item);\n\n                // calculate the positions for the next line\n                bBox = li.getBBox();\n\n                itemWidth = item.checkboxOffset =\n                    options.itemWidth ||\n                    item.legendItemWidth ||\n                    bBox.width + itemExtraWidth;\n                legend.itemHeight = itemHeight = Math.round(\n                    item.legendItemHeight || bBox.height || legend.symbolHeight\n                );\n\n                // If the item exceeds the width, start a new line\n                if (\n                    horizontal &&\n                    legend.itemX - padding + itemWidth > (\n                        widthOption || (\n                            chart.spacingBox.width - 2 * padding - options.x\n                        )\n                    )\n                ) {\n                    legend.itemX = padding;\n                    legend.itemY += itemMarginTop + legend.lastLineHeight +\n                        itemMarginBottom;\n                    legend.lastLineHeight = 0; // reset for next line (#915, #3976)\n                }\n\n                // If the item exceeds the height, start a new column\n                /*if (!horizontal && legend.itemY + options.y +\n                \t\titemHeight > chart.chartHeight - spacingTop - spacingBottom) {\n                \tlegend.itemY = legend.initialItemY;\n                \tlegend.itemX += legend.maxItemWidth;\n                \tlegend.maxItemWidth = 0;\n                }*/\n\n                // Set the edge positions\n                legend.maxItemWidth = Math.max(legend.maxItemWidth, itemWidth);\n                legend.lastItemY = itemMarginTop + legend.itemY + itemMarginBottom;\n                legend.lastLineHeight = Math.max( // #915\n                    itemHeight,\n                    legend.lastLineHeight\n                );\n\n                // cache the position of the newly generated or reordered items\n                item._legendItemPos = [legend.itemX, legend.itemY];\n\n                // advance\n                if (horizontal) {\n                    legend.itemX += itemWidth;\n\n                } else {\n                    legend.itemY += itemMarginTop + itemHeight + itemMarginBottom;\n                    legend.lastLineHeight = itemHeight;\n                }\n\n                // the width of the widest item\n                legend.offsetWidth = widthOption || Math.max(\n                    (horizontal ? legend.itemX - padding - itemDistance : itemWidth) +\n                    padding,\n                    legend.offsetWidth\n                );\n            },\n\n            /**\n             * Get all items, which is one item per series for normal series and one\n             * item per point for pie series.\n             */\n            getAllItems: function() {\n                var allItems = [];\n                each(this.chart.series, function(series) {\n                    var seriesOptions = series && series.options;\n\n                    // Handle showInLegend. If the series is linked to another series,\n                    // defaults to false.\n                    if (series && pick(\n                            seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? undefined : false, true\n                        )) {\n\n                        // Use points or series for the legend item depending on\n                        // legendType\n                        allItems = allItems.concat(\n                            series.legendItems ||\n                            (\n                                seriesOptions.legendType === 'point' ?\n                                series.data :\n                                series\n                            )\n                        );\n                    }\n                });\n                return allItems;\n            },\n\n            /**\n             * Adjust the chart margins by reserving space for the legend on only one\n             * side of the chart. If the position is set to a corner, top or bottom is\n             * reserved for horizontal legends and left or right for vertical ones.\n             */\n            adjustMargins: function(margin, spacing) {\n                var chart = this.chart,\n                    options = this.options,\n                    // Use the first letter of each alignment option in order to detect\n                    // the side. (#4189 - use charAt(x) notation instead of [x] for IE7)\n                    alignment = options.align.charAt(0) +\n                    options.verticalAlign.charAt(0) +\n                    options.layout.charAt(0);\n\n                if (!options.floating) {\n\n                    each([\n                        /(lth|ct|rth)/,\n                        /(rtv|rm|rbv)/,\n                        /(rbh|cb|lbh)/,\n                        /(lbv|lm|ltv)/\n                    ], function(alignments, side) {\n                        if (alignments.test(alignment) && !defined(margin[side])) {\n                            // Now we have detected on which side of the chart we should\n                            // reserve space for the legend\n                            chart[marginNames[side]] = Math.max(\n                                chart[marginNames[side]],\n                                (\n                                    chart.legend[\n                                        (side + 1) % 2 ? 'legendHeight' : 'legendWidth'\n                                    ] + [1, -1, -1, 1][side] * options[\n                                        (side % 2) ? 'x' : 'y'\n                                    ] +\n                                    pick(options.margin, 12) +\n                                    spacing[side]\n                                )\n                            );\n                        }\n                    });\n                }\n            },\n\n            /**\n             * Render the legend. This method can be called both before and after\n             * chart.render. If called after, it will only rearrange items instead\n             * of creating new ones.\n             */\n            render: function() {\n                var legend = this,\n                    chart = legend.chart,\n                    renderer = chart.renderer,\n                    legendGroup = legend.group,\n                    allItems,\n                    display,\n                    legendWidth,\n                    legendHeight,\n                    box = legend.box,\n                    options = legend.options,\n                    padding = legend.padding;\n\n                legend.itemX = padding;\n                legend.itemY = legend.initialItemY;\n                legend.offsetWidth = 0;\n                legend.lastItemY = 0;\n\n                if (!legendGroup) {\n                    legend.group = legendGroup = renderer.g('legend')\n                        .attr({\n                            zIndex: 7\n                        })\n                        .add();\n                    legend.contentGroup = renderer.g()\n                        .attr({\n                            zIndex: 1\n                        }) // above background\n                        .add(legendGroup);\n                    legend.scrollGroup = renderer.g()\n                        .add(legend.contentGroup);\n                }\n\n                legend.renderTitle();\n\n                // add each series or point\n                allItems = legend.getAllItems();\n\n                // sort by legendIndex\n                stableSort(allItems, function(a, b) {\n                    return ((a.options && a.options.legendIndex) || 0) -\n                        ((b.options && b.options.legendIndex) || 0);\n                });\n\n                // reversed legend\n                if (options.reversed) {\n                    allItems.reverse();\n                }\n\n                legend.allItems = allItems;\n                legend.display = display = !!allItems.length;\n\n                // render the items\n                legend.lastLineHeight = 0;\n                each(allItems, function(item) {\n                    legend.renderItem(item);\n                });\n\n                // Get the box\n                legendWidth = (options.width || legend.offsetWidth) + padding;\n                legendHeight = legend.lastItemY + legend.lastLineHeight +\n                    legend.titleHeight;\n                legendHeight = legend.handleOverflow(legendHeight);\n                legendHeight += padding;\n\n                // Draw the border and/or background\n                if (!box) {\n                    legend.box = box = renderer.rect()\n                        .addClass('highcharts-legend-box')\n                        .attr({\n                            r: options.borderRadius\n                        })\n                        .add(legendGroup);\n                    box.isNew = true;\n                }\n\n\n                // Presentational\n                box\n                    .attr({\n                        stroke: options.borderColor,\n                        'stroke-width': options.borderWidth || 0,\n                        fill: options.backgroundColor || 'none'\n                    })\n                    .shadow(options.shadow);\n\n\n                if (legendWidth > 0 && legendHeight > 0) {\n                    box[box.isNew ? 'attr' : 'animate'](\n                        box.crisp({\n                            x: 0,\n                            y: 0,\n                            width: legendWidth,\n                            height: legendHeight\n                        }, box.strokeWidth())\n                    );\n                    box.isNew = false;\n                }\n\n                // hide the border if no items\n                box[display ? 'show' : 'hide']();\n\n\n\n                legend.legendWidth = legendWidth;\n                legend.legendHeight = legendHeight;\n\n                // Now that the legend width and height are established, put the items\n                // in the final position\n                each(allItems, function(item) {\n                    legend.positionItem(item);\n                });\n\n                // 1.x compatibility: positioning based on style\n                /*var props = ['left', 'right', 'top', 'bottom'],\n                \tprop,\n                \ti = 4;\n                while (i--) {\n                \tprop = props[i];\n                \tif (options.style[prop] && options.style[prop] !== 'auto') {\n                \t\toptions[i < 2 ? 'align' : 'verticalAlign'] = prop;\n                \t\toptions[i < 2 ? 'x' : 'y'] = \n                \t\t\tpInt(options.style[prop]) * (i % 2 ? -1 : 1);\n                \t}\n                }*/\n\n                if (display) {\n                    legendGroup.align(merge(options, {\n                        width: legendWidth,\n                        height: legendHeight\n                    }), true, 'spacingBox');\n                }\n\n                if (!chart.isResizing) {\n                    this.positionCheckboxes();\n                }\n            },\n\n            /**\n             * Set up the overflow handling by adding navigation with up and down arrows\n             * below the legend.\n             */\n            handleOverflow: function(legendHeight) {\n                var legend = this,\n                    chart = this.chart,\n                    renderer = chart.renderer,\n                    options = this.options,\n                    optionsY = options.y,\n                    alignTop = options.verticalAlign === 'top',\n                    padding = this.padding,\n                    spaceHeight = chart.spacingBox.height +\n                    (alignTop ? -optionsY : optionsY) - padding,\n                    maxHeight = options.maxHeight,\n                    clipHeight,\n                    clipRect = this.clipRect,\n                    navOptions = options.navigation,\n                    animation = pick(navOptions.animation, true),\n                    arrowSize = navOptions.arrowSize || 12,\n                    nav = this.nav,\n                    pages = this.pages,\n                    lastY,\n                    allItems = this.allItems,\n                    clipToHeight = function(height) {\n                        if (typeof height === 'number') {\n                            clipRect.attr({\n                                height: height\n                            });\n                        } else if (clipRect) { // Reset (#5912)\n                            legend.clipRect = clipRect.destroy();\n                            legend.contentGroup.clip();\n                        }\n\n                        // useHTML\n                        if (legend.contentGroup.div) {\n                            legend.contentGroup.div.style.clip = height ?\n                                'rect(' + padding + 'px,9999px,' +\n                                (padding + height) + 'px,0)' :\n                                'auto';\n                        }\n                    };\n\n\n                // Adjust the height\n                if (\n                    options.layout === 'horizontal' &&\n                    options.verticalAlign !== 'middle' &&\n                    !options.floating\n                ) {\n                    spaceHeight /= 2;\n                }\n                if (maxHeight) {\n                    spaceHeight = Math.min(spaceHeight, maxHeight);\n                }\n\n                // Reset the legend height and adjust the clipping rectangle\n                pages.length = 0;\n                if (legendHeight > spaceHeight && navOptions.enabled !== false) {\n\n                    this.clipHeight = clipHeight =\n                        Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);\n                    this.currentPage = pick(this.currentPage, 1);\n                    this.fullHeight = legendHeight;\n\n                    // Fill pages with Y positions so that the top of each a legend item\n                    // defines the scroll top for each page (#2098)\n                    each(allItems, function(item, i) {\n                        var y = item._legendItemPos[1],\n                            h = Math.round(item.legendItem.getBBox().height),\n                            len = pages.length;\n\n                        if (!len || (y - pages[len - 1] > clipHeight &&\n                                (lastY || y) !== pages[len - 1])) {\n                            pages.push(lastY || y);\n                            len++;\n                        }\n\n                        if (i === allItems.length - 1 &&\n                            y + h - pages[len - 1] > clipHeight) {\n                            pages.push(y);\n                        }\n                        if (y !== lastY) {\n                            lastY = y;\n                        }\n                    });\n\n                    // Only apply clipping if needed. Clipping causes blurred legend in\n                    // PDF export (#1787)\n                    if (!clipRect) {\n                        clipRect = legend.clipRect =\n                            renderer.clipRect(0, padding, 9999, 0);\n                        legend.contentGroup.clip(clipRect);\n                    }\n\n                    clipToHeight(clipHeight);\n\n                    // Add navigation elements\n                    if (!nav) {\n                        this.nav = nav = renderer.g()\n                            .attr({\n                                zIndex: 1\n                            })\n                            .add(this.group);\n\n                        this.up = renderer\n                            .symbol(\n                                'triangle',\n                                0,\n                                0,\n                                arrowSize,\n                                arrowSize\n                            )\n                            .on('click', function() {\n                                legend.scroll(-1, animation);\n                            })\n                            .add(nav);\n\n                        this.pager = renderer.text('', 15, 10)\n                            .addClass('highcharts-legend-navigation')\n\n                            .css(navOptions.style)\n\n                            .add(nav);\n\n                        this.down = renderer\n                            .symbol(\n                                'triangle-down',\n                                0,\n                                0,\n                                arrowSize,\n                                arrowSize\n                            )\n                            .on('click', function() {\n                                legend.scroll(1, animation);\n                            })\n                            .add(nav);\n                    }\n\n                    // Set initial position\n                    legend.scroll(0);\n\n                    legendHeight = spaceHeight;\n\n                    // Reset\n                } else if (nav) {\n                    clipToHeight();\n                    this.nav = nav.destroy(); // #6322\n                    this.scrollGroup.attr({\n                        translateY: 1\n                    });\n                    this.clipHeight = 0; // #1379\n                }\n\n                return legendHeight;\n            },\n\n            /**\n             * Scroll the legend by a number of pages\n             * @param {Object} scrollBy\n             * @param {Object} animation\n             */\n            scroll: function(scrollBy, animation) {\n                var pages = this.pages,\n                    pageCount = pages.length,\n                    currentPage = this.currentPage + scrollBy,\n                    clipHeight = this.clipHeight,\n                    navOptions = this.options.navigation,\n                    pager = this.pager,\n                    padding = this.padding,\n                    scrollOffset;\n\n                // When resizing while looking at the last page\n                if (currentPage > pageCount) {\n                    currentPage = pageCount;\n                }\n\n                if (currentPage > 0) {\n\n                    if (animation !== undefined) {\n                        setAnimation(animation, this.chart);\n                    }\n\n                    this.nav.attr({\n                        translateX: padding,\n                        translateY: clipHeight + this.padding + 7 + this.titleHeight,\n                        visibility: 'visible'\n                    });\n                    this.up.attr({\n                        'class': currentPage === 1 ?\n                            'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n                    });\n                    pager.attr({\n                        text: currentPage + '/' + pageCount\n                    });\n                    this.down.attr({\n                        'x': 18 + this.pager.getBBox().width, // adjust to text width\n                        'class': currentPage === pageCount ?\n                            'highcharts-legend-nav-inactive' : 'highcharts-legend-nav-active'\n                    });\n\n\n                    this.up\n                        .attr({\n                            fill: currentPage === 1 ?\n                                navOptions.inactiveColor : navOptions.activeColor\n                        })\n                        .css({\n                            cursor: currentPage === 1 ? 'default' : 'pointer'\n                        });\n                    this.down\n                        .attr({\n                            fill: currentPage === pageCount ?\n                                navOptions.inactiveColor : navOptions.activeColor\n                        })\n                        .css({\n                            cursor: currentPage === pageCount ? 'default' : 'pointer'\n                        });\n\n\n                    scrollOffset = -pages[currentPage - 1] + this.initialItemY;\n\n                    this.scrollGroup.animate({\n                        translateY: scrollOffset\n                    });\n\n                    this.currentPage = currentPage;\n                    this.positionCheckboxes(scrollOffset);\n                }\n\n            }\n\n        };\n\n        /*\n         * LegendSymbolMixin\n         */\n\n        H.LegendSymbolMixin = {\n\n            /**\n             * Get the series' symbol in the legend\n             *\n             * @param {Object} legend The legend object\n             * @param {Object} item The series (this) or point\n             */\n            drawRectangle: function(legend, item) {\n                var options = legend.options,\n                    symbolHeight = legend.symbolHeight,\n                    square = options.squareSymbol,\n                    symbolWidth = square ? symbolHeight : legend.symbolWidth;\n\n                item.legendSymbol = this.chart.renderer.rect(\n                        square ? (legend.symbolWidth - symbolHeight) / 2 : 0,\n                        legend.baseline - symbolHeight + 1, // #3988\n                        symbolWidth,\n                        symbolHeight,\n                        pick(legend.options.symbolRadius, symbolHeight / 2)\n                    )\n                    .addClass('highcharts-point')\n                    .attr({\n                        zIndex: 3\n                    }).add(item.legendGroup);\n\n            },\n\n            /**\n             * Get the series' symbol in the legend. This method should be overridable\n             * to create custom symbols through\n             * Highcharts.seriesTypes[type].prototype.drawLegendSymbols.\n             *\n             * @param {Object} legend The legend object\n             */\n            drawLineMarker: function(legend) {\n\n                var options = this.options,\n                    markerOptions = options.marker,\n                    radius,\n                    legendSymbol,\n                    symbolWidth = legend.symbolWidth,\n                    symbolHeight = legend.symbolHeight,\n                    generalRadius = symbolHeight / 2,\n                    renderer = this.chart.renderer,\n                    legendItemGroup = this.legendGroup,\n                    verticalCenter = legend.baseline -\n                    Math.round(legend.fontMetrics.b * 0.3),\n                    attr = {};\n\n                // Draw the line\n\n                attr = {\n                    'stroke-width': options.lineWidth || 0\n                };\n                if (options.dashStyle) {\n                    attr.dashstyle = options.dashStyle;\n                }\n\n\n                this.legendLine = renderer.path([\n                        'M',\n                        0,\n                        verticalCenter,\n                        'L',\n                        symbolWidth,\n                        verticalCenter\n                    ])\n                    .addClass('highcharts-graph')\n                    .attr(attr)\n                    .add(legendItemGroup);\n\n                // Draw the marker\n                if (markerOptions && markerOptions.enabled !== false) {\n\n                    // Do not allow the marker to be larger than the symbolHeight\n                    radius = Math.min(\n                        pick(markerOptions.radius, generalRadius),\n                        generalRadius\n                    );\n\n                    // Restrict symbol markers size\n                    if (this.symbol.indexOf('url') === 0) {\n                        markerOptions = merge(markerOptions, {\n                            width: symbolHeight,\n                            height: symbolHeight\n                        });\n                        radius = 0;\n                    }\n\n                    this.legendSymbol = legendSymbol = renderer.symbol(\n                            this.symbol,\n                            (symbolWidth / 2) - radius,\n                            verticalCenter - radius,\n                            2 * radius,\n                            2 * radius,\n                            markerOptions\n                        )\n                        .addClass('highcharts-point')\n                        .add(legendItemGroup);\n                    legendSymbol.isMarker = true;\n                }\n            }\n        };\n\n        // Workaround for #2030, horizontal legend items not displaying in IE11 Preview,\n        // and for #2580, a similar drawing flaw in Firefox 26.\n        // Explore if there's a general cause for this. The problem may be related\n        // to nested group elements, as the legend item texts are within 4 group\n        // elements.\n        if (/Trident\\/7\\.0/.test(win.navigator.userAgent) || isFirefox) {\n            wrap(Highcharts.Legend.prototype, 'positionItem', function(proceed, item) {\n                var legend = this,\n                    // If chart destroyed in sync, this is undefined (#2030)\n                    runPositionItem = function() {\n                        if (item._legendItemPos) {\n                            proceed.call(legend, item);\n                        }\n                    };\n\n                // Do it now, for export and to get checkbox placement\n                runPositionItem();\n\n                // Do it after to work around the core issue\n                setTimeout(runPositionItem);\n            });\n        }\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            animate = H.animate,\n            animObject = H.animObject,\n            attr = H.attr,\n            doc = H.doc,\n            Axis = H.Axis, // @todo add as requirement\n            createElement = H.createElement,\n            defaultOptions = H.defaultOptions,\n            discardElement = H.discardElement,\n            charts = H.charts,\n            css = H.css,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            find = H.find,\n            fireEvent = H.fireEvent,\n            getStyle = H.getStyle,\n            grep = H.grep,\n            isNumber = H.isNumber,\n            isObject = H.isObject,\n            isString = H.isString,\n            Legend = H.Legend, // @todo add as requirement\n            marginNames = H.marginNames,\n            merge = H.merge,\n            objectEach = H.objectEach,\n            Pointer = H.Pointer, // @todo add as requirement\n            pick = H.pick,\n            pInt = H.pInt,\n            removeEvent = H.removeEvent,\n            seriesTypes = H.seriesTypes,\n            splat = H.splat,\n            svg = H.svg,\n            syncTimeout = H.syncTimeout,\n            win = H.win,\n            Renderer = H.Renderer;\n        /**\n         * The Chart class. The recommended constructor is {@link Highcharts#chart}.\n         * @class Highcharts.Chart\n         * @param  {String|HTMLDOMElement} renderTo\n         *         The DOM element to render to, or its id.\n         * @param  {Options} options\n         *         The chart options structure.\n         * @param  {Function} [callback]\n         *         Function to run when the chart has loaded and and all external images\n         *         are loaded. Defining a {@link\n         *         https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n         *         handler is equivalent.\n         *\n         * @example\n         * var chart = new Highcharts.Chart('container', {\n         * \t   title: {\n         * \t   \t   text: 'My chart'\n         * \t   },\n         * \t   series: [{\n         * \t       data: [1, 3, 2, 4]\n         * \t   }]\n         * })\n         */\n        var Chart = H.Chart = function() {\n            this.getArgs.apply(this, arguments);\n        };\n\n        /**\n         * Factory function for basic charts. \n         *\n         * @function #chart\n         * @memberOf Highcharts\n         * @param  {String|HTMLDOMElement} renderTo - The DOM element to render to, or\n         * its id.\n         * @param  {Options} options - The chart options structure.\n         * @param  {Function} [callback] - Function to run when the chart has loaded and\n         * and all external images are loaded. Defining a {@link\n         * https://api.highcharts.com/highcharts/chart.events.load|chart.event.load}\n         * handler is equivalent.\n         * @return {Highcharts.Chart} - Returns the Chart object.\n         *\n         * @example\n         * // Render a chart in to div#container\n         * var chart = Highcharts.chart('container', {\n         *     title: {\n         *         text: 'My chart'\n         *     },\n         *     series: [{\n         *         data: [1, 3, 2, 4]\n         *     }]\n         * });\n         */\n        H.chart = function(a, b, c) {\n            return new Chart(a, b, c);\n        };\n\n        extend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {\n\n            /**\n             * Hook for modules\n             */\n            callbacks: [],\n\n            /**\n             * Handle the arguments passed to the constructor\n             * @returns {Array} Arguments without renderTo\n             */\n            getArgs: function() {\n                var args = [].slice.call(arguments);\n\n                // Remove the optional first argument, renderTo, and\n                // set it on this.\n                if (isString(args[0]) || args[0].nodeName) {\n                    this.renderTo = args.shift();\n                }\n                this.init(args[0], args[1]);\n            },\n\n            /**\n             * Initialize the chart\n             */\n            init: function(userOptions, callback) {\n\n                // Handle regular options\n                var options,\n                    type,\n                    seriesOptions = userOptions.series, // skip merging data points to increase performance\n                    userPlotOptions = userOptions.plotOptions || {};\n\n                userOptions.series = null;\n                options = merge(defaultOptions, userOptions); // do the merge\n\n                // Override (by copy of user options) or clear tooltip options\n                // in chart.options.plotOptions (#6218)\n                for (type in options.plotOptions) {\n                    options.plotOptions[type].tooltip = (\n                        userPlotOptions[type] &&\n                        merge(userPlotOptions[type].tooltip) // override by copy\n                    ) || undefined; // or clear\n                }\n                // User options have higher priority than default options (#6218).\n                // In case of exporting: path is changed\n                options.tooltip.userOptions = (userOptions.chart &&\n                        userOptions.chart.forExport && userOptions.tooltip.userOptions) ||\n                    userOptions.tooltip;\n\n                options.series = userOptions.series = seriesOptions; // set back the series data\n                this.userOptions = userOptions;\n\n                var optionsChart = options.chart;\n\n                var chartEvents = optionsChart.events;\n\n                this.margin = [];\n                this.spacing = [];\n\n                //this.runChartClick = chartEvents && !!chartEvents.click;\n                this.bounds = {\n                    h: {},\n                    v: {}\n                }; // Pixel data bounds for touch zoom\n\n                this.callback = callback;\n                this.isResizing = 0;\n\n                /**\n                 * The options structure for the chart. It contains members for the sub\n                 * elements like series, legend, tooltip etc.\n                 *\n                 * @memberof Highcharts.Chart\n                 * @name options\n                 * @type {Options}\n                 */\n                this.options = options;\n                /**\n                 * All the axes in the chart.\n                 *\n                 * @memberof Highcharts.Chart\n                 * @name axes\n                 * @see  Highcharts.Chart.xAxis\n                 * @see  Highcharts.Chart.yAxis\n                 * @type {Array.<Highcharts.Axis>}\n                 */\n                this.axes = [];\n\n                /**\n                 * All the current series in the chart.\n                 *\n                 * @memberof Highcharts.Chart\n                 * @name series\n                 * @type {Array.<Highcharts.Series>}\n                 */\n                this.series = [];\n\n                /**\n                 * The chart title. The title has an `update` method that allows\n                 * modifying the options directly or indirectly via `chart.update`.\n                 *\n                 * @memberof Highcharts.Chart\n                 * @name title\n                 * @type Object\n                 *\n                 * @sample highcharts/members/title-update/\n                 *         Updating titles\n                 */\n\n                /**\n                 * The chart subtitle. The subtitle has an `update` method that allows\n                 * modifying the options directly or indirectly via `chart.update`.\n                 *\n                 * @memberof Highcharts.Chart\n                 * @name subtitle\n                 * @type Object\n                 */\n\n\n\n                this.hasCartesianSeries = optionsChart.showAxes;\n                //this.axisOffset = undefined;\n                //this.inverted = undefined;\n                //this.loadingShown = undefined;\n                //this.container = undefined;\n                //this.chartWidth = undefined;\n                //this.chartHeight = undefined;\n                //this.marginRight = undefined;\n                //this.marginBottom = undefined;\n                //this.containerWidth = undefined;\n                //this.containerHeight = undefined;\n                //this.oldChartWidth = undefined;\n                //this.oldChartHeight = undefined;\n\n                //this.renderTo = undefined;\n\n                //this.spacingBox = undefined\n\n                //this.legend = undefined;\n\n                // Elements\n                //this.chartBackground = undefined;\n                //this.plotBackground = undefined;\n                //this.plotBGImage = undefined;\n                //this.plotBorder = undefined;\n                //this.loadingDiv = undefined;\n                //this.loadingSpan = undefined;\n\n                var chart = this;\n\n                // Add the chart to the global lookup\n                chart.index = charts.length;\n\n                charts.push(chart);\n                H.chartCount++;\n\n                // Chart event handlers\n                if (chartEvents) {\n                    objectEach(chartEvents, function(event, eventType) {\n                        addEvent(chart, eventType, event);\n                    });\n                }\n\n                /**\n                 * A collection of the X axes in the chart.\n                 * @type {Array.<Highcharts.Axis>}\n                 * @name xAxis\n                 * @memberOf Highcharts.Chart\n                 */\n                chart.xAxis = [];\n                /**\n                 * A collection of the Y axes in the chart.\n                 * @type {Array.<Highcharts.Axis>}\n                 * @name yAxis\n                 * @memberOf Highcharts.Chart\n                 */\n                chart.yAxis = [];\n\n                chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;\n\n                chart.firstRender();\n            },\n\n            /**\n             * Initialize an individual series, called internally before render time\n             */\n            initSeries: function(options) {\n                var chart = this,\n                    optionsChart = chart.options.chart,\n                    type = options.type || optionsChart.type || optionsChart.defaultSeriesType,\n                    series,\n                    Constr = seriesTypes[type];\n\n                // No such series type\n                if (!Constr) {\n                    H.error(17, true);\n                }\n\n                series = new Constr();\n                series.init(this, options);\n                return series;\n            },\n\n            /**\n             * Order all series above a given index. When series are added and ordered\n             * by configuration, only the last series is handled (#248, #1123, #2456,\n             * #6112). This function is called on series initialization and destroy.\n             *\n             * @param {number} fromIndex - If this is given, only the series above this\n             *\t index are handled.\n             */\n            orderSeries: function(fromIndex) {\n                var series = this.series,\n                    i = fromIndex || 0;\n                for (; i < series.length; i++) {\n                    if (series[i]) {\n                        series[i].index = i;\n                        series[i].name = series[i].name ||\n                            'Series ' + (series[i].index + 1);\n                    }\n                }\n            },\n\n            /**\n             * Check whether a given point is within the plot area\n             *\n             * @param {Number} plotX Pixel x relative to the plot area\n             * @param {Number} plotY Pixel y relative to the plot area\n             * @param {Boolean} inverted Whether the chart is inverted\n             */\n            isInsidePlot: function(plotX, plotY, inverted) {\n                var x = inverted ? plotY : plotX,\n                    y = inverted ? plotX : plotY;\n\n                return x >= 0 &&\n                    x <= this.plotWidth &&\n                    y >= 0 &&\n                    y <= this.plotHeight;\n            },\n\n            /**\n             * Redraw the chart after changes have been done to the data, axis extremes\n             * chart size or chart elements. All methods for updating axes, series or\n             * points have a parameter for redrawing the chart. This is `true` by\n             * default. But in many cases you want to do more than one operation on the\n             * chart before redrawing, for example add a number of points. In those\n             * cases it is a waste of resources to redraw the chart for each new point\n             * added. So you add the points and call `chart.redraw()` after.\n             *\n             * @param  {AnimationOptions} animation\n             *         If or how to apply animation to the redraw.\n             */\n            redraw: function(animation) {\n                var chart = this,\n                    axes = chart.axes,\n                    series = chart.series,\n                    pointer = chart.pointer,\n                    legend = chart.legend,\n                    redrawLegend = chart.isDirtyLegend,\n                    hasStackedSeries,\n                    hasDirtyStacks,\n                    hasCartesianSeries = chart.hasCartesianSeries,\n                    isDirtyBox = chart.isDirtyBox,\n                    i,\n                    serie,\n                    renderer = chart.renderer,\n                    isHiddenChart = renderer.isHidden(),\n                    afterRedraw = [];\n\n                // Handle responsive rules, not only on resize (#6130)\n                if (chart.setResponsive) {\n                    chart.setResponsive(false);\n                }\n\n                H.setAnimation(animation, chart);\n\n                if (isHiddenChart) {\n                    chart.temporaryDisplay();\n                }\n\n                // Adjust title layout (reflow multiline text)\n                chart.layOutTitles();\n\n                // link stacked series\n                i = series.length;\n                while (i--) {\n                    serie = series[i];\n\n                    if (serie.options.stacking) {\n                        hasStackedSeries = true;\n\n                        if (serie.isDirty) {\n                            hasDirtyStacks = true;\n                            break;\n                        }\n                    }\n                }\n                if (hasDirtyStacks) { // mark others as dirty\n                    i = series.length;\n                    while (i--) {\n                        serie = series[i];\n                        if (serie.options.stacking) {\n                            serie.isDirty = true;\n                        }\n                    }\n                }\n\n                // Handle updated data in the series\n                each(series, function(serie) {\n                    if (serie.isDirty) {\n                        if (serie.options.legendType === 'point') {\n                            if (serie.updateTotals) {\n                                serie.updateTotals();\n                            }\n                            redrawLegend = true;\n                        }\n                    }\n                    if (serie.isDirtyData) {\n                        fireEvent(serie, 'updatedData');\n                    }\n                });\n\n                // handle added or removed series\n                if (redrawLegend && legend.options.enabled) { // series or pie points are added or removed\n                    // draw legend graphics\n                    legend.render();\n\n                    chart.isDirtyLegend = false;\n                }\n\n                // reset stacks\n                if (hasStackedSeries) {\n                    chart.getStacks();\n                }\n\n\n                if (hasCartesianSeries) {\n                    // set axes scales\n                    each(axes, function(axis) {\n                        axis.updateNames();\n                        axis.setScale();\n                    });\n                }\n\n                chart.getMargins(); // #3098\n\n                if (hasCartesianSeries) {\n                    // If one axis is dirty, all axes must be redrawn (#792, #2169)\n                    each(axes, function(axis) {\n                        if (axis.isDirty) {\n                            isDirtyBox = true;\n                        }\n                    });\n\n                    // redraw axes\n                    each(axes, function(axis) {\n\n                        // Fire 'afterSetExtremes' only if extremes are set\n                        var key = axis.min + ',' + axis.max;\n                        if (axis.extKey !== key) { // #821, #4452\n                            axis.extKey = key;\n                            afterRedraw.push(function() { // prevent a recursive call to chart.redraw() (#1119)\n                                fireEvent(axis, 'afterSetExtremes', extend(axis.eventArgs, axis.getExtremes())); // #747, #751\n                                delete axis.eventArgs;\n                            });\n                        }\n                        if (isDirtyBox || hasStackedSeries) {\n                            axis.redraw();\n                        }\n                    });\n                }\n\n                // the plot areas size has changed\n                if (isDirtyBox) {\n                    chart.drawChartBox();\n                }\n\n                // Fire an event before redrawing series, used by the boost module to\n                // clear previous series renderings.\n                fireEvent(chart, 'predraw');\n\n                // redraw affected series\n                each(series, function(serie) {\n                    if ((isDirtyBox || serie.isDirty) && serie.visible) {\n                        serie.redraw();\n                    }\n                    // Set it here, otherwise we will have unlimited 'updatedData' calls\n                    // for a hidden series after setData(). Fixes #6012\n                    serie.isDirtyData = false;\n                });\n\n                // move tooltip or reset\n                if (pointer) {\n                    pointer.reset(true);\n                }\n\n                // redraw if canvas\n                renderer.draw();\n\n                // Fire the events\n                fireEvent(chart, 'redraw');\n                fireEvent(chart, 'render');\n\n                if (isHiddenChart) {\n                    chart.temporaryDisplay(true);\n                }\n\n                // Fire callbacks that are put on hold until after the redraw\n                each(afterRedraw, function(callback) {\n                    callback.call();\n                });\n            },\n\n            /**\n             * Get an axis, series or point object by `id` as given in the configuration\n             * options. Returns `undefined` if no item is found.\n             * @param id {String} The id as given in the configuration options.\n             * @return {Highcharts.Axis|Highcharts.Series|Highcharts.Point|undefined}\n             *         The retrieved item.\n             * @sample highcharts/plotoptions/series-id/\n             *         Get series by id\n             */\n            get: function(id) {\n\n                var ret,\n                    series = this.series,\n                    i;\n\n                function itemById(item) {\n                    return item.id === id || (item.options && item.options.id === id);\n                }\n\n                ret =\n                    // Search axes\n                    find(this.axes, itemById) ||\n\n                    // Search series\n                    find(this.series, itemById);\n\n                // Search points\n                for (i = 0; !ret && i < series.length; i++) {\n                    ret = find(series[i].points || [], itemById);\n                }\n\n                return ret;\n            },\n\n            /**\n             * Create the Axis instances based on the config options\n             */\n            getAxes: function() {\n                var chart = this,\n                    options = this.options,\n                    xAxisOptions = options.xAxis = splat(options.xAxis || {}),\n                    yAxisOptions = options.yAxis = splat(options.yAxis || {}),\n                    optionsArray;\n\n                // make sure the options are arrays and add some members\n                each(xAxisOptions, function(axis, i) {\n                    axis.index = i;\n                    axis.isX = true;\n                });\n\n                each(yAxisOptions, function(axis, i) {\n                    axis.index = i;\n                });\n\n                // concatenate all axis options into one array\n                optionsArray = xAxisOptions.concat(yAxisOptions);\n\n                each(optionsArray, function(axisOptions) {\n                    new Axis(chart, axisOptions); // eslint-disable-line no-new\n                });\n            },\n\n\n            /**\n             * Returns an array of all currently selected points in the chart. Points\n             * can be selected by clicking or programmatically by the {@link\n             * Highcharts.Point#select} function.\n             *\n             * @return {Array.<Highcharts.Point>}\n             *         The currently selected points.\n             *\n             * @sample highcharts/plotoptions/series-allowpointselect-line/\n             *         Get selected points\n             */\n            getSelectedPoints: function() {\n                var points = [];\n                each(this.series, function(serie) {\n                    // series.data - for points outside of viewed range (#6445)\n                    points = points.concat(grep(serie.data || [], function(point) {\n                        return point.selected;\n                    }));\n                });\n                return points;\n            },\n\n            /**\n             * Returns an array of all currently selected series in the chart. Series\n             * can be selected either programmatically by the {@link\n             * Highcharts.Series#select} function or by checking the checkbox next to\n             * the legend item if {@link\n             * https://api.highcharts.com/highcharts/plotOptions.series.showCheckbox|\n             * series.showCheckBox} is true.\n             * \n             * @return {Array.<Highcharts.Series>}\n             *         The currently selected series.\n             *\n             * @sample highcharts/members/chart-getselectedseries/\n             *         Get selected series\n             */\n            getSelectedSeries: function() {\n                return grep(this.series, function(serie) {\n                    return serie.selected;\n                });\n            },\n\n            /**\n             * Set a new title or subtitle for the chart.\n             *\n             * @param  titleOptions {TitleOptions}\n             *         New title options.\n             * @param  subtitleOptions {SubtitleOptions}\n             *         New subtitle options.\n             * @param  redraw {Boolean}\n             *         Whether to redraw the chart or wait for a later call to \n             *         `chart.redraw()`.\n             *\n             * @sample highcharts/members/chart-settitle/ Set title text and styles\n             *\n             */\n            setTitle: function(titleOptions, subtitleOptions, redraw) {\n                var chart = this,\n                    options = chart.options,\n                    chartTitleOptions,\n                    chartSubtitleOptions;\n\n                chartTitleOptions = options.title = merge(\n\n                    // Default styles\n                    {\n                        style: {\n                            color: '#333333',\n                            fontSize: options.isStock ? '16px' : '18px' // #2944\n                        }\n                    },\n\n                    options.title,\n                    titleOptions\n                );\n                chartSubtitleOptions = options.subtitle = merge(\n\n                    // Default styles\n                    {\n                        style: {\n                            color: '#666666'\n                        }\n                    },\n\n                    options.subtitle,\n                    subtitleOptions\n                );\n\n                // add title and subtitle\n                each([\n                    ['title', titleOptions, chartTitleOptions],\n                    ['subtitle', subtitleOptions, chartSubtitleOptions]\n                ], function(arr, i) {\n                    var name = arr[0],\n                        title = chart[name],\n                        titleOptions = arr[1],\n                        chartTitleOptions = arr[2];\n\n                    if (title && titleOptions) {\n                        chart[name] = title = title.destroy(); // remove old\n                    }\n\n                    if (chartTitleOptions && chartTitleOptions.text && !title) {\n                        chart[name] = chart.renderer.text(\n                                chartTitleOptions.text,\n                                0,\n                                0,\n                                chartTitleOptions.useHTML\n                            )\n                            .attr({\n                                align: chartTitleOptions.align,\n                                'class': 'highcharts-' + name,\n                                zIndex: chartTitleOptions.zIndex || 4\n                            })\n                            .add();\n\n                        // Update methods, shortcut to Chart.setTitle\n                        chart[name].update = function(o) {\n                            chart.setTitle(!i && o, i && o);\n                        };\n\n\n                        // Presentational\n                        chart[name].css(chartTitleOptions.style);\n\n\n                    }\n                });\n                chart.layOutTitles(redraw);\n            },\n\n            /**\n             * Lay out the chart titles and cache the full offset height for use\n             * in getMargins\n             */\n            layOutTitles: function(redraw) {\n                var titleOffset = 0,\n                    requiresDirtyBox,\n                    renderer = this.renderer,\n                    spacingBox = this.spacingBox;\n\n                // Lay out the title and the subtitle respectively\n                each(['title', 'subtitle'], function(key) {\n                    var title = this[key],\n                        titleOptions = this.options[key],\n                        offset = key === 'title' ? -3 :\n                        // Floating subtitle (#6574)\n                        titleOptions.verticalAlign ? 0 : titleOffset + 2,\n                        titleSize;\n\n                    if (title) {\n\n                        titleSize = titleOptions.style.fontSize;\n\n                        titleSize = renderer.fontMetrics(titleSize, title).b;\n\n                        title\n                            .css({\n                                width: (titleOptions.width ||\n                                    spacingBox.width + titleOptions.widthAdjust) + 'px'\n                            })\n                            .align(extend({\n                                y: offset + titleSize\n                            }, titleOptions), false, 'spacingBox');\n\n                        if (!titleOptions.floating && !titleOptions.verticalAlign) {\n                            titleOffset = Math.ceil(\n                                titleOffset +\n                                // Skip the cache for HTML (#3481)\n                                title.getBBox(titleOptions.useHTML).height\n                            );\n                        }\n                    }\n                }, this);\n\n                requiresDirtyBox = this.titleOffset !== titleOffset;\n                this.titleOffset = titleOffset; // used in getMargins\n\n                if (!this.isDirtyBox && requiresDirtyBox) {\n                    this.isDirtyBox = requiresDirtyBox;\n                    // Redraw if necessary (#2719, #2744)\n                    if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {\n                        this.redraw();\n                    }\n                }\n            },\n\n            /**\n             * Get chart width and height according to options and container size\n             */\n            getChartSize: function() {\n                var chart = this,\n                    optionsChart = chart.options.chart,\n                    widthOption = optionsChart.width,\n                    heightOption = optionsChart.height,\n                    renderTo = chart.renderTo;\n\n                // Get inner width and height\n                if (!defined(widthOption)) {\n                    chart.containerWidth = getStyle(renderTo, 'width');\n                }\n                if (!defined(heightOption)) {\n                    chart.containerHeight = getStyle(renderTo, 'height');\n                }\n\n                chart.chartWidth = Math.max( // #1393\n                    0,\n                    widthOption || chart.containerWidth || 600 // #1460\n                );\n                chart.chartHeight = Math.max(\n                    0,\n                    H.relativeLength(\n                        heightOption,\n                        chart.chartWidth\n                    ) || chart.containerHeight || 400\n                );\n            },\n\n            /**\n             * If the renderTo element has no offsetWidth, most likely one or more of\n             * its parents are hidden. Loop up the DOM tree to temporarily display the\n             * parents, then save the original display properties, and when the true\n             * size is retrieved, reset them. Used on first render and on redraws.\n             *\n             * @param {Boolean} revert - Revert to the saved original styles.\n             */\n            temporaryDisplay: function(revert) {\n                var node = this.renderTo,\n                    tempStyle;\n                if (!revert) {\n                    while (node && node.style) {\n                        if (getStyle(node, 'display', false) === 'none') {\n                            node.hcOrigStyle = {\n                                display: node.style.display,\n                                height: node.style.height,\n                                overflow: node.style.overflow\n                            };\n                            tempStyle = {\n                                display: 'block',\n                                overflow: 'hidden'\n                            };\n                            if (node !== this.renderTo) {\n                                tempStyle.height = 0;\n                            }\n\n                            H.css(node, tempStyle);\n                            if (node.style.setProperty) { // #2631\n                                node.style.setProperty('display', 'block', 'important');\n                            }\n                        }\n                        node = node.parentNode;\n                    }\n                } else {\n                    while (node && node.style) {\n                        if (node.hcOrigStyle) {\n                            H.css(node, node.hcOrigStyle);\n                            delete node.hcOrigStyle;\n                        }\n                        node = node.parentNode;\n                    }\n                }\n            },\n\n            /**\n             * Setter for the chart class name\n             */\n            setClassName: function(className) {\n                this.container.className = 'highcharts-container ' + (className || '');\n            },\n\n            /**\n             * Get the containing element, determine the size and create the inner\n             * container div to hold the chart\n             */\n            getContainer: function() {\n                var chart = this,\n                    container,\n                    options = chart.options,\n                    optionsChart = options.chart,\n                    chartWidth,\n                    chartHeight,\n                    renderTo = chart.renderTo,\n                    indexAttrName = 'data-highcharts-chart',\n                    oldChartIndex,\n                    Ren,\n                    containerId = H.uniqueKey(),\n                    containerStyle,\n                    key;\n\n                if (!renderTo) {\n                    chart.renderTo = renderTo = optionsChart.renderTo;\n                }\n\n                if (isString(renderTo)) {\n                    chart.renderTo = renderTo = doc.getElementById(renderTo);\n                }\n\n                // Display an error if the renderTo is wrong\n                if (!renderTo) {\n                    H.error(13, true);\n                }\n\n                // If the container already holds a chart, destroy it. The check for\n                // hasRendered is there because web pages that are saved to disk from\n                // the browser, will preserve the data-highcharts-chart attribute and\n                // the SVG contents, but not an interactive chart. So in this case,\n                // charts[oldChartIndex] will point to the wrong chart if any (#2609).\n                oldChartIndex = pInt(attr(renderTo, indexAttrName));\n                if (\n                    isNumber(oldChartIndex) &&\n                    charts[oldChartIndex] &&\n                    charts[oldChartIndex].hasRendered\n                ) {\n                    charts[oldChartIndex].destroy();\n                }\n\n                // Make a reference to the chart from the div\n                attr(renderTo, indexAttrName, chart.index);\n\n                // remove previous chart\n                renderTo.innerHTML = '';\n\n                // If the container doesn't have an offsetWidth, it has or is a child of\n                // a node that has display:none. We need to temporarily move it out to a\n                // visible state to determine the size, else the legend and tooltips\n                // won't render properly. The skipClone option is used in sparklines as\n                // a micro optimization, saving about 1-2 ms each chart.\n                if (!optionsChart.skipClone && !renderTo.offsetWidth) {\n                    chart.temporaryDisplay();\n                }\n\n                // get the width and height\n                chart.getChartSize();\n                chartWidth = chart.chartWidth;\n                chartHeight = chart.chartHeight;\n\n                // Create the inner container\n\n                containerStyle = extend({\n                    position: 'relative',\n                    overflow: 'hidden', // needed for context menu (avoid scrollbars)\n                    // and content overflow in IE\n                    width: chartWidth + 'px',\n                    height: chartHeight + 'px',\n                    textAlign: 'left',\n                    lineHeight: 'normal', // #427\n                    zIndex: 0, // #1072\n                    '-webkit-tap-highlight-color': 'rgba(0,0,0,0)'\n                }, optionsChart.style);\n\n\n                /**\n                 * The containing HTML element of the chart. The container is\n                 * dynamically inserted into the element given as the `renderTo`\n                 * parameterin the {@link Highcharts#chart} constructor.\n                 *\n                 * @memberOf Highcharts.Chart\n                 * @type {HTMLDOMElement}\n                 */\n                container = createElement(\n                    'div', {\n                        id: containerId\n                    },\n                    containerStyle,\n                    renderTo\n                );\n                chart.container = container;\n\n                // cache the cursor (#1650)\n                chart._cursor = container.style.cursor;\n\n                // Initialize the renderer\n                Ren = H[optionsChart.renderer] || Renderer;\n                chart.renderer = new Ren(\n                    container,\n                    chartWidth,\n                    chartHeight,\n                    null,\n                    optionsChart.forExport,\n                    options.exporting && options.exporting.allowHTML\n                );\n\n\n                chart.setClassName(optionsChart.className);\n\n                chart.renderer.setStyle(optionsChart.style);\n\n\n                // Add a reference to the charts index\n                chart.renderer.chartIndex = chart.index;\n            },\n\n            /**\n             * Calculate margins by rendering axis labels in a preliminary position.\n             * Title, subtitle and legend have already been rendered at this stage, but\n             * will be moved into their final positions\n             */\n            getMargins: function(skipAxes) {\n                var chart = this,\n                    spacing = chart.spacing,\n                    margin = chart.margin,\n                    titleOffset = chart.titleOffset;\n\n                chart.resetMargins();\n\n                // Adjust for title and subtitle\n                if (titleOffset && !defined(margin[0])) {\n                    chart.plotTop = Math.max(\n                        chart.plotTop,\n                        titleOffset + chart.options.title.margin + spacing[0]\n                    );\n                }\n\n                // Adjust for legend\n                if (chart.legend.display) {\n                    chart.legend.adjustMargins(margin, spacing);\n                }\n\n                // adjust for scroller\n                if (chart.extraMargin) {\n                    chart[chart.extraMargin.type] =\n                        (chart[chart.extraMargin.type] || 0) + chart.extraMargin.value;\n                }\n                if (chart.extraTopMargin) {\n                    chart.plotTop += chart.extraTopMargin;\n                }\n                if (!skipAxes) {\n                    this.getAxisMargins();\n                }\n            },\n\n            getAxisMargins: function() {\n\n                var chart = this,\n                    // [top, right, bottom, left]\n                    axisOffset = chart.axisOffset = [0, 0, 0, 0],\n                    margin = chart.margin;\n\n                // pre-render axes to get labels offset width\n                if (chart.hasCartesianSeries) {\n                    each(chart.axes, function(axis) {\n                        if (axis.visible) {\n                            axis.getOffset();\n                        }\n                    });\n                }\n\n                // Add the axis offsets\n                each(marginNames, function(m, side) {\n                    if (!defined(margin[side])) {\n                        chart[m] += axisOffset[side];\n                    }\n                });\n\n                chart.setChartSize();\n\n            },\n\n            /**\n             * Reflows the chart to its container. By default, the chart reflows\n             * automatically to its container following a `window.resize` event, as per\n             * the {@link https://api.highcharts/highcharts/chart.reflow|chart.reflow}\n             * option. However, there are no reliable events for div resize, so if the\n             * container is resized without a window resize event, this must be called\n             * explicitly.\n             *\n             * @param  {Object} e\n             *         Event arguments. Used primarily when the function is called\n             *         internally as a response to window resize.\n             *\n             * @sample highcharts/members/chart-reflow/\n             *         Resize div and reflow\n             * @sample highcharts/chart/events-container/\n             *         Pop up and reflow\n             */\n            reflow: function(e) {\n                var chart = this,\n                    optionsChart = chart.options.chart,\n                    renderTo = chart.renderTo,\n                    hasUserWidth = defined(optionsChart.width),\n                    width = optionsChart.width || getStyle(renderTo, 'width'),\n                    height = optionsChart.height || getStyle(renderTo, 'height'),\n                    target = e ? e.target : win;\n\n                // Width and height checks for display:none. Target is doc in IE8 and\n                // Opera, win in Firefox, Chrome and IE9.\n                if (!hasUserWidth &&\n                    !chart.isPrinting &&\n                    width &&\n                    height &&\n                    (target === win || target === doc)\n                ) {\n                    if (\n                        width !== chart.containerWidth ||\n                        height !== chart.containerHeight\n                    ) {\n                        clearTimeout(chart.reflowTimeout);\n                        // When called from window.resize, e is set, else it's called\n                        // directly (#2224)\n                        chart.reflowTimeout = syncTimeout(function() {\n                            // Set size, it may have been destroyed in the meantime\n                            // (#1257)\n                            if (chart.container) {\n                                chart.setSize(undefined, undefined, false);\n                            }\n                        }, e ? 100 : 0);\n                    }\n                    chart.containerWidth = width;\n                    chart.containerHeight = height;\n                }\n            },\n\n            /**\n             * Add the event handlers necessary for auto resizing\n             */\n            initReflow: function() {\n                var chart = this,\n                    unbind;\n\n                unbind = addEvent(win, 'resize', function(e) {\n                    chart.reflow(e);\n                });\n                addEvent(chart, 'destroy', unbind);\n\n                // The following will add listeners to re-fit the chart before and after\n                // printing (#2284). However it only works in WebKit. Should have worked\n                // in Firefox, but not supported in IE.\n                /*\n                if (win.matchMedia) {\n                \twin.matchMedia('print').addListener(function reflow() {\n                \t\tchart.reflow();\n                \t});\n                }\n                */\n            },\n\n            /**\n             * Resize the chart to a given width and height. In order to set the width\n             * only, the height argument may be skipped. To set the height only, pass\n             * `undefined for the width.\n             * @param  {Number|undefined|null} [width]\n             *         The new pixel width of the chart. Since v4.2.6, the argument can\n             *         be `undefined` in order to preserve the current value (when\n             *         setting height only), or `null` to adapt to the width of the\n             *         containing element.\n             * @param  {Number|undefined|null} [height]\n             *         The new pixel height of the chart. Since v4.2.6, the argument can\n             *         be `undefined` in order to preserve the current value, or `null`\n             *         in order to adapt to the height of the containing element.\n             * @param  {AnimationOptions} [animation=true]\n             *         Whether and how to apply animation.\n             *\n             * @sample highcharts/members/chart-setsize-button/\n             *         Test resizing from buttons\n             * @sample highcharts/members/chart-setsize-jquery-resizable/\n             *         Add a jQuery UI resizable\n             * @sample stock/members/chart-setsize/\n             *         Highstock with UI resizable\n             */\n            setSize: function(width, height, animation) {\n                var chart = this,\n                    renderer = chart.renderer,\n                    globalAnimation;\n\n                // Handle the isResizing counter\n                chart.isResizing += 1;\n\n                // set the animation for the current process\n                H.setAnimation(animation, chart);\n\n                chart.oldChartHeight = chart.chartHeight;\n                chart.oldChartWidth = chart.chartWidth;\n                if (width !== undefined) {\n                    chart.options.chart.width = width;\n                }\n                if (height !== undefined) {\n                    chart.options.chart.height = height;\n                }\n                chart.getChartSize();\n\n                // Resize the container with the global animation applied if enabled\n                // (#2503)\n\n                globalAnimation = renderer.globalAnimation;\n                (globalAnimation ? animate : css)(chart.container, {\n                    width: chart.chartWidth + 'px',\n                    height: chart.chartHeight + 'px'\n                }, globalAnimation);\n\n\n                chart.setChartSize(true);\n                renderer.setSize(chart.chartWidth, chart.chartHeight, animation);\n\n                // handle axes\n                each(chart.axes, function(axis) {\n                    axis.isDirty = true;\n                    axis.setScale();\n                });\n\n                chart.isDirtyLegend = true; // force legend redraw\n                chart.isDirtyBox = true; // force redraw of plot and chart border\n\n                chart.layOutTitles(); // #2857\n                chart.getMargins();\n\n                chart.redraw(animation);\n\n\n                chart.oldChartHeight = null;\n                fireEvent(chart, 'resize');\n\n                // Fire endResize and set isResizing back. If animation is disabled,\n                // fire without delay\n                syncTimeout(function() {\n                    if (chart) {\n                        fireEvent(chart, 'endResize', null, function() {\n                            chart.isResizing -= 1;\n                        });\n                    }\n                }, animObject(globalAnimation).duration);\n            },\n\n            /**\n             * Set the public chart properties. This is done before and after the\n             * pre-render to determine margin sizes\n             */\n            setChartSize: function(skipAxes) {\n                var chart = this,\n                    inverted = chart.inverted,\n                    renderer = chart.renderer,\n                    chartWidth = chart.chartWidth,\n                    chartHeight = chart.chartHeight,\n                    optionsChart = chart.options.chart,\n                    spacing = chart.spacing,\n                    clipOffset = chart.clipOffset,\n                    clipX,\n                    clipY,\n                    plotLeft,\n                    plotTop,\n                    plotWidth,\n                    plotHeight,\n                    plotBorderWidth;\n\n                function clipOffsetSide(side) {\n                    var offset = clipOffset[side] || 0;\n                    return Math.max(plotBorderWidth || offset, offset) / 2;\n                }\n\n                chart.plotLeft = plotLeft = Math.round(chart.plotLeft);\n                chart.plotTop = plotTop = Math.round(chart.plotTop);\n                chart.plotWidth = plotWidth = Math.max(\n                    0,\n                    Math.round(chartWidth - plotLeft - chart.marginRight)\n                );\n                chart.plotHeight = plotHeight = Math.max(\n                    0,\n                    Math.round(chartHeight - plotTop - chart.marginBottom)\n                );\n\n                chart.plotSizeX = inverted ? plotHeight : plotWidth;\n                chart.plotSizeY = inverted ? plotWidth : plotHeight;\n\n                chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;\n\n                // Set boxes used for alignment\n                chart.spacingBox = renderer.spacingBox = {\n                    x: spacing[3],\n                    y: spacing[0],\n                    width: chartWidth - spacing[3] - spacing[1],\n                    height: chartHeight - spacing[0] - spacing[2]\n                };\n                chart.plotBox = renderer.plotBox = {\n                    x: plotLeft,\n                    y: plotTop,\n                    width: plotWidth,\n                    height: plotHeight\n                };\n\n                plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2);\n                clipX = Math.ceil(clipOffsetSide(3));\n                clipY = Math.ceil(clipOffsetSide(0));\n                chart.clipBox = {\n                    x: clipX,\n                    y: clipY,\n                    width: Math.floor(\n                        chart.plotSizeX -\n                        clipOffsetSide(1) -\n                        clipX\n                    ),\n                    height: Math.max(\n                        0,\n                        Math.floor(\n                            chart.plotSizeY -\n                            clipOffsetSide(2) -\n                            clipY\n                        )\n                    )\n                };\n\n                if (!skipAxes) {\n                    each(chart.axes, function(axis) {\n                        axis.setAxisSize();\n                        axis.setAxisTranslation();\n                    });\n                }\n            },\n\n            /**\n             * Initial margins before auto size margins are applied\n             */\n            resetMargins: function() {\n                var chart = this,\n                    chartOptions = chart.options.chart;\n\n                // Create margin and spacing array\n                each(['margin', 'spacing'], function splashArrays(target) {\n                    var value = chartOptions[target],\n                        values = isObject(value) ? value : [value, value, value, value];\n\n                    each(['Top', 'Right', 'Bottom', 'Left'], function(sideName, side) {\n                        chart[target][side] = pick(\n                            chartOptions[target + sideName],\n                            values[side]\n                        );\n                    });\n                });\n\n                // Set margin names like chart.plotTop, chart.plotLeft,\n                // chart.marginRight, chart.marginBottom.\n                each(marginNames, function(m, side) {\n                    chart[m] = pick(chart.margin[side], chart.spacing[side]);\n                });\n                chart.axisOffset = [0, 0, 0, 0]; // top, right, bottom, left\n                chart.clipOffset = [];\n            },\n\n            /**\n             * Draw the borders and backgrounds for chart and plot area\n             */\n            drawChartBox: function() {\n                var chart = this,\n                    optionsChart = chart.options.chart,\n                    renderer = chart.renderer,\n                    chartWidth = chart.chartWidth,\n                    chartHeight = chart.chartHeight,\n                    chartBackground = chart.chartBackground,\n                    plotBackground = chart.plotBackground,\n                    plotBorder = chart.plotBorder,\n                    chartBorderWidth,\n\n                    plotBGImage = chart.plotBGImage,\n                    chartBackgroundColor = optionsChart.backgroundColor,\n                    plotBackgroundColor = optionsChart.plotBackgroundColor,\n                    plotBackgroundImage = optionsChart.plotBackgroundImage,\n\n                    mgn,\n                    bgAttr,\n                    plotLeft = chart.plotLeft,\n                    plotTop = chart.plotTop,\n                    plotWidth = chart.plotWidth,\n                    plotHeight = chart.plotHeight,\n                    plotBox = chart.plotBox,\n                    clipRect = chart.clipRect,\n                    clipBox = chart.clipBox,\n                    verb = 'animate';\n\n                // Chart area\n                if (!chartBackground) {\n                    chart.chartBackground = chartBackground = renderer.rect()\n                        .addClass('highcharts-background')\n                        .add();\n                    verb = 'attr';\n                }\n\n\n                // Presentational\n                chartBorderWidth = optionsChart.borderWidth || 0;\n                mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);\n\n                bgAttr = {\n                    fill: chartBackgroundColor || 'none'\n                };\n\n                if (chartBorderWidth || chartBackground['stroke-width']) { // #980\n                    bgAttr.stroke = optionsChart.borderColor;\n                    bgAttr['stroke-width'] = chartBorderWidth;\n                }\n                chartBackground\n                    .attr(bgAttr)\n                    .shadow(optionsChart.shadow);\n\n                chartBackground[verb]({\n                    x: mgn / 2,\n                    y: mgn / 2,\n                    width: chartWidth - mgn - chartBorderWidth % 2,\n                    height: chartHeight - mgn - chartBorderWidth % 2,\n                    r: optionsChart.borderRadius\n                });\n\n                // Plot background\n                verb = 'animate';\n                if (!plotBackground) {\n                    verb = 'attr';\n                    chart.plotBackground = plotBackground = renderer.rect()\n                        .addClass('highcharts-plot-background')\n                        .add();\n                }\n                plotBackground[verb](plotBox);\n\n\n                // Presentational attributes for the background\n                plotBackground\n                    .attr({\n                        fill: plotBackgroundColor || 'none'\n                    })\n                    .shadow(optionsChart.plotShadow);\n\n                // Create the background image\n                if (plotBackgroundImage) {\n                    if (!plotBGImage) {\n                        chart.plotBGImage = renderer.image(\n                            plotBackgroundImage,\n                            plotLeft,\n                            plotTop,\n                            plotWidth,\n                            plotHeight\n                        ).add();\n                    } else {\n                        plotBGImage.animate(plotBox);\n                    }\n                }\n\n\n                // Plot clip\n                if (!clipRect) {\n                    chart.clipRect = renderer.clipRect(clipBox);\n                } else {\n                    clipRect.animate({\n                        width: clipBox.width,\n                        height: clipBox.height\n                    });\n                }\n\n                // Plot area border\n                verb = 'animate';\n                if (!plotBorder) {\n                    verb = 'attr';\n                    chart.plotBorder = plotBorder = renderer.rect()\n                        .addClass('highcharts-plot-border')\n                        .attr({\n                            zIndex: 1 // Above the grid\n                        })\n                        .add();\n                }\n\n\n                // Presentational\n                plotBorder.attr({\n                    stroke: optionsChart.plotBorderColor,\n                    'stroke-width': optionsChart.plotBorderWidth || 0,\n                    fill: 'none'\n                });\n\n\n                plotBorder[verb](plotBorder.crisp({\n                    x: plotLeft,\n                    y: plotTop,\n                    width: plotWidth,\n                    height: plotHeight\n                }, -plotBorder.strokeWidth())); //#3282 plotBorder should be negative;\n\n                // reset\n                chart.isDirtyBox = false;\n            },\n\n            /**\n             * Detect whether a certain chart property is needed based on inspecting its\n             * options and series. This mainly applies to the chart.inverted property,\n             * and in extensions to the chart.angular and chart.polar properties.\n             */\n            propFromSeries: function() {\n                var chart = this,\n                    optionsChart = chart.options.chart,\n                    klass,\n                    seriesOptions = chart.options.series,\n                    i,\n                    value;\n\n\n                each(['inverted', 'angular', 'polar'], function(key) {\n\n                    // The default series type's class\n                    klass = seriesTypes[optionsChart.type ||\n                        optionsChart.defaultSeriesType];\n\n                    // Get the value from available chart-wide properties\n                    value =\n                        optionsChart[key] || // It is set in the options\n                        (klass && klass.prototype[key]); // The default series class\n                    // requires it\n\n                    // 4. Check if any the chart's series require it\n                    i = seriesOptions && seriesOptions.length;\n                    while (!value && i--) {\n                        klass = seriesTypes[seriesOptions[i].type];\n                        if (klass && klass.prototype[key]) {\n                            value = true;\n                        }\n                    }\n\n                    // Set the chart property\n                    chart[key] = value;\n                });\n\n            },\n\n            /**\n             * Link two or more series together. This is done initially from\n             * Chart.render, and after Chart.addSeries and Series.remove.\n             */\n            linkSeries: function() {\n                var chart = this,\n                    chartSeries = chart.series;\n\n                // Reset links\n                each(chartSeries, function(series) {\n                    series.linkedSeries.length = 0;\n                });\n\n                // Apply new links\n                each(chartSeries, function(series) {\n                    var linkedTo = series.options.linkedTo;\n                    if (isString(linkedTo)) {\n                        if (linkedTo === ':previous') {\n                            linkedTo = chart.series[series.index - 1];\n                        } else {\n                            linkedTo = chart.get(linkedTo);\n                        }\n                        // #3341 avoid mutual linking\n                        if (linkedTo && linkedTo.linkedParent !== series) {\n                            linkedTo.linkedSeries.push(series);\n                            series.linkedParent = linkedTo;\n                            series.visible = pick(\n                                series.options.visible,\n                                linkedTo.options.visible,\n                                series.visible\n                            ); // #3879\n                        }\n                    }\n                });\n            },\n\n            /**\n             * Render series for the chart\n             */\n            renderSeries: function() {\n                each(this.series, function(serie) {\n                    serie.translate();\n                    serie.render();\n                });\n            },\n\n            /**\n             * Render labels for the chart\n             */\n            renderLabels: function() {\n                var chart = this,\n                    labels = chart.options.labels;\n                if (labels.items) {\n                    each(labels.items, function(label) {\n                        var style = extend(labels.style, label.style),\n                            x = pInt(style.left) + chart.plotLeft,\n                            y = pInt(style.top) + chart.plotTop + 12;\n\n                        // delete to prevent rewriting in IE\n                        delete style.left;\n                        delete style.top;\n\n                        chart.renderer.text(\n                                label.html,\n                                x,\n                                y\n                            )\n                            .attr({\n                                zIndex: 2\n                            })\n                            .css(style)\n                            .add();\n\n                    });\n                }\n            },\n\n            /**\n             * Render all graphics for the chart\n             */\n            render: function() {\n                var chart = this,\n                    axes = chart.axes,\n                    renderer = chart.renderer,\n                    options = chart.options,\n                    tempWidth,\n                    tempHeight,\n                    redoHorizontal,\n                    redoVertical;\n\n                // Title\n                chart.setTitle();\n\n\n                // Legend\n                chart.legend = new Legend(chart, options.legend);\n\n                // Get stacks\n                if (chart.getStacks) {\n                    chart.getStacks();\n                }\n\n                // Get chart margins\n                chart.getMargins(true);\n                chart.setChartSize();\n\n                // Record preliminary dimensions for later comparison\n                tempWidth = chart.plotWidth;\n                tempHeight = chart.plotHeight = chart.plotHeight - 21; // 21 is the most common correction for X axis labels\n\n                // Get margins by pre-rendering axes\n                each(axes, function(axis) {\n                    axis.setScale();\n                });\n                chart.getAxisMargins();\n\n                // If the plot area size has changed significantly, calculate tick positions again\n                redoHorizontal = tempWidth / chart.plotWidth > 1.1;\n                redoVertical = tempHeight / chart.plotHeight > 1.05; // Height is more sensitive\n\n                if (redoHorizontal || redoVertical) {\n\n                    each(axes, function(axis) {\n                        if ((axis.horiz && redoHorizontal) || (!axis.horiz && redoVertical)) {\n                            axis.setTickInterval(true); // update to reflect the new margins\n                        }\n                    });\n                    chart.getMargins(); // second pass to check for new labels\n                }\n\n                // Draw the borders and backgrounds\n                chart.drawChartBox();\n\n\n                // Axes\n                if (chart.hasCartesianSeries) {\n                    each(axes, function(axis) {\n                        if (axis.visible) {\n                            axis.render();\n                        }\n                    });\n                }\n\n                // The series\n                if (!chart.seriesGroup) {\n                    chart.seriesGroup = renderer.g('series-group')\n                        .attr({\n                            zIndex: 3\n                        })\n                        .add();\n                }\n                chart.renderSeries();\n\n                // Labels\n                chart.renderLabels();\n\n                // Credits\n                chart.addCredits();\n\n                // Handle responsiveness\n                if (chart.setResponsive) {\n                    chart.setResponsive();\n                }\n\n                // Set flag\n                chart.hasRendered = true;\n\n            },\n\n            /**\n             * Set a new credits label for the chart.\n             *\n             * @param  {CreditOptions} options\n             *         A configuration object for the new credits.\n             * @sample highcharts/credits/credits-update/ Add and update credits\n             */\n            addCredits: function(credits) {\n                var chart = this;\n\n                credits = merge(true, this.options.credits, credits);\n                if (credits.enabled && !this.credits) {\n\n                    /**\n                     * The chart's credits label. The label has an `update` method that\n                     * allows setting new options as per the {@link\n                     * https://api.highcharts.com/highcharts/credits|\n                     * credits options set}.\n                     *\n                     * @memberof Highcharts.Chart\n                     * @name credits\n                     * @type {Highcharts.SVGElement}\n                     */\n                    this.credits = this.renderer.text(\n                            credits.text + (this.mapCredits || ''),\n                            0,\n                            0\n                        )\n                        .addClass('highcharts-credits')\n                        .on('click', function() {\n                            if (credits.href) {\n                                win.location.href = credits.href;\n                            }\n                        })\n                        .attr({\n                            align: credits.position.align,\n                            zIndex: 8\n                        })\n\n                        .css(credits.style)\n\n                        .add()\n                        .align(credits.position);\n\n                    // Dynamically update\n                    this.credits.update = function(options) {\n                        chart.credits = chart.credits.destroy();\n                        chart.addCredits(options);\n                    };\n                }\n            },\n\n            /**\n             * Remove the chart and purge memory. This method is called internally\n             * before adding a second chart into the same container, as well as on\n             * window unload to prevent leaks.\n             *\n             * @sample highcharts/members/chart-destroy/\n             *         Destroy the chart from a button\n             * @sample stock/members/chart-destroy/\n             *         Destroy with Highstock\n             */\n            destroy: function() {\n                var chart = this,\n                    axes = chart.axes,\n                    series = chart.series,\n                    container = chart.container,\n                    i,\n                    parentNode = container && container.parentNode;\n\n                // fire the chart.destoy event\n                fireEvent(chart, 'destroy');\n\n                // Delete the chart from charts lookup array\n                if (chart.renderer.forExport) {\n                    H.erase(charts, chart); // #6569\n                } else {\n                    charts[chart.index] = undefined;\n                }\n                H.chartCount--;\n                chart.renderTo.removeAttribute('data-highcharts-chart');\n\n                // remove events\n                removeEvent(chart);\n\n                // ==== Destroy collections:\n                // Destroy axes\n                i = axes.length;\n                while (i--) {\n                    axes[i] = axes[i].destroy();\n                }\n\n                // Destroy scroller & scroller series before destroying base series\n                if (this.scroller && this.scroller.destroy) {\n                    this.scroller.destroy();\n                }\n\n                // Destroy each series\n                i = series.length;\n                while (i--) {\n                    series[i] = series[i].destroy();\n                }\n\n                // ==== Destroy chart properties:\n                each([\n                    'title', 'subtitle', 'chartBackground', 'plotBackground',\n                    'plotBGImage', 'plotBorder', 'seriesGroup', 'clipRect', 'credits',\n                    'pointer', 'rangeSelector', 'legend', 'resetZoomButton', 'tooltip',\n                    'renderer'\n                ], function(name) {\n                    var prop = chart[name];\n\n                    if (prop && prop.destroy) {\n                        chart[name] = prop.destroy();\n                    }\n                });\n\n                // remove container and all SVG\n                if (container) { // can break in IE when destroyed before finished loading\n                    container.innerHTML = '';\n                    removeEvent(container);\n                    if (parentNode) {\n                        discardElement(container);\n                    }\n\n                }\n\n                // clean it all up\n                objectEach(chart, function(val, key) {\n                    delete chart[key];\n                });\n\n            },\n\n\n            /**\n             * VML namespaces can't be added until after complete. Listening\n             * for Perini's doScroll hack is not enough.\n             */\n            isReadyToRender: function() {\n                var chart = this;\n\n                // Note: win == win.top is required\n                if ((!svg && (win == win.top && doc.readyState !== 'complete'))) { // eslint-disable-line eqeqeq\n                    doc.attachEvent('onreadystatechange', function() {\n                        doc.detachEvent('onreadystatechange', chart.firstRender);\n                        if (doc.readyState === 'complete') {\n                            chart.firstRender();\n                        }\n                    });\n                    return false;\n                }\n                return true;\n            },\n\n            /**\n             * Prepare for first rendering after all data are loaded\n             */\n            firstRender: function() {\n                var chart = this,\n                    options = chart.options;\n\n                // Check whether the chart is ready to render\n                if (!chart.isReadyToRender()) {\n                    return;\n                }\n\n                // Create the container\n                chart.getContainer();\n\n                // Run an early event after the container and renderer are established\n                fireEvent(chart, 'init');\n\n\n                chart.resetMargins();\n                chart.setChartSize();\n\n                // Set the common chart properties (mainly invert) from the given series\n                chart.propFromSeries();\n\n                // get axes\n                chart.getAxes();\n\n                // Initialize the series\n                each(options.series || [], function(serieOptions) {\n                    chart.initSeries(serieOptions);\n                });\n\n                chart.linkSeries();\n\n                // Run an event after axes and series are initialized, but before render. At this stage,\n                // the series data is indexed and cached in the xData and yData arrays, so we can access\n                // those before rendering. Used in Highstock.\n                fireEvent(chart, 'beforeRender');\n\n                // depends on inverted and on margins being set\n                if (Pointer) {\n                    chart.pointer = new Pointer(chart, options);\n                }\n\n                chart.render();\n\n                // Fire the load event if there are no external images\n                if (!chart.renderer.imgCount && chart.onload) {\n                    chart.onload();\n                }\n\n                // If the chart was rendered outside the top container, put it back in (#3679)\n                chart.temporaryDisplay(true);\n\n            },\n\n            /** \n             * On chart load\n             */\n            onload: function() {\n\n                // Run callbacks\n                each([this.callback].concat(this.callbacks), function(fn) {\n                    if (fn && this.index !== undefined) { // Chart destroyed in its own callback (#3600)\n                        fn.apply(this, [this]);\n                    }\n                }, this);\n\n                fireEvent(this, 'load');\n                fireEvent(this, 'render');\n\n\n                // Set up auto resize, check for not destroyed (#6068)\n                if (defined(this.index) && this.options.chart.reflow !== false) {\n                    this.initReflow();\n                }\n\n                // Don't run again\n                this.onload = null;\n            }\n\n        }); // end Chart\n\n    }(Highcharts));\n    (function(Highcharts) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var Point,\n            H = Highcharts,\n\n            each = H.each,\n            extend = H.extend,\n            erase = H.erase,\n            fireEvent = H.fireEvent,\n            format = H.format,\n            isArray = H.isArray,\n            isNumber = H.isNumber,\n            pick = H.pick,\n            removeEvent = H.removeEvent;\n\n        /**\n         * The Point object. The point objects are generated from the `series.data` \n         * configuration objects or raw numbers. They can be accessed from the\n         * `Series.points` array. Other ways to instaniate points are through {@link\n         * Highcharts.Series#addPoint} or {@link Highcharts.Series#setData}.\n         *\n         * @class\n         */\n\n        Highcharts.Point = Point = function() {};\n        Highcharts.Point.prototype = {\n\n            /**\n             * Initialize the point. Called internally based on the series.data option.\n             * @param {Object} series The series object containing this point.\n             * @param {Object} options The data in either number, array or object\n             *        format.\n             * @param {Number} x Optionally, the X value of the.\n             * @returns {Object} The Point instance.\n             */\n            init: function(series, options, x) {\n\n                var point = this,\n                    colors,\n                    colorCount = series.chart.options.chart.colorCount,\n                    colorIndex;\n\n                /**\n                 * The series object associated with the point.\n                 *\n                 * @name series\n                 * @memberof Highcharts.Point\n                 * @type Highcharts.Series\n                 */\n                point.series = series;\n\n\n                /**\n                 * The point's current color.\n                 * @name color\n                 * @memberof Highcharts.Point\n                 * @type {Color}\n                 */\n                point.color = series.color; // #3445\n\n                point.applyOptions(options, x);\n\n                if (series.options.colorByPoint) {\n\n                    colors = series.options.colors || series.chart.options.colors;\n                    point.color = point.color || colors[series.colorCounter];\n                    colorCount = colors.length;\n\n                    colorIndex = series.colorCounter;\n                    series.colorCounter++;\n                    // loop back to zero\n                    if (series.colorCounter === colorCount) {\n                        series.colorCounter = 0;\n                    }\n                } else {\n                    colorIndex = series.colorIndex;\n                }\n                point.colorIndex = pick(point.colorIndex, colorIndex);\n\n                series.chart.pointCount++;\n                return point;\n            },\n            /**\n             * Apply the options containing the x and y data and possible some extra\n             * properties. Called on point init or from point.update.\n             *\n             * @param {Object} options The point options as defined in series.data.\n             * @param {Number} x Optionally, the X value.\n             * @returns {Object} The Point instance.\n             */\n            applyOptions: function(options, x) {\n                var point = this,\n                    series = point.series,\n                    pointValKey = series.options.pointValKey || series.pointValKey;\n\n                options = Point.prototype.optionsToObject.call(this, options);\n\n                // copy options directly to point\n                extend(point, options);\n                point.options = point.options ? extend(point.options, options) : options;\n\n                // Since options are copied into the Point instance, some accidental options must be shielded (#5681)\n                if (options.group) {\n                    delete point.group;\n                }\n\n                // For higher dimension series types. For instance, for ranges, point.y is mapped to point.low.\n                if (pointValKey) {\n                    point.y = point[pointValKey];\n                }\n                point.isNull = pick(\n                    point.isValid && !point.isValid(),\n                    point.x === null || !isNumber(point.y, true)\n                ); // #3571, check for NaN\n\n                // The point is initially selected by options (#5777)\n                if (point.selected) {\n                    point.state = 'select';\n                }\n\n                // If no x is set by now, get auto incremented value. All points must have an\n                // x value, however the y value can be null to create a gap in the series\n                if ('name' in point && x === undefined && series.xAxis && series.xAxis.hasNames) {\n                    point.x = series.xAxis.nameToX(point);\n                }\n                if (point.x === undefined && series) {\n                    if (x === undefined) {\n                        point.x = series.autoIncrement(point);\n                    } else {\n                        point.x = x;\n                    }\n                }\n\n                return point;\n            },\n\n            /**\n             * Transform number or array configs into objects\n             */\n            optionsToObject: function(options) {\n                var ret = {},\n                    series = this.series,\n                    keys = series.options.keys,\n                    pointArrayMap = keys || series.pointArrayMap || ['y'],\n                    valueCount = pointArrayMap.length,\n                    firstItemType,\n                    i = 0,\n                    j = 0;\n\n                if (isNumber(options) || options === null) {\n                    ret[pointArrayMap[0]] = options;\n\n                } else if (isArray(options)) {\n                    // with leading x value\n                    if (!keys && options.length > valueCount) {\n                        firstItemType = typeof options[0];\n                        if (firstItemType === 'string') {\n                            ret.name = options[0];\n                        } else if (firstItemType === 'number') {\n                            ret.x = options[0];\n                        }\n                        i++;\n                    }\n                    while (j < valueCount) {\n                        if (!keys || options[i] !== undefined) { // Skip undefined positions for keys\n                            ret[pointArrayMap[j]] = options[i];\n                        }\n                        i++;\n                        j++;\n                    }\n                } else if (typeof options === 'object') {\n                    ret = options;\n\n                    // This is the fastest way to detect if there are individual point dataLabels that need\n                    // to be considered in drawDataLabels. These can only occur in object configs.\n                    if (options.dataLabels) {\n                        series._hasPointLabels = true;\n                    }\n\n                    // Same approach as above for markers\n                    if (options.marker) {\n                        series._hasPointMarkers = true;\n                    }\n                }\n                return ret;\n            },\n\n            /**\n             * Get the CSS class names for individual points\n             * @returns {String} The class name\n             */\n            getClassName: function() {\n                return 'highcharts-point' +\n                    (this.selected ? ' highcharts-point-select' : '') +\n                    (this.negative ? ' highcharts-negative' : '') +\n                    (this.isNull ? ' highcharts-null-point' : '') +\n                    (this.colorIndex !== undefined ? ' highcharts-color-' +\n                        this.colorIndex : '') +\n                    (this.options.className ? ' ' + this.options.className : '') +\n                    (this.zone && this.zone.className ? ' ' +\n                        this.zone.className.replace('highcharts-negative', '') : '');\n            },\n\n            /**\n             * Return the zone that the point belongs to\n             */\n            getZone: function() {\n                var series = this.series,\n                    zones = series.zones,\n                    zoneAxis = series.zoneAxis || 'y',\n                    i = 0,\n                    zone;\n\n                zone = zones[i];\n                while (this[zoneAxis] >= zone.value) {\n                    zone = zones[++i];\n                }\n\n                if (zone && zone.color && !this.options.color) {\n                    this.color = zone.color;\n                }\n\n                return zone;\n            },\n\n            /**\n             * Destroy a point to clear memory. Its reference still stays in series.data.\n             */\n            destroy: function() {\n                var point = this,\n                    series = point.series,\n                    chart = series.chart,\n                    hoverPoints = chart.hoverPoints,\n                    prop;\n\n                chart.pointCount--;\n\n                if (hoverPoints) {\n                    point.setState();\n                    erase(hoverPoints, point);\n                    if (!hoverPoints.length) {\n                        chart.hoverPoints = null;\n                    }\n\n                }\n                if (point === chart.hoverPoint) {\n                    point.onMouseOut();\n                }\n\n                // remove all events\n                if (point.graphic || point.dataLabel) { // removeEvent and destroyElements are performance expensive\n                    removeEvent(point);\n                    point.destroyElements();\n                }\n\n                if (point.legendItem) { // pies have legend items\n                    chart.legend.destroyItem(point);\n                }\n\n                for (prop in point) {\n                    point[prop] = null;\n                }\n\n\n            },\n\n            /**\n             * Destroy SVG elements associated with the point\n             */\n            destroyElements: function() {\n                var point = this,\n                    props = ['graphic', 'dataLabel', 'dataLabelUpper', 'connector', 'shadowGroup'],\n                    prop,\n                    i = 6;\n                while (i--) {\n                    prop = props[i];\n                    if (point[prop]) {\n                        point[prop] = point[prop].destroy();\n                    }\n                }\n            },\n\n            /**\n             * Return the configuration hash needed for the data label and tooltip formatters\n             */\n            getLabelConfig: function() {\n                return {\n                    x: this.category,\n                    y: this.y,\n                    color: this.color,\n                    colorIndex: this.colorIndex,\n                    key: this.name || this.category,\n                    series: this.series,\n                    point: this,\n                    percentage: this.percentage,\n                    total: this.total || this.stackTotal\n                };\n            },\n\n            /**\n             * Extendable method for formatting each point's tooltip line\n             *\n             * @return {String} A string to be concatenated in to the common tooltip text\n             */\n            tooltipFormatter: function(pointFormat) {\n\n                // Insert options for valueDecimals, valuePrefix, and valueSuffix\n                var series = this.series,\n                    seriesTooltipOptions = series.tooltipOptions,\n                    valueDecimals = pick(seriesTooltipOptions.valueDecimals, ''),\n                    valuePrefix = seriesTooltipOptions.valuePrefix || '',\n                    valueSuffix = seriesTooltipOptions.valueSuffix || '';\n\n                // Loop over the point array map and replace unformatted values with sprintf formatting markup\n                each(series.pointArrayMap || ['y'], function(key) {\n                    key = '{point.' + key; // without the closing bracket\n                    if (valuePrefix || valueSuffix) {\n                        pointFormat = pointFormat.replace(key + '}', valuePrefix + key + '}' + valueSuffix);\n                    }\n                    pointFormat = pointFormat.replace(key + '}', key + ':,.' + valueDecimals + 'f}');\n                });\n\n                return format(pointFormat, {\n                    point: this,\n                    series: this.series\n                });\n            },\n\n            /**\n             * Fire an event on the Point object.\n             * @param {String} eventType\n             * @param {Object} eventArgs Additional event arguments\n             * @param {Function} defaultFunction Default event handler\n             */\n            firePointEvent: function(eventType, eventArgs, defaultFunction) {\n                var point = this,\n                    series = this.series,\n                    seriesOptions = series.options;\n\n                // load event handlers on demand to save time on mouseover/out\n                if (seriesOptions.point.events[eventType] || (point.options && point.options.events && point.options.events[eventType])) {\n                    this.importEvents();\n                }\n\n                // add default handler if in selection mode\n                if (eventType === 'click' && seriesOptions.allowPointSelect) {\n                    defaultFunction = function(event) {\n                        // Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera\n                        if (point.select) { // Could be destroyed by prior event handlers (#2911)\n                            point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);\n                        }\n                    };\n                }\n\n                fireEvent(this, eventType, eventArgs, defaultFunction);\n            },\n\n            /**\n             * For certain series types, like pie charts, where individual points can\n             * be shown or hidden. \n             *\n             * @name visible\n             * @memberOf Highcharts.Point\n             * @type {Boolean}\n             */\n            visible: true\n        };\n\n        /**\n         * For categorized axes this property holds the category name for the \n         * point. For other axes it holds the X value.\n         *\n         * @name category\n         * @memberOf Highcharts.Point\n         * @type {String|Number}\n         */\n\n        /**\n         * The percentage for points in a stacked series or pies.\n         *\n         * @name percentage\n         * @memberOf Highcharts.Point\n         * @type {Number}\n         */\n\n        /**\n         * The total of values in either a stack for stacked series, or a pie in a pie\n         * series.\n         *\n         * @name total\n         * @memberOf Highcharts.Point\n         * @type {Number}\n         */\n\n        /**\n         * The x value of the point.\n         *\n         * @name x\n         * @memberOf Highcharts.Point\n         * @type {Number}\n         */\n\n        /**\n         * The y value of the point.\n         *\n         * @name y\n         * @memberOf Highcharts.Point\n         * @type {Number}\n         */\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            animObject = H.animObject,\n            arrayMax = H.arrayMax,\n            arrayMin = H.arrayMin,\n            correctFloat = H.correctFloat,\n            Date = H.Date,\n            defaultOptions = H.defaultOptions,\n            defaultPlotOptions = H.defaultPlotOptions,\n            defined = H.defined,\n            each = H.each,\n            erase = H.erase,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            grep = H.grep,\n            isArray = H.isArray,\n            isNumber = H.isNumber,\n            isString = H.isString,\n            LegendSymbolMixin = H.LegendSymbolMixin, // @todo add as a requirement\n            merge = H.merge,\n            objectEach = H.objectEach,\n            pick = H.pick,\n            Point = H.Point, // @todo  add as a requirement\n            removeEvent = H.removeEvent,\n            splat = H.splat,\n            SVGElement = H.SVGElement,\n            syncTimeout = H.syncTimeout,\n            win = H.win;\n\n        /**\n         * This is the base series prototype that all other series types inherit from.\n         * A new series is initiated either through the {@link https://api.highcharts.com/highcharts/series|\n         * series} option structure, or after the chart is initiated, through {@link\n         * Highcharts.Chart#addSeries}.\n         *\n         * The object can be accessed in a number of ways. All series and point event\n         * handlers give a reference to the `series` object. The chart object has a\n         * {@link Highcharts.Chart.series|series} property that is a collection of all\n         * the chart's series. The point objects and axis objects also have the same\n         * reference.\n         * \n         * Another way to reference the series programmatically is by `id`. Add an id\n         * in the series configuration options, and get the series object by {@link\n         * Highcharts.Chart#get}.\n         *\n         * Configuration options for the series are given in three levels. Options for\n         * all series in a chart are given in the {@link https://api.highcharts.com/highcharts/plotOptions.series|\n         * plotOptions.series} object. Then options for all series of a specific type\n         * are given in the plotOptions of that type, for example `plotOptions.line`.\n         * Next, options for one single series are given in the series array, or as\n         * arguements to `chart.addSeries`. \n         * \n         * The data in the series is stored in various arrays.\n         *\n         * - First, `series.options.data` contains all the original config options for\n         * each point whether added by options or methods like `series.addPoint`.\n         * - Next, `series.data` contains those values converted to points, but in case\n         * the series data length exceeds the `cropThreshold`, or if the data is grouped,\n         * `series.data` doesn't contain all the points. It only contains the points that\n         * have been created on demand.\n         * - Then there's `series.points` that contains all currently visible point\n         * objects. In case of cropping, the cropped-away points are not part of this\n         * array. The `series.points` array starts at `series.cropStart` compared to\n         * `series.data` and `series.options.data`. If however the series data is grouped,\n         * these can't be correlated one to one.\n         * - `series.xData` and `series.processedXData` contain clean x values, equivalent\n         * to `series.data` and `series.points`.\n         * - `series.yData` and `series.processedYData` contain clean y values, equivalent\n         * to `series.data` and `series.points`.\n         *\n         * @class Highcharts.Series\n         * @param  {Highcharts.Chart} chart\n         *         The chart instance.\n         * @param  {Object} options\n         *         The series options.\n         */\n        H.Series = H.seriesType('line', null, { // base series options\n\n            //cursor: 'default',\n            //dashStyle: null,\n            //linecap: 'round',\n            lineWidth: 2,\n            //shadow: false,\n\n            allowPointSelect: false,\n            showCheckbox: false,\n            animation: {\n                duration: 1000\n            },\n            //clip: true,\n            //connectNulls: false,\n            //enableMouseTracking: true,\n            events: {},\n            //legendIndex: 0,\n            // stacking: null,\n            marker: {\n\n                lineWidth: 0,\n                lineColor: '#ffffff',\n                //fillColor: null,\n\n                //enabled: true,\n                //symbol: null,\n                radius: 4,\n                states: { // states for a single point\n                    hover: {\n                        animation: {\n                            duration: 50\n                        },\n                        enabled: true,\n                        radiusPlus: 2,\n\n                        lineWidthPlus: 1\n\n                    },\n\n                    select: {\n                        fillColor: '#cccccc',\n                        lineColor: '#000000',\n                        lineWidth: 2\n                    }\n\n                }\n            },\n            point: {\n                events: {}\n            },\n            dataLabels: {\n                align: 'center',\n                // defer: true,\n                // enabled: false,\n                formatter: function() {\n                    return this.y === null ? '' : H.numberFormat(this.y, -1);\n                },\n\n                style: {\n                    fontSize: '11px',\n                    fontWeight: 'bold',\n                    color: 'contrast',\n                    textOutline: '1px contrast'\n                },\n                // backgroundColor: undefined,\n                // borderColor: undefined,\n                // borderWidth: undefined,\n                // shadow: false\n\n                verticalAlign: 'bottom', // above singular point\n                x: 0,\n                y: 0,\n                // borderRadius: undefined,\n                padding: 5\n            },\n            // draw points outside the plot area when the number of points is less than\n            // this\n            cropThreshold: 300,\n            pointRange: 0,\n            //pointStart: 0,\n            //pointInterval: 1,\n            //showInLegend: null, // auto = false for linked series\n            softThreshold: true,\n            states: { // states for the entire series\n                hover: {\n                    //enabled: false,\n                    animation: {\n                        duration: 50\n                    },\n                    lineWidthPlus: 1,\n                    marker: {\n                        // lineWidth: base + 1,\n                        // radius: base + 1\n                    },\n                    halo: {\n                        size: 10,\n\n                        opacity: 0.25\n\n                    }\n                },\n                select: {\n                    marker: {}\n                }\n            },\n            stickyTracking: true,\n            //tooltip: {\n            //pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span>' +\n            // '{series.name}: <b>{point.y}</b>'\n            //valueDecimals: null,\n            //xDateFormat: '%A, %b %e, %Y',\n            //valuePrefix: '',\n            //ySuffix: ''\n            //}\n            turboThreshold: 1000,\n            // zIndex: null\n            findNearestPointBy: 'x'\n\n        }, /** @lends Highcharts.Series.prototype */ {\n            isCartesian: true,\n            pointClass: Point,\n            sorted: true, // requires the data to be sorted\n            requireSorting: true,\n            directTouch: false,\n            axisTypes: ['xAxis', 'yAxis'],\n            colorCounter: 0,\n            // each point's x and y values are stored in this.xData and this.yData\n            parallelArrays: ['x', 'y'],\n            coll: 'series',\n            init: function(chart, options) {\n                var series = this,\n                    events,\n                    chartSeries = chart.series,\n                    lastSeries;\n\n                /**\n                 * Read only. The chart that the series belongs to.\n                 *\n                 * @name chart\n                 * @memberOf Series\n                 * @type {Chart}\n                 */\n                series.chart = chart;\n\n                /**\n                 * Read only. The series' type, like \"line\", \"area\", \"column\" etc. The\n                 * type in the series options anc can be altered using {@link\n                 * Series#update}.\n                 *\n                 * @name type\n                 * @memberOf Series\n                 * @type String\n                 */\n\n                /**\n                 * Read only. The series' current options. To update, use {@link\n                 * Series#update}.\n                 *\n                 * @name options\n                 * @memberOf Series\n                 * @type SeriesOptions\n                 */\n                series.options = options = series.setOptions(options);\n                series.linkedSeries = [];\n\n                // bind the axes\n                series.bindAxes();\n\n                // set some variables\n                extend(series, {\n                    /**\n                     * The series name as given in the options. Defaults to\n                     * \"Series {n}\".\n                     *\n                     * @name name\n                     * @memberOf Series\n                     * @type {String}\n                     */\n                    name: options.name,\n                    state: '',\n                    /**\n                     * Read only. The series' visibility state as set by {@link\n                     * Series#show}, {@link Series#hide}, or in the initial\n                     * configuration.\n                     *\n                     * @name visible\n                     * @memberOf Series\n                     * @type {Boolean}\n                     */\n                    visible: options.visible !== false, // true by default\n                    /**\n                     * Read only. The series' selected state as set by {@link\n                     * Highcharts.Series#select}.\n                     * \n                     * @name selected\n                     * @memberOf Series\n                     * @type {Boolean}\n                     */\n                    selected: options.selected === true // false by default\n                });\n\n                // register event listeners\n                events = options.events;\n\n                objectEach(events, function(event, eventType) {\n                    addEvent(series, eventType, event);\n                });\n                if (\n                    (events && events.click) ||\n                    (\n                        options.point &&\n                        options.point.events &&\n                        options.point.events.click\n                    ) ||\n                    options.allowPointSelect\n                ) {\n                    chart.runTrackerClick = true;\n                }\n\n                series.getColor();\n                series.getSymbol();\n\n                // Set the data\n                each(series.parallelArrays, function(key) {\n                    series[key + 'Data'] = [];\n                });\n                series.setData(options.data, false);\n\n                // Mark cartesian\n                if (series.isCartesian) {\n                    chart.hasCartesianSeries = true;\n                }\n\n                // Get the index and register the series in the chart. The index is one\n                // more than the current latest series index (#5960).\n                if (chartSeries.length) {\n                    lastSeries = chartSeries[chartSeries.length - 1];\n                }\n                series._i = pick(lastSeries && lastSeries._i, -1) + 1;\n\n                // Insert the series and re-order all series above the insertion point.\n                chart.orderSeries(this.insert(chartSeries));\n            },\n\n            /**\n             * Insert the series in a collection with other series, either the chart\n             * series or yAxis series, in the correct order according to the index \n             * option.\n             * @param  {Array} collection A collection of series.\n             * @returns {Number} The index of the series in the collection.\n             */\n            insert: function(collection) {\n                var indexOption = this.options.index,\n                    i;\n\n                // Insert by index option\n                if (isNumber(indexOption)) {\n                    i = collection.length;\n                    while (i--) {\n                        // Loop down until the interted element has higher index\n                        if (indexOption >=\n                            pick(collection[i].options.index, collection[i]._i)) {\n                            collection.splice(i + 1, 0, this);\n                            break;\n                        }\n                    }\n                    if (i === -1) {\n                        collection.unshift(this);\n                    }\n                    i = i + 1;\n\n                    // Or just push it to the end\n                } else {\n                    collection.push(this);\n                }\n                return pick(i, collection.length - 1);\n            },\n\n            /**\n             * Set the xAxis and yAxis properties of cartesian series, and register the\n             * series in the `axis.series` array.\n             *\n             * @function #bindAxes\n             * @memberOf Series\n             * @returns {void}\n             */\n            bindAxes: function() {\n                var series = this,\n                    seriesOptions = series.options,\n                    chart = series.chart,\n                    axisOptions;\n\n                // repeat for xAxis and yAxis\n                each(series.axisTypes || [], function(AXIS) {\n\n                    // loop through the chart's axis objects\n                    each(chart[AXIS], function(axis) {\n                        axisOptions = axis.options;\n\n                        // apply if the series xAxis or yAxis option mathches the number\n                        // of the axis, or if undefined, use the first axis\n                        if (\n                            seriesOptions[AXIS] === axisOptions.index ||\n                            (\n                                seriesOptions[AXIS] !== undefined &&\n                                seriesOptions[AXIS] === axisOptions.id\n                            ) ||\n                            (\n                                seriesOptions[AXIS] === undefined &&\n                                axisOptions.index === 0\n                            )\n                        ) {\n\n                            // register this series in the axis.series lookup\n                            series.insert(axis.series);\n\n                            // set this series.xAxis or series.yAxis reference\n                            /**\n                             * Read only. The unique xAxis object associated with the\n                             * series.\n                             *\n                             * @name xAxis\n                             * @memberOf Series\n                             * @type Axis\n                             */\n                            /**\n                             * Read only. The unique yAxis object associated with the\n                             * series.\n                             *\n                             * @name yAxis\n                             * @memberOf Series\n                             * @type Axis\n                             */\n                            series[AXIS] = axis;\n\n                            // mark dirty for redraw\n                            axis.isDirty = true;\n                        }\n                    });\n\n                    // The series needs an X and an Y axis\n                    if (!series[AXIS] && series.optionalAxis !== AXIS) {\n                        H.error(18, true);\n                    }\n\n                });\n            },\n\n            /**\n             * For simple series types like line and column, the data values are held in\n             * arrays like xData and yData for quick lookup to find extremes and more.\n             * For multidimensional series like bubble and map, this can be extended\n             * with arrays like zData and valueData by adding to the\n             * series.parallelArrays array.\n             */\n            updateParallelArrays: function(point, i) {\n                var series = point.series,\n                    args = arguments,\n                    fn = isNumber(i) ?\n                    // Insert the value in the given position\n                    function(key) {\n                        var val = key === 'y' && series.toYData ?\n                            series.toYData(point) :\n                            point[key];\n                        series[key + 'Data'][i] = val;\n                    } :\n                    // Apply the method specified in i with the following arguments\n                    // as arguments\n                    function(key) {\n                        Array.prototype[i].apply(\n                            series[key + 'Data'],\n                            Array.prototype.slice.call(args, 2)\n                        );\n                    };\n\n                each(series.parallelArrays, fn);\n            },\n\n            /**\n             * Return an auto incremented x value based on the pointStart and\n             * pointInterval options. This is only used if an x value is not given for\n             * the point that calls autoIncrement.\n             */\n            autoIncrement: function() {\n\n                var options = this.options,\n                    xIncrement = this.xIncrement,\n                    date,\n                    pointInterval,\n                    pointIntervalUnit = options.pointIntervalUnit;\n\n                xIncrement = pick(xIncrement, options.pointStart, 0);\n\n                this.pointInterval = pointInterval = pick(\n                    this.pointInterval,\n                    options.pointInterval,\n                    1\n                );\n\n                // Added code for pointInterval strings\n                if (pointIntervalUnit) {\n                    date = new Date(xIncrement);\n\n                    if (pointIntervalUnit === 'day') {\n                        date = +date[Date.hcSetDate](\n                            date[Date.hcGetDate]() + pointInterval\n                        );\n                    } else if (pointIntervalUnit === 'month') {\n                        date = +date[Date.hcSetMonth](\n                            date[Date.hcGetMonth]() + pointInterval\n                        );\n                    } else if (pointIntervalUnit === 'year') {\n                        date = +date[Date.hcSetFullYear](\n                            date[Date.hcGetFullYear]() + pointInterval\n                        );\n                    }\n                    pointInterval = date - xIncrement;\n\n                }\n\n                this.xIncrement = xIncrement + pointInterval;\n                return xIncrement;\n            },\n\n            /**\n             * Set the series options by merging from the options tree\n             * @param {Object} itemOptions\n             */\n            setOptions: function(itemOptions) {\n                var chart = this.chart,\n                    chartOptions = chart.options,\n                    plotOptions = chartOptions.plotOptions,\n                    userOptions = chart.userOptions || {},\n                    userPlotOptions = userOptions.plotOptions || {},\n                    typeOptions = plotOptions[this.type],\n                    options,\n                    zones;\n\n                this.userOptions = itemOptions;\n\n                // General series options take precedence over type options because\n                // otherwise, default type options like column.animation would be\n                // overwritten by the general option. But issues have been raised here\n                // (#3881), and the solution may be to distinguish between default\n                // option and userOptions like in the tooltip below.\n                options = merge(\n                    typeOptions,\n                    plotOptions.series,\n                    itemOptions\n                );\n\n                // The tooltip options are merged between global and series specific\n                // options. Importance order asscendingly:\n                // globals: (1)tooltip, (2)plotOptions.series, (3)plotOptions[this.type]\n                // init userOptions with possible later updates: 4-6 like 1-3 and\n                // (7)this series options\n                this.tooltipOptions = merge(\n                    defaultOptions.tooltip, // 1\n                    defaultOptions.plotOptions.series &&\n                    defaultOptions.plotOptions.series.tooltip, // 2\n                    defaultOptions.plotOptions[this.type].tooltip, // 3\n                    chartOptions.tooltip.userOptions, // 4\n                    plotOptions.series && plotOptions.series.tooltip, // 5\n                    plotOptions[this.type].tooltip, // 6\n                    itemOptions.tooltip // 7\n                );\n\n                // When shared tooltip, stickyTracking is true by default,\n                // unless user says otherwise.\n                this.stickyTracking = pick(\n                    itemOptions.stickyTracking,\n                    userPlotOptions[this.type] &&\n                    userPlotOptions[this.type].stickyTracking,\n                    userPlotOptions.series && userPlotOptions.series.stickyTracking,\n                    (\n                        this.tooltipOptions.shared && !this.noSharedTooltip ?\n                        true :\n                        options.stickyTracking\n                    )\n                );\n\n                // Delete marker object if not allowed (#1125)\n                if (typeOptions.marker === null) {\n                    delete options.marker;\n                }\n\n                // Handle color zones\n                this.zoneAxis = options.zoneAxis;\n                zones = this.zones = (options.zones || []).slice();\n                if (\n                    (options.negativeColor || options.negativeFillColor) &&\n                    !options.zones\n                ) {\n                    zones.push({\n                        value: options[this.zoneAxis + 'Threshold'] ||\n                            options.threshold ||\n                            0,\n                        className: 'highcharts-negative',\n\n                        color: options.negativeColor,\n                        fillColor: options.negativeFillColor\n\n                    });\n                }\n                if (zones.length) { // Push one extra zone for the rest\n                    if (defined(zones[zones.length - 1].value)) {\n                        zones.push({\n\n                            color: this.color,\n                            fillColor: this.fillColor\n\n                        });\n                    }\n                }\n                return options;\n            },\n\n            getCyclic: function(prop, value, defaults) {\n                var i,\n                    chart = this.chart,\n                    userOptions = this.userOptions,\n                    indexName = prop + 'Index',\n                    counterName = prop + 'Counter',\n                    len = defaults ? defaults.length : pick(\n                        chart.options.chart[prop + 'Count'],\n                        chart[prop + 'Count']\n                    ),\n                    setting;\n\n                if (!value) {\n                    // Pick up either the colorIndex option, or the _colorIndex after\n                    // Series.update()\n                    setting = pick(\n                        userOptions[indexName],\n                        userOptions['_' + indexName]\n                    );\n                    if (defined(setting)) { // after Series.update()\n                        i = setting;\n                    } else {\n                        // #6138\n                        if (!chart.series.length) {\n                            chart[counterName] = 0;\n                        }\n                        userOptions['_' + indexName] = i = chart[counterName] % len;\n                        chart[counterName] += 1;\n                    }\n                    if (defaults) {\n                        value = defaults[i];\n                    }\n                }\n                // Set the colorIndex\n                if (i !== undefined) {\n                    this[indexName] = i;\n                }\n                this[prop] = value;\n            },\n\n            /**\n             * Get the series' color\n             */\n\n            getColor: function() {\n                if (this.options.colorByPoint) {\n                    // #4359, selected slice got series.color even when colorByPoint was\n                    // set.\n                    this.options.color = null;\n                } else {\n                    this.getCyclic(\n                        'color',\n                        this.options.color || defaultPlotOptions[this.type].color,\n                        this.chart.options.colors\n                    );\n                }\n            },\n\n            /**\n             * Get the series' symbol\n             */\n            getSymbol: function() {\n                var seriesMarkerOption = this.options.marker;\n\n                this.getCyclic(\n                    'symbol',\n                    seriesMarkerOption.symbol,\n                    this.chart.options.symbols\n                );\n            },\n\n            drawLegendSymbol: LegendSymbolMixin.drawLineMarker,\n\n            /**\n             * Apply a new set of data to the series and optionally redraw it. The new\n             * data array is passed by reference (except in case of `updatePoints`), and\n             * may later be mutated when updating the chart data.\n             * \n             * Note the difference in behaviour when setting the same amount of points,\n             * or a different amount of points, as handled by the `updatePoints`\n             * parameter. \n             * \n             * @param  {SeriesDataOptions} data\n             *         Takes an array of data in the same format as described under\n             *         `series<type>data` for the given series type.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after the series is altered. If doing\n             *         more operations on the chart, it is a good idea to set redraw to\n             *         false and call {@link Chart#redraw} after.\n             * @param  {AnimationOptions} [animation]\n             *         When the updated data is the same length as the existing data,\n             *         points will be updated by default, and animation visualizes how\n             *         the points are changed. Set false to disable animation, or a\n             *         configuration object to set duration or easing.\n             * @param  {Boolean} [updatePoints=true]\n             *         When the updated data is the same length as the existing data,\n             *         points will be updated instead of replaced. This allows updating\n             *         with animation and performs better. In this case, the original\n             *         array is not passed by reference. Set false to prevent.\n             *\n             * @sample highcharts/members/series-setdata/\n             *         Set new data from a button\n             * @sample highcharts/members/series-setdata-pie/\n             *         Set data in a pie\n             * @sample stock/members/series-setdata/\n             *         Set new data in Highstock\n             * @sample maps/members/series-setdata/\n             *         Set new data in Highmaps\n             */\n            setData: function(data, redraw, animation, updatePoints) {\n                var series = this,\n                    oldData = series.points,\n                    oldDataLength = (oldData && oldData.length) || 0,\n                    dataLength,\n                    options = series.options,\n                    chart = series.chart,\n                    firstPoint = null,\n                    xAxis = series.xAxis,\n                    i,\n                    turboThreshold = options.turboThreshold,\n                    pt,\n                    xData = this.xData,\n                    yData = this.yData,\n                    pointArrayMap = series.pointArrayMap,\n                    valueCount = pointArrayMap && pointArrayMap.length;\n\n                data = data || [];\n                dataLength = data.length;\n                redraw = pick(redraw, true);\n\n                // If the point count is the same as is was, just run Point.update which\n                // is cheaper, allows animation, and keeps references to points.\n                if (\n                    updatePoints !== false &&\n                    dataLength &&\n                    oldDataLength === dataLength &&\n                    !series.cropped &&\n                    !series.hasGroupedData &&\n                    series.visible\n                ) {\n                    each(data, function(point, i) {\n                        // .update doesn't exist on a linked, hidden series (#3709)\n                        if (oldData[i].update && point !== options.data[i]) {\n                            oldData[i].update(point, false, null, false);\n                        }\n                    });\n\n                } else {\n\n                    // Reset properties\n                    series.xIncrement = null;\n\n                    series.colorCounter = 0; // for series with colorByPoint (#1547)\n\n                    // Update parallel arrays\n                    each(this.parallelArrays, function(key) {\n                        series[key + 'Data'].length = 0;\n                    });\n\n                    // In turbo mode, only one- or twodimensional arrays of numbers are\n                    // allowed. The first value is tested, and we assume that all the\n                    // rest are defined the same way. Although the 'for' loops are\n                    // similar, they are repeated inside each if-else conditional for\n                    // max performance.\n                    if (turboThreshold && dataLength > turboThreshold) {\n\n                        // find the first non-null point\n                        i = 0;\n                        while (firstPoint === null && i < dataLength) {\n                            firstPoint = data[i];\n                            i++;\n                        }\n\n\n                        if (isNumber(firstPoint)) { // assume all points are numbers\n                            for (i = 0; i < dataLength; i++) {\n                                xData[i] = this.autoIncrement();\n                                yData[i] = data[i];\n                            }\n\n                            // Assume all points are arrays when first point is\n                        } else if (isArray(firstPoint)) {\n                            if (valueCount) { // [x, low, high] or [x, o, h, l, c]\n                                for (i = 0; i < dataLength; i++) {\n                                    pt = data[i];\n                                    xData[i] = pt[0];\n                                    yData[i] = pt.slice(1, valueCount + 1);\n                                }\n                            } else { // [x, y]\n                                for (i = 0; i < dataLength; i++) {\n                                    pt = data[i];\n                                    xData[i] = pt[0];\n                                    yData[i] = pt[1];\n                                }\n                            }\n                        } else {\n                            // Highcharts expects configs to be numbers or arrays in\n                            // turbo mode\n                            H.error(12);\n                        }\n                    } else {\n                        for (i = 0; i < dataLength; i++) {\n                            if (data[i] !== undefined) { // stray commas in oldIE\n                                pt = {\n                                    series: series\n                                };\n                                series.pointClass.prototype.applyOptions.apply(\n                                    pt, [data[i]]\n                                );\n                                series.updateParallelArrays(pt, i);\n                            }\n                        }\n                    }\n\n                    // Forgetting to cast strings to numbers is a common caveat when\n                    // handling CSV or JSON\n                    if (isString(yData[0])) {\n                        H.error(14, true);\n                    }\n\n                    /**\n                     * Read only. An array containing the series' data point objects. To\n                     * modify the data, use {@link Highcharts.Series#setData} or {@link\n                     * Highcharts.Point#update}.\n                     *\n                     * @name data\n                     * @memberOf Highcharts.Series\n                     * @type {Array.<Highcharts.Point>}\n                     */\n                    series.data = [];\n                    series.options.data = series.userOptions.data = data;\n\n                    // destroy old points\n                    i = oldDataLength;\n                    while (i--) {\n                        if (oldData[i] && oldData[i].destroy) {\n                            oldData[i].destroy();\n                        }\n                    }\n\n                    // reset minRange (#878)\n                    if (xAxis) {\n                        xAxis.minRange = xAxis.userMinRange;\n                    }\n\n                    // redraw\n                    series.isDirty = chart.isDirtyBox = true;\n                    series.isDirtyData = !!oldData;\n                    animation = false;\n                }\n\n                // Typically for pie series, points need to be processed and generated\n                // prior to rendering the legend\n                if (options.legendType === 'point') {\n                    this.processData();\n                    this.generatePoints();\n                }\n\n                if (redraw) {\n                    chart.redraw(animation);\n                }\n            },\n\n            /**\n             * Process the data by cropping away unused data points if the series is\n             * longer than the crop threshold. This saves computing time for large\n             * series.\n             */\n            processData: function(force) {\n                var series = this,\n                    processedXData = series.xData, // copied during slice operation\n                    processedYData = series.yData,\n                    dataLength = processedXData.length,\n                    croppedData,\n                    cropStart = 0,\n                    cropped,\n                    distance,\n                    closestPointRange,\n                    xAxis = series.xAxis,\n                    i, // loop variable\n                    options = series.options,\n                    cropThreshold = options.cropThreshold,\n                    getExtremesFromAll =\n                    series.getExtremesFromAll ||\n                    options.getExtremesFromAll, // #4599\n                    isCartesian = series.isCartesian,\n                    xExtremes,\n                    val2lin = xAxis && xAxis.val2lin,\n                    isLog = xAxis && xAxis.isLog,\n                    min,\n                    max;\n\n                // If the series data or axes haven't changed, don't go through this.\n                // Return false to pass the message on to override methods like in data\n                // grouping.\n                if (\n                    isCartesian &&\n                    !series.isDirty &&\n                    !xAxis.isDirty &&\n                    !series.yAxis.isDirty &&\n                    !force\n                ) {\n                    return false;\n                }\n\n                if (xAxis) {\n                    xExtremes = xAxis.getExtremes(); // corrected for log axis (#3053)\n                    min = xExtremes.min;\n                    max = xExtremes.max;\n                }\n\n                // optionally filter out points outside the plot area\n                if (\n                    isCartesian &&\n                    series.sorted &&\n                    !getExtremesFromAll &&\n                    (!cropThreshold || dataLength > cropThreshold || series.forceCrop)\n                ) {\n\n                    // it's outside current extremes\n                    if (\n                        processedXData[dataLength - 1] < min ||\n                        processedXData[0] > max\n                    ) {\n                        processedXData = [];\n                        processedYData = [];\n\n                        // only crop if it's actually spilling out\n                    } else if (\n                        processedXData[0] < min ||\n                        processedXData[dataLength - 1] > max\n                    ) {\n                        croppedData = this.cropData(\n                            series.xData,\n                            series.yData,\n                            min,\n                            max\n                        );\n                        processedXData = croppedData.xData;\n                        processedYData = croppedData.yData;\n                        cropStart = croppedData.start;\n                        cropped = true;\n                    }\n                }\n\n\n                // Find the closest distance between processed points\n                i = processedXData.length || 1;\n                while (--i) {\n                    distance = isLog ?\n                        val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) :\n                        processedXData[i] - processedXData[i - 1];\n\n                    if (\n                        distance > 0 &&\n                        (\n                            closestPointRange === undefined ||\n                            distance < closestPointRange\n                        )\n                    ) {\n                        closestPointRange = distance;\n\n                        // Unsorted data is not supported by the line tooltip, as well as\n                        // data grouping and navigation in Stock charts (#725) and width\n                        // calculation of columns (#1900)\n                    } else if (distance < 0 && series.requireSorting) {\n                        H.error(15);\n                    }\n                }\n\n                // Record the properties\n                series.cropped = cropped; // undefined or true\n                series.cropStart = cropStart;\n                series.processedXData = processedXData;\n                series.processedYData = processedYData;\n\n                series.closestPointRange = closestPointRange;\n\n            },\n\n            /**\n             * Iterate over xData and crop values between min and max. Returns object\n             * containing crop start/end cropped xData with corresponding part of yData,\n             * dataMin and dataMax within the cropped range\n             */\n            cropData: function(xData, yData, min, max) {\n                var dataLength = xData.length,\n                    cropStart = 0,\n                    cropEnd = dataLength,\n                    // line-type series need one point outside\n                    cropShoulder = pick(this.cropShoulder, 1),\n                    i,\n                    j;\n\n                // iterate up to find slice start\n                for (i = 0; i < dataLength; i++) {\n                    if (xData[i] >= min) {\n                        cropStart = Math.max(0, i - cropShoulder);\n                        break;\n                    }\n                }\n\n                // proceed to find slice end\n                for (j = i; j < dataLength; j++) {\n                    if (xData[j] > max) {\n                        cropEnd = j + cropShoulder;\n                        break;\n                    }\n                }\n\n                return {\n                    xData: xData.slice(cropStart, cropEnd),\n                    yData: yData.slice(cropStart, cropEnd),\n                    start: cropStart,\n                    end: cropEnd\n                };\n            },\n\n\n            /**\n             * Generate the data point after the data has been processed by cropping\n             * away unused points and optionally grouped in Highcharts Stock.\n             */\n            generatePoints: function() {\n                var series = this,\n                    options = series.options,\n                    dataOptions = options.data,\n                    data = series.data,\n                    dataLength,\n                    processedXData = series.processedXData,\n                    processedYData = series.processedYData,\n                    PointClass = series.pointClass,\n                    processedDataLength = processedXData.length,\n                    cropStart = series.cropStart || 0,\n                    cursor,\n                    hasGroupedData = series.hasGroupedData,\n                    keys = options.keys,\n                    point,\n                    points = [],\n                    i;\n\n                if (!data && !hasGroupedData) {\n                    var arr = [];\n                    arr.length = dataOptions.length;\n                    data = series.data = arr;\n                }\n\n                if (keys && hasGroupedData) {\n                    // grouped data has already applied keys (#6590)\n                    series.options.keys = false;\n                }\n\n                for (i = 0; i < processedDataLength; i++) {\n                    cursor = cropStart + i;\n                    if (!hasGroupedData) {\n                        point = data[cursor];\n                        if (!point && dataOptions[cursor] !== undefined) { // #970\n                            data[cursor] = point = (new PointClass()).init(\n                                series,\n                                dataOptions[cursor],\n                                processedXData[i]\n                            );\n                        }\n                    } else {\n                        // splat the y data in case of ohlc data array\n                        point = (new PointClass()).init(\n                            series, [processedXData[i]].concat(splat(processedYData[i]))\n                        );\n\n                        /**\n                         * Highstock only. If a point object is created by data\n                         * grouping, it doesn't reflect actual points in the raw data.\n                         * In this case, the `dataGroup` property holds information\n                         * that points back to the raw data.\n                         *\n                         * - `dataGroup.start` is the index of the first raw data point\n                         * in the group.\n                         * - `dataGroup.length` is the amount of points in the group.\n                         *\n                         * @name dataGroup\n                         * @memberOf Point\n                         * @type {Object}\n                         * \n                         */\n                        point.dataGroup = series.groupMap[i];\n                    }\n                    if (point) { // #6279\n                        point.index = cursor; // For faster access in Point.update\n                        points[i] = point;\n                    }\n                }\n\n                // restore keys options (#6590)\n                series.options.keys = keys;\n\n                // Hide cropped-away points - this only runs when the number of points\n                // is above cropThreshold, or when swithching view from non-grouped\n                // data to grouped data (#637)\n                if (\n                    data &&\n                    (\n                        processedDataLength !== (dataLength = data.length) ||\n                        hasGroupedData\n                    )\n                ) {\n                    for (i = 0; i < dataLength; i++) {\n                        // when has grouped data, clear all points\n                        if (i === cropStart && !hasGroupedData) {\n                            i += processedDataLength;\n                        }\n                        if (data[i]) {\n                            data[i].destroyElements();\n                            data[i].plotX = undefined; // #1003\n                        }\n                    }\n                }\n\n                series.data = data;\n                series.points = points;\n            },\n\n            /**\n             * Calculate Y extremes for visible data\n             */\n            getExtremes: function(yData) {\n                var xAxis = this.xAxis,\n                    yAxis = this.yAxis,\n                    xData = this.processedXData,\n                    yDataLength,\n                    activeYData = [],\n                    activeCounter = 0,\n                    // #2117, need to compensate for log X axis\n                    xExtremes = xAxis.getExtremes(),\n                    xMin = xExtremes.min,\n                    xMax = xExtremes.max,\n                    validValue,\n                    withinRange,\n                    x,\n                    y,\n                    i,\n                    j;\n\n                yData = yData || this.stackedYData || this.processedYData || [];\n                yDataLength = yData.length;\n\n                for (i = 0; i < yDataLength; i++) {\n\n                    x = xData[i];\n                    y = yData[i];\n\n                    // For points within the visible range, including the first point\n                    // outside the visible range, consider y extremes\n                    validValue =\n                        (isNumber(y, true) || isArray(y)) &&\n                        (!yAxis.positiveValuesOnly || (y.length || y > 0));\n                    withinRange =\n                        this.getExtremesFromAll ||\n                        this.options.getExtremesFromAll ||\n                        this.cropped ||\n                        ((xData[i] || x) >= xMin && (xData[i] || x) <= xMax);\n\n                    if (validValue && withinRange) {\n\n                        j = y.length;\n                        if (j) { // array, like ohlc or range data\n                            while (j--) {\n                                if (y[j] !== null) {\n                                    activeYData[activeCounter++] = y[j];\n                                }\n                            }\n                        } else {\n                            activeYData[activeCounter++] = y;\n                        }\n                    }\n                }\n\n                this.dataMin = arrayMin(activeYData);\n                this.dataMax = arrayMax(activeYData);\n            },\n\n            /**\n             * Translate data points from raw data values to chart specific positioning\n             * data needed later in drawPoints, drawGraph and drawTracker.\n             *\n             * @function #translate\n             * @memberOf Series\n             * @returns {void}\n             */\n            translate: function() {\n                if (!this.processedXData) { // hidden series\n                    this.processData();\n                }\n                this.generatePoints();\n                var series = this,\n                    options = series.options,\n                    stacking = options.stacking,\n                    xAxis = series.xAxis,\n                    categories = xAxis.categories,\n                    yAxis = series.yAxis,\n                    points = series.points,\n                    dataLength = points.length,\n                    hasModifyValue = !!series.modifyValue,\n                    i,\n                    pointPlacement = options.pointPlacement,\n                    dynamicallyPlaced =\n                    pointPlacement === 'between' ||\n                    isNumber(pointPlacement),\n                    threshold = options.threshold,\n                    stackThreshold = options.startFromThreshold ? threshold : 0,\n                    plotX,\n                    plotY,\n                    lastPlotX,\n                    stackIndicator,\n                    closestPointRangePx = Number.MAX_VALUE;\n\n                // Point placement is relative to each series pointRange (#5889)\n                if (pointPlacement === 'between') {\n                    pointPlacement = 0.5;\n                }\n                if (isNumber(pointPlacement)) {\n                    pointPlacement *= pick(options.pointRange || xAxis.pointRange);\n                }\n\n                // Translate each point\n                for (i = 0; i < dataLength; i++) {\n                    var point = points[i],\n                        xValue = point.x,\n                        yValue = point.y,\n                        yBottom = point.low,\n                        stack = stacking && yAxis.stacks[(\n                            series.negStacks &&\n                            yValue < (stackThreshold ? 0 : threshold) ? '-' : ''\n                        ) + series.stackKey],\n                        pointStack,\n                        stackValues;\n\n                    // Discard disallowed y values for log axes (#3434)\n                    if (yAxis.positiveValuesOnly && yValue !== null && yValue <= 0) {\n                        point.isNull = true;\n                    }\n\n                    // Get the plotX translation\n                    point.plotX = plotX = correctFloat( // #5236\n                        Math.min(Math.max(-1e5, xAxis.translate(\n                            xValue,\n                            0,\n                            0,\n                            0,\n                            1,\n                            pointPlacement,\n                            this.type === 'flags'\n                        )), 1e5) // #3923\n                    );\n\n                    // Calculate the bottom y value for stacked series\n                    if (\n                        stacking &&\n                        series.visible &&\n                        !point.isNull &&\n                        stack &&\n                        stack[xValue]\n                    ) {\n                        stackIndicator = series.getStackIndicator(\n                            stackIndicator,\n                            xValue,\n                            series.index\n                        );\n                        pointStack = stack[xValue];\n                        stackValues = pointStack.points[stackIndicator.key];\n                        yBottom = stackValues[0];\n                        yValue = stackValues[1];\n\n                        if (\n                            yBottom === stackThreshold &&\n                            stackIndicator.key === stack[xValue].base\n                        ) {\n                            yBottom = pick(threshold, yAxis.min);\n                        }\n                        if (yAxis.positiveValuesOnly && yBottom <= 0) { // #1200, #1232\n                            yBottom = null;\n                        }\n\n                        point.total = point.stackTotal = pointStack.total;\n                        point.percentage =\n                            pointStack.total &&\n                            (point.y / pointStack.total * 100);\n                        point.stackY = yValue;\n\n                        // Place the stack label\n                        pointStack.setOffset(\n                            series.pointXOffset || 0,\n                            series.barW || 0\n                        );\n\n                    }\n\n                    // Set translated yBottom or remove it\n                    point.yBottom = defined(yBottom) ?\n                        yAxis.translate(yBottom, 0, 1, 0, 1) :\n                        null;\n\n                    // general hook, used for Highstock compare mode\n                    if (hasModifyValue) {\n                        yValue = series.modifyValue(yValue, point);\n                    }\n\n                    // Set the the plotY value, reset it for redraws\n                    point.plotY = plotY =\n                        (typeof yValue === 'number' && yValue !== Infinity) ?\n                        Math.min(Math.max(-1e5,\n                            yAxis.translate(yValue, 0, 1, 0, 1)), 1e5) : // #3201\n                        undefined;\n\n                    point.isInside =\n                        plotY !== undefined &&\n                        plotY >= 0 &&\n                        plotY <= yAxis.len && // #3519\n                        plotX >= 0 &&\n                        plotX <= xAxis.len;\n\n\n                    // Set client related positions for mouse tracking\n                    point.clientX = dynamicallyPlaced ?\n                        correctFloat(\n                            xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)\n                        ) :\n                        plotX; // #1514, #5383, #5518\n\n                    point.negative = point.y < (threshold || 0);\n\n                    // some API data\n                    point.category = categories && categories[point.x] !== undefined ?\n                        categories[point.x] : point.x;\n\n                    // Determine auto enabling of markers (#3635, #5099)\n                    if (!point.isNull) {\n                        if (lastPlotX !== undefined) {\n                            closestPointRangePx = Math.min(\n                                closestPointRangePx,\n                                Math.abs(plotX - lastPlotX)\n                            );\n                        }\n                        lastPlotX = plotX;\n                    }\n\n                    // Find point zone\n                    point.zone = this.zones.length && point.getZone();\n                }\n                series.closestPointRangePx = closestPointRangePx;\n            },\n\n            /**\n             * Return the series points with null points filtered out\n             */\n            getValidPoints: function(points, insideOnly) {\n                var chart = this.chart;\n                // #3916, #5029, #5085\n                return grep(points || this.points || [], function isValidPoint(point) {\n                    if (insideOnly && !chart.isInsidePlot(\n                            point.plotX,\n                            point.plotY,\n                            chart.inverted\n                        )) {\n                        return false;\n                    }\n                    return !point.isNull;\n                });\n            },\n\n            /**\n             * Set the clipping for the series. For animated series it is called twice,\n             * first to initiate animating the clip then the second time without the\n             * animation to set the final clip.\n             */\n            setClip: function(animation) {\n                var chart = this.chart,\n                    options = this.options,\n                    renderer = chart.renderer,\n                    inverted = chart.inverted,\n                    seriesClipBox = this.clipBox,\n                    clipBox = seriesClipBox || chart.clipBox,\n                    sharedClipKey =\n                    this.sharedClipKey || [\n                        '_sharedClip',\n                        animation && animation.duration,\n                        animation && animation.easing,\n                        clipBox.height,\n                        options.xAxis,\n                        options.yAxis\n                    ].join(','), // #4526\n                    clipRect = chart[sharedClipKey],\n                    markerClipRect = chart[sharedClipKey + 'm'];\n\n                // If a clipping rectangle with the same properties is currently present\n                // in the chart, use that.\n                if (!clipRect) {\n\n                    // When animation is set, prepare the initial positions\n                    if (animation) {\n                        clipBox.width = 0;\n\n                        chart[sharedClipKey + 'm'] = markerClipRect = renderer.clipRect(-99, // include the width of the first marker\n                            inverted ? -chart.plotLeft : -chart.plotTop,\n                            99,\n                            inverted ? chart.chartWidth : chart.chartHeight\n                        );\n                    }\n                    chart[sharedClipKey] = clipRect = renderer.clipRect(clipBox);\n                    // Create hashmap for series indexes\n                    clipRect.count = {\n                        length: 0\n                    };\n\n                }\n                if (animation) {\n                    if (!clipRect.count[this.index]) {\n                        clipRect.count[this.index] = true;\n                        clipRect.count.length += 1;\n                    }\n                }\n\n                if (options.clip !== false) {\n                    this.group.clip(animation || seriesClipBox ? clipRect : chart.clipRect);\n                    this.markerGroup.clip(markerClipRect);\n                    this.sharedClipKey = sharedClipKey;\n                }\n\n                // Remove the shared clipping rectangle when all series are shown\n                if (!animation) {\n                    if (clipRect.count[this.index]) {\n                        delete clipRect.count[this.index];\n                        clipRect.count.length -= 1;\n                    }\n\n                    if (clipRect.count.length === 0 && sharedClipKey && chart[sharedClipKey]) {\n                        if (!seriesClipBox) {\n                            chart[sharedClipKey] = chart[sharedClipKey].destroy();\n                        }\n                        if (chart[sharedClipKey + 'm']) {\n                            chart[sharedClipKey + 'm'] = chart[sharedClipKey + 'm'].destroy();\n                        }\n                    }\n                }\n            },\n\n            /**\n             * Animate in the series\n             */\n            animate: function(init) {\n                var series = this,\n                    chart = series.chart,\n                    clipRect,\n                    animation = animObject(series.options.animation),\n                    sharedClipKey;\n\n                // Initialize the animation. Set up the clipping rectangle.\n                if (init) {\n\n                    series.setClip(animation);\n\n                    // Run the animation\n                } else {\n                    sharedClipKey = this.sharedClipKey;\n                    clipRect = chart[sharedClipKey];\n                    if (clipRect) {\n                        clipRect.animate({\n                            width: chart.plotSizeX\n                        }, animation);\n                    }\n                    if (chart[sharedClipKey + 'm']) {\n                        chart[sharedClipKey + 'm'].animate({\n                            width: chart.plotSizeX + 99\n                        }, animation);\n                    }\n\n                    // Delete this function to allow it only once\n                    series.animate = null;\n\n                }\n            },\n\n            /**\n             * This runs after animation to land on the final plot clipping\n             */\n            afterAnimate: function() {\n                this.setClip();\n                fireEvent(this, 'afterAnimate');\n            },\n\n            /**\n             * Draw the markers.\n             *\n             * @function #drawPoints\n             * @memberOf Series\n             * @returns {void}\n             */\n            drawPoints: function() {\n                var series = this,\n                    points = series.points,\n                    chart = series.chart,\n                    plotY,\n                    i,\n                    point,\n                    symbol,\n                    graphic,\n                    options = series.options,\n                    seriesMarkerOptions = options.marker,\n                    pointMarkerOptions,\n                    hasPointMarker,\n                    enabled,\n                    isInside,\n                    markerGroup = series[series.specialGroup] || series.markerGroup,\n                    xAxis = series.xAxis,\n                    markerAttribs,\n                    globallyEnabled = pick(\n                        seriesMarkerOptions.enabled,\n                        xAxis.isRadial ? true : null,\n                        // Use larger or equal as radius is null in bubbles (#6321)\n                        series.closestPointRangePx >= 2 * seriesMarkerOptions.radius\n                    );\n\n                if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {\n\n                    for (i = 0; i < points.length; i++) {\n                        point = points[i];\n                        plotY = point.plotY;\n                        graphic = point.graphic;\n                        pointMarkerOptions = point.marker || {};\n                        hasPointMarker = !!point.marker;\n                        enabled = (globallyEnabled && pointMarkerOptions.enabled === undefined) || pointMarkerOptions.enabled;\n                        isInside = point.isInside;\n\n                        // only draw the point if y is defined\n                        if (enabled && isNumber(plotY) && point.y !== null) {\n\n                            // Shortcuts\n                            symbol = pick(pointMarkerOptions.symbol, series.symbol);\n                            point.hasImage = symbol.indexOf('url') === 0;\n\n                            markerAttribs = series.markerAttribs(\n                                point,\n                                point.selected && 'select'\n                            );\n\n                            if (graphic) { // update\n                                graphic[isInside ? 'show' : 'hide'](true) // Since the marker group isn't clipped, each individual marker must be toggled\n                                    .animate(markerAttribs);\n                            } else if (isInside && (markerAttribs.width > 0 || point.hasImage)) {\n                                point.graphic = graphic = chart.renderer.symbol(\n                                        symbol,\n                                        markerAttribs.x,\n                                        markerAttribs.y,\n                                        markerAttribs.width,\n                                        markerAttribs.height,\n                                        hasPointMarker ? pointMarkerOptions : seriesMarkerOptions\n                                    )\n                                    .add(markerGroup);\n                            }\n\n\n                            // Presentational attributes\n                            if (graphic) {\n                                graphic.attr(series.pointAttribs(point, point.selected && 'select'));\n                            }\n\n\n                            if (graphic) {\n                                graphic.addClass(point.getClassName(), true);\n                            }\n\n                        } else if (graphic) {\n                            point.graphic = graphic.destroy(); // #1269\n                        }\n                    }\n                }\n\n            },\n\n            /**\n             * Get non-presentational attributes for the point.\n             */\n            markerAttribs: function(point, state) {\n                var seriesMarkerOptions = this.options.marker,\n                    seriesStateOptions,\n                    pointMarkerOptions = point.marker || {},\n                    pointStateOptions,\n                    radius = pick(\n                        pointMarkerOptions.radius,\n                        seriesMarkerOptions.radius\n                    ),\n                    attribs;\n\n                // Handle hover and select states\n                if (state) {\n                    seriesStateOptions = seriesMarkerOptions.states[state];\n                    pointStateOptions = pointMarkerOptions.states &&\n                        pointMarkerOptions.states[state];\n\n                    radius = pick(\n                        pointStateOptions && pointStateOptions.radius,\n                        seriesStateOptions && seriesStateOptions.radius,\n                        radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0)\n                    );\n                }\n\n                if (point.hasImage) {\n                    radius = 0; // and subsequently width and height is not set\n                }\n\n                attribs = {\n                    x: Math.floor(point.plotX) - radius, // Math.floor for #1843\n                    y: point.plotY - radius\n                };\n\n                if (radius) {\n                    attribs.width = attribs.height = 2 * radius;\n                }\n\n                return attribs;\n\n            },\n\n\n            /**\n             * Get presentational attributes for marker-based series (line, spline, scatter, bubble, mappoint...)\n             */\n            pointAttribs: function(point, state) {\n                var seriesMarkerOptions = this.options.marker,\n                    seriesStateOptions,\n                    pointOptions = point && point.options,\n                    pointMarkerOptions = (pointOptions && pointOptions.marker) || {},\n                    pointStateOptions,\n                    color = this.color,\n                    pointColorOption = pointOptions && pointOptions.color,\n                    pointColor = point && point.color,\n                    strokeWidth = pick(\n                        pointMarkerOptions.lineWidth,\n                        seriesMarkerOptions.lineWidth\n                    ),\n                    zoneColor = point && point.zone && point.zone.color,\n                    fill,\n                    stroke;\n\n                color = pointColorOption || zoneColor || pointColor || color;\n                fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color;\n                stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color;\n\n                // Handle hover and select states\n                if (state) {\n                    seriesStateOptions = seriesMarkerOptions.states[state];\n                    pointStateOptions = (pointMarkerOptions.states && pointMarkerOptions.states[state]) || {};\n                    strokeWidth = pick(\n                        pointStateOptions.lineWidth,\n                        seriesStateOptions.lineWidth,\n                        strokeWidth + pick(\n                            pointStateOptions.lineWidthPlus,\n                            seriesStateOptions.lineWidthPlus,\n                            0\n                        )\n                    );\n                    fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;\n                    stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;\n                }\n\n                return {\n                    'stroke': stroke,\n                    'stroke-width': strokeWidth,\n                    'fill': fill\n                };\n            },\n\n            /**\n             * Clear DOM objects and free up memory\n             */\n            destroy: function() {\n                var series = this,\n                    chart = series.chart,\n                    issue134 = /AppleWebKit\\/533/.test(win.navigator.userAgent),\n                    destroy,\n                    i,\n                    data = series.data || [],\n                    point,\n                    axis;\n\n                // add event hook\n                fireEvent(series, 'destroy');\n\n                // remove all events\n                removeEvent(series);\n\n                // erase from axes\n                each(series.axisTypes || [], function(AXIS) {\n                    axis = series[AXIS];\n                    if (axis && axis.series) {\n                        erase(axis.series, series);\n                        axis.isDirty = axis.forceRedraw = true;\n                    }\n                });\n\n                // remove legend items\n                if (series.legendItem) {\n                    series.chart.legend.destroyItem(series);\n                }\n\n                // destroy all points with their elements\n                i = data.length;\n                while (i--) {\n                    point = data[i];\n                    if (point && point.destroy) {\n                        point.destroy();\n                    }\n                }\n                series.points = null;\n\n                // Clear the animation timeout if we are destroying the series during initial animation\n                clearTimeout(series.animationTimeout);\n\n                // Destroy all SVGElements associated to the series\n                objectEach(series, function(val, prop) {\n                    if (val instanceof SVGElement && !val.survive) { // Survive provides a hook for not destroying\n\n                        // issue 134 workaround\n                        destroy = issue134 && prop === 'group' ?\n                            'hide' :\n                            'destroy';\n\n                        val[destroy]();\n                    }\n                });\n\n                // remove from hoverSeries\n                if (chart.hoverSeries === series) {\n                    chart.hoverSeries = null;\n                }\n                erase(chart.series, series);\n                chart.orderSeries();\n\n                // clear all members\n                objectEach(series, function(val, prop) {\n                    delete series[prop];\n                });\n            },\n\n            /**\n             * Get the graph path\n             */\n            getGraphPath: function(points, nullsAsZeroes, connectCliffs) {\n                var series = this,\n                    options = series.options,\n                    step = options.step,\n                    reversed,\n                    graphPath = [],\n                    xMap = [],\n                    gap;\n\n                points = points || series.points;\n\n                // Bottom of a stack is reversed\n                reversed = points.reversed;\n                if (reversed) {\n                    points.reverse();\n                }\n                // Reverse the steps (#5004)\n                step = {\n                    right: 1,\n                    center: 2\n                }[step] || (step && 3);\n                if (step && reversed) {\n                    step = 4 - step;\n                }\n\n                // Remove invalid points, especially in spline (#5015)\n                if (options.connectNulls && !nullsAsZeroes && !connectCliffs) {\n                    points = this.getValidPoints(points);\n                }\n\n                // Build the line\n                each(points, function(point, i) {\n\n                    var plotX = point.plotX,\n                        plotY = point.plotY,\n                        lastPoint = points[i - 1],\n                        pathToPoint; // the path to this point from the previous\n\n                    if ((point.leftCliff || (lastPoint && lastPoint.rightCliff)) && !connectCliffs) {\n                        gap = true; // ... and continue\n                    }\n\n                    // Line series, nullsAsZeroes is not handled\n                    if (point.isNull && !defined(nullsAsZeroes) && i > 0) {\n                        gap = !options.connectNulls;\n\n                        // Area series, nullsAsZeroes is set\n                    } else if (point.isNull && !nullsAsZeroes) {\n                        gap = true;\n\n                    } else {\n\n                        if (i === 0 || gap) {\n                            pathToPoint = ['M', point.plotX, point.plotY];\n\n                        } else if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object\n\n                            pathToPoint = series.getPointSpline(points, point, i);\n\n                        } else if (step) {\n\n                            if (step === 1) { // right\n                                pathToPoint = [\n                                    'L',\n                                    lastPoint.plotX,\n                                    plotY\n                                ];\n\n                            } else if (step === 2) { // center\n                                pathToPoint = [\n                                    'L',\n                                    (lastPoint.plotX + plotX) / 2,\n                                    lastPoint.plotY,\n                                    'L',\n                                    (lastPoint.plotX + plotX) / 2,\n                                    plotY\n                                ];\n\n                            } else {\n                                pathToPoint = [\n                                    'L',\n                                    plotX,\n                                    lastPoint.plotY\n                                ];\n                            }\n                            pathToPoint.push('L', plotX, plotY);\n\n                        } else {\n                            // normal line to next point\n                            pathToPoint = [\n                                'L',\n                                plotX,\n                                plotY\n                            ];\n                        }\n\n                        // Prepare for animation. When step is enabled, there are two path nodes for each x value.\n                        xMap.push(point.x);\n                        if (step) {\n                            xMap.push(point.x);\n                        }\n\n                        graphPath.push.apply(graphPath, pathToPoint);\n                        gap = false;\n                    }\n                });\n\n                graphPath.xMap = xMap;\n                series.graphPath = graphPath;\n\n                return graphPath;\n\n            },\n\n            /**\n             * Draw the actual graph\n             */\n            drawGraph: function() {\n                var series = this,\n                    options = this.options,\n                    graphPath = (this.gappedPath || this.getGraphPath).call(this),\n                    props = [\n                        [\n                            'graph',\n                            'highcharts-graph',\n\n                            options.lineColor || this.color,\n                            options.dashStyle\n\n                        ]\n                    ];\n\n                // Add the zone properties if any\n                each(this.zones, function(zone, i) {\n                    props.push([\n                        'zone-graph-' + i,\n                        'highcharts-graph highcharts-zone-graph-' + i + ' ' + (zone.className || ''),\n\n                        zone.color || series.color,\n                        zone.dashStyle || options.dashStyle\n\n                    ]);\n                });\n\n                // Draw the graph\n                each(props, function(prop, i) {\n                    var graphKey = prop[0],\n                        graph = series[graphKey],\n                        attribs;\n\n                    if (graph) {\n                        graph.endX = graphPath.xMap;\n                        graph.animate({\n                            d: graphPath\n                        });\n\n                    } else if (graphPath.length) { // #1487\n\n                        series[graphKey] = series.chart.renderer.path(graphPath)\n                            .addClass(prop[1])\n                            .attr({\n                                zIndex: 1\n                            }) // #1069\n                            .add(series.group);\n\n\n                        attribs = {\n                            'stroke': prop[2],\n                            'stroke-width': options.lineWidth,\n                            'fill': (series.fillGraph && series.color) || 'none' // Polygon series use filled graph\n                        };\n\n                        if (prop[3]) {\n                            attribs.dashstyle = prop[3];\n                        } else if (options.linecap !== 'square') {\n                            attribs['stroke-linecap'] = attribs['stroke-linejoin'] = 'round';\n                        }\n\n                        graph = series[graphKey]\n                            .attr(attribs)\n                            .shadow((i < 2) && options.shadow); // add shadow to normal series (0) or to first zone (1) #3932\n\n                    }\n\n                    // Helpers for animation\n                    if (graph) {\n                        graph.startX = graphPath.xMap;\n                        //graph.shiftUnit = options.step ? 2 : 1;\n                        graph.isArea = graphPath.isArea; // For arearange animation\n                    }\n                });\n            },\n\n            /**\n             * Clip the graphs into the positive and negative coloured graphs\n             */\n            applyZones: function() {\n                var series = this,\n                    chart = this.chart,\n                    renderer = chart.renderer,\n                    zones = this.zones,\n                    translatedFrom,\n                    translatedTo,\n                    clips = this.clips || [],\n                    clipAttr,\n                    graph = this.graph,\n                    area = this.area,\n                    chartSizeMax = Math.max(chart.chartWidth, chart.chartHeight),\n                    axis = this[(this.zoneAxis || 'y') + 'Axis'],\n                    extremes,\n                    reversed,\n                    inverted = chart.inverted,\n                    horiz,\n                    pxRange,\n                    pxPosMin,\n                    pxPosMax,\n                    ignoreZones = false;\n\n                if (zones.length && (graph || area) && axis && axis.min !== undefined) {\n                    reversed = axis.reversed;\n                    horiz = axis.horiz;\n                    // The use of the Color Threshold assumes there are no gaps\n                    // so it is safe to hide the original graph and area\n                    if (graph) {\n                        graph.hide();\n                    }\n                    if (area) {\n                        area.hide();\n                    }\n\n                    // Create the clips\n                    extremes = axis.getExtremes();\n                    each(zones, function(threshold, i) {\n\n                        translatedFrom = reversed ?\n                            (horiz ? chart.plotWidth : 0) :\n                            (horiz ? 0 : axis.toPixels(extremes.min));\n                        translatedFrom = Math.min(Math.max(pick(translatedTo, translatedFrom), 0), chartSizeMax);\n                        translatedTo = Math.min(Math.max(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true)), 0), chartSizeMax);\n\n                        if (ignoreZones) {\n                            translatedFrom = translatedTo = axis.toPixels(extremes.max);\n                        }\n\n                        pxRange = Math.abs(translatedFrom - translatedTo);\n                        pxPosMin = Math.min(translatedFrom, translatedTo);\n                        pxPosMax = Math.max(translatedFrom, translatedTo);\n                        if (axis.isXAxis) {\n                            clipAttr = {\n                                x: inverted ? pxPosMax : pxPosMin,\n                                y: 0,\n                                width: pxRange,\n                                height: chartSizeMax\n                            };\n                            if (!horiz) {\n                                clipAttr.x = chart.plotHeight - clipAttr.x;\n                            }\n                        } else {\n                            clipAttr = {\n                                x: 0,\n                                y: inverted ? pxPosMax : pxPosMin,\n                                width: chartSizeMax,\n                                height: pxRange\n                            };\n                            if (horiz) {\n                                clipAttr.y = chart.plotWidth - clipAttr.y;\n                            }\n                        }\n\n\n                        /// VML SUPPPORT\n                        if (inverted && renderer.isVML) {\n                            if (axis.isXAxis) {\n                                clipAttr = {\n                                    x: 0,\n                                    y: reversed ? pxPosMin : pxPosMax,\n                                    height: clipAttr.width,\n                                    width: chart.chartWidth\n                                };\n                            } else {\n                                clipAttr = {\n                                    x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,\n                                    y: 0,\n                                    width: clipAttr.height,\n                                    height: chart.chartHeight\n                                };\n                            }\n                        }\n                        /// END OF VML SUPPORT\n\n\n                        if (clips[i]) {\n                            clips[i].animate(clipAttr);\n                        } else {\n                            clips[i] = renderer.clipRect(clipAttr);\n\n                            if (graph) {\n                                series['zone-graph-' + i].clip(clips[i]);\n                            }\n\n                            if (area) {\n                                series['zone-area-' + i].clip(clips[i]);\n                            }\n                        }\n                        // if this zone extends out of the axis, ignore the others\n                        ignoreZones = threshold.value > extremes.max;\n                    });\n                    this.clips = clips;\n                }\n            },\n\n            /**\n             * Initialize and perform group inversion on series.group and series.markerGroup\n             */\n            invertGroups: function(inverted) {\n                var series = this,\n                    chart = series.chart,\n                    remover;\n\n                function setInvert() {\n                    each(['group', 'markerGroup'], function(groupName) {\n                        if (series[groupName]) {\n\n                            // VML/HTML needs explicit attributes for flipping\n                            if (chart.renderer.isVML) {\n                                series[groupName].attr({\n                                    width: series.yAxis.len,\n                                    height: series.xAxis.len\n                                });\n                            }\n\n                            series[groupName].width = series.yAxis.len;\n                            series[groupName].height = series.xAxis.len;\n                            series[groupName].invert(inverted);\n                        }\n                    });\n                }\n\n                // Pie, go away (#1736)\n                if (!series.xAxis) {\n                    return;\n                }\n\n                // A fixed size is needed for inversion to work\n                remover = addEvent(chart, 'resize', setInvert);\n                addEvent(series, 'destroy', remover);\n\n                // Do it now\n                setInvert(inverted); // do it now\n\n                // On subsequent render and redraw, just do setInvert without setting up events again\n                series.invertGroups = setInvert;\n            },\n\n            /**\n             * General abstraction for creating plot groups like series.group,\n             * series.dataLabelsGroup and series.markerGroup. On subsequent calls, the\n             * group will only be adjusted to the updated plot size.\n             */\n            plotGroup: function(prop, name, visibility, zIndex, parent) {\n                var group = this[prop],\n                    isNew = !group;\n\n                // Generate it on first call\n                if (isNew) {\n                    this[prop] = group = this.chart.renderer.g()\n                        .attr({\n                            zIndex: zIndex || 0.1 // IE8 and pointer logic use this\n                        })\n                        .add(parent);\n\n                }\n\n                // Add the class names, and replace existing ones as response to\n                // Series.update (#6660)\n                group.addClass(\n                    (\n                        'highcharts-' + name +\n                        ' highcharts-series-' + this.index +\n                        ' highcharts-' + this.type + '-series ' +\n                        'highcharts-color-' + this.colorIndex + ' ' +\n                        (this.options.className || '')\n                    ),\n                    true\n                );\n\n                // Place it on first and subsequent (redraw) calls\n                group.attr({\n                    visibility: visibility\n                })[isNew ? 'attr' : 'animate'](\n                    this.getPlotBox()\n                );\n                return group;\n            },\n\n            /**\n             * Get the translation and scale for the plot area of this series\n             */\n            getPlotBox: function() {\n                var chart = this.chart,\n                    xAxis = this.xAxis,\n                    yAxis = this.yAxis;\n\n                // Swap axes for inverted (#2339)\n                if (chart.inverted) {\n                    xAxis = yAxis;\n                    yAxis = this.xAxis;\n                }\n                return {\n                    translateX: xAxis ? xAxis.left : chart.plotLeft,\n                    translateY: yAxis ? yAxis.top : chart.plotTop,\n                    scaleX: 1, // #1623\n                    scaleY: 1\n                };\n            },\n\n            /**\n             * Render the graph and markers\n             */\n            render: function() {\n                var series = this,\n                    chart = series.chart,\n                    group,\n                    options = series.options,\n                    // Animation doesn't work in IE8 quirks when the group div is\n                    // hidden, and looks bad in other oldIE\n                    animDuration = (!!series.animate &&\n                        chart.renderer.isSVG &&\n                        animObject(options.animation).duration\n                    ),\n                    visibility = series.visible ? 'inherit' : 'hidden', // #2597\n                    zIndex = options.zIndex,\n                    hasRendered = series.hasRendered,\n                    chartSeriesGroup = chart.seriesGroup,\n                    inverted = chart.inverted;\n\n                // the group\n                group = series.plotGroup(\n                    'group',\n                    'series',\n                    visibility,\n                    zIndex,\n                    chartSeriesGroup\n                );\n\n                series.markerGroup = series.plotGroup(\n                    'markerGroup',\n                    'markers',\n                    visibility,\n                    zIndex,\n                    chartSeriesGroup\n                );\n\n                // initiate the animation\n                if (animDuration) {\n                    series.animate(true);\n                }\n\n                // SVGRenderer needs to know this before drawing elements (#1089, #1795)\n                group.inverted = series.isCartesian ? inverted : false;\n\n                // draw the graph if any\n                if (series.drawGraph) {\n                    series.drawGraph();\n                    series.applyZones();\n                }\n\n                /*\t\teach(series.points, function (point) {\n                \t\t\tif (point.redraw) {\n                \t\t\t\tpoint.redraw();\n                \t\t\t}\n                \t\t});*/\n\n                // draw the data labels (inn pies they go before the points)\n                if (series.drawDataLabels) {\n                    series.drawDataLabels();\n                }\n\n                // draw the points\n                if (series.visible) {\n                    series.drawPoints();\n                }\n\n\n                // draw the mouse tracking area\n                if (\n                    series.drawTracker &&\n                    series.options.enableMouseTracking !== false\n                ) {\n                    series.drawTracker();\n                }\n\n                // Handle inverted series and tracker groups\n                series.invertGroups(inverted);\n\n                // Initial clipping, must be defined after inverting groups for VML.\n                // Applies to columns etc. (#3839).\n                if (options.clip !== false && !series.sharedClipKey && !hasRendered) {\n                    group.clip(chart.clipRect);\n                }\n\n                // Run the animation\n                if (animDuration) {\n                    series.animate();\n                }\n\n                // Call the afterAnimate function on animation complete (but don't\n                // overwrite the animation.complete option which should be available to\n                // the user).\n                if (!hasRendered) {\n                    series.animationTimeout = syncTimeout(function() {\n                        series.afterAnimate();\n                    }, animDuration);\n                }\n\n                series.isDirty = false; // means data is in accordance with what you see\n                // (See #322) series.isDirty = series.isDirtyData = false; // means\n                // data is in accordance with what you see\n                series.hasRendered = true;\n            },\n\n            /**\n             * Redraw the series after an update in the axes.\n             */\n            redraw: function() {\n                var series = this,\n                    chart = series.chart,\n                    // cache it here as it is set to false in render, but used after\n                    wasDirty = series.isDirty || series.isDirtyData,\n                    group = series.group,\n                    xAxis = series.xAxis,\n                    yAxis = series.yAxis;\n\n                // reposition on resize\n                if (group) {\n                    if (chart.inverted) {\n                        group.attr({\n                            width: chart.plotWidth,\n                            height: chart.plotHeight\n                        });\n                    }\n\n                    group.animate({\n                        translateX: pick(xAxis && xAxis.left, chart.plotLeft),\n                        translateY: pick(yAxis && yAxis.top, chart.plotTop)\n                    });\n                }\n\n                series.translate();\n                series.render();\n                if (wasDirty) { // #3868, #3945\n                    delete this.kdTree;\n                }\n            },\n\n            /**\n             * KD Tree && PointSearching Implementation\n             */\n\n            kdAxisArray: ['clientX', 'plotY'],\n\n            searchPoint: function(e, compareX) {\n                var series = this,\n                    xAxis = series.xAxis,\n                    yAxis = series.yAxis,\n                    inverted = series.chart.inverted;\n\n                return this.searchKDTree({\n                    clientX: inverted ?\n                        xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,\n                    plotY: inverted ?\n                        yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos\n                }, compareX);\n            },\n\n            /**\n             * Build the k-d-tree that is used by mouse and touch interaction to get the\n             * closest point. Line-like series typically have a one-dimensional tree \n             * where points are searched along the X axis, while scatter-like series\n             * typically search in two dimensions, X and Y.\n             */\n            buildKDTree: function() {\n\n                // Prevent multiple k-d-trees from being built simultaneously (#6235)\n                this.buildingKdTree = true;\n\n                var series = this,\n                    dimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?\n                    2 : 1;\n\n                // Internal function\n                function _kdtree(points, depth, dimensions) {\n                    var axis,\n                        median,\n                        length = points && points.length;\n\n                    if (length) {\n\n                        // alternate between the axis\n                        axis = series.kdAxisArray[depth % dimensions];\n\n                        // sort point array\n                        points.sort(function(a, b) {\n                            return a[axis] - b[axis];\n                        });\n\n                        median = Math.floor(length / 2);\n\n                        // build and return nod\n                        return {\n                            point: points[median],\n                            left: _kdtree(\n                                points.slice(0, median), depth + 1, dimensions\n                            ),\n                            right: _kdtree(\n                                points.slice(median + 1), depth + 1, dimensions\n                            )\n                        };\n\n                    }\n                }\n\n                // Start the recursive build process with a clone of the points array\n                // and null points filtered out (#3873)\n                function startRecursive() {\n                    series.kdTree = _kdtree(\n                        series.getValidPoints(\n                            null,\n                            // For line-type series restrict to plot area, but\n                            // column-type series not (#3916, #4511)\n                            !series.directTouch\n                        ),\n                        dimensions,\n                        dimensions\n                    );\n                    series.buildingKdTree = false;\n                }\n                delete series.kdTree;\n\n                // For testing tooltips, don't build async\n                syncTimeout(startRecursive, series.options.kdNow ? 0 : 1);\n            },\n\n            searchKDTree: function(point, compareX) {\n                var series = this,\n                    kdX = this.kdAxisArray[0],\n                    kdY = this.kdAxisArray[1],\n                    kdComparer = compareX ? 'distX' : 'dist',\n                    kdDimensions = series.options.findNearestPointBy.indexOf('y') > -1 ?\n                    2 : 1;\n\n                // Set the one and two dimensional distance on the point object\n                function setDistance(p1, p2) {\n                    var x = (defined(p1[kdX]) && defined(p2[kdX])) ?\n                        Math.pow(p1[kdX] - p2[kdX], 2) :\n                        null,\n                        y = (defined(p1[kdY]) && defined(p2[kdY])) ?\n                        Math.pow(p1[kdY] - p2[kdY], 2) :\n                        null,\n                        r = (x || 0) + (y || 0);\n\n                    p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n                    p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;\n                }\n\n                function _search(search, tree, depth, dimensions) {\n                    var point = tree.point,\n                        axis = series.kdAxisArray[depth % dimensions],\n                        tdist,\n                        sideA,\n                        sideB,\n                        ret = point,\n                        nPoint1,\n                        nPoint2;\n\n                    setDistance(search, point);\n\n                    // Pick side based on distance to splitting point\n                    tdist = search[axis] - point[axis];\n                    sideA = tdist < 0 ? 'left' : 'right';\n                    sideB = tdist < 0 ? 'right' : 'left';\n\n                    // End of tree\n                    if (tree[sideA]) {\n                        nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);\n\n                        ret = (nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point);\n                    }\n                    if (tree[sideB]) {\n                        // compare distance to current best to splitting point to decide\n                        // wether to check side B or not\n                        if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {\n                            nPoint2 = _search(\n                                search,\n                                tree[sideB],\n                                depth + 1,\n                                dimensions\n                            );\n                            ret = nPoint2[kdComparer] < ret[kdComparer] ?\n                                nPoint2 :\n                                ret;\n                        }\n                    }\n\n                    return ret;\n                }\n\n                if (!this.kdTree && !this.buildingKdTree) {\n                    this.buildKDTree();\n                }\n\n                if (this.kdTree) {\n                    return _search(point, this.kdTree, kdDimensions, kdDimensions);\n                }\n            }\n\n        }); // end Series prototype\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var Axis = H.Axis,\n            Chart = H.Chart,\n            correctFloat = H.correctFloat,\n            defined = H.defined,\n            destroyObjectProperties = H.destroyObjectProperties,\n            each = H.each,\n            format = H.format,\n            objectEach = H.objectEach,\n            pick = H.pick,\n            Series = H.Series;\n\n        /**\n         * The class for stacks. Each stack, on a specific X value and either negative\n         * or positive, has its own stack item.\n         *\n         * @class\n         */\n        function StackItem(axis, options, isNegative, x, stackOption) {\n\n            var inverted = axis.chart.inverted;\n\n            this.axis = axis;\n\n            // Tells if the stack is negative\n            this.isNegative = isNegative;\n\n            // Save the options to be able to style the label\n            this.options = options;\n\n            // Save the x value to be able to position the label later\n            this.x = x;\n\n            // Initialize total value\n            this.total = null;\n\n            // This will keep each points' extremes stored by series.index and point \n            // index\n            this.points = {};\n\n            // Save the stack option on the series configuration object, and whether to \n            // treat it as percent\n            this.stack = stackOption;\n            this.leftCliff = 0;\n            this.rightCliff = 0;\n\n            // The align options and text align varies on whether the stack is negative \n            // and if the chart is inverted or not.\n            // First test the user supplied value, then use the dynamic.\n            this.alignOptions = {\n                align: options.align ||\n                    (inverted ? (isNegative ? 'left' : 'right') : 'center'),\n                verticalAlign: options.verticalAlign ||\n                    (inverted ? 'middle' : (isNegative ? 'bottom' : 'top')),\n                y: pick(options.y, inverted ? 4 : (isNegative ? 14 : -6)),\n                x: pick(options.x, inverted ? (isNegative ? -6 : 6) : 0)\n            };\n\n            this.textAlign = options.textAlign ||\n                (inverted ? (isNegative ? 'right' : 'left') : 'center');\n        }\n\n        StackItem.prototype = {\n            destroy: function() {\n                destroyObjectProperties(this, this.axis);\n            },\n\n            /**\n             * Renders the stack total label and adds it to the stack label group.\n             */\n            render: function(group) {\n                var options = this.options,\n                    formatOption = options.format,\n                    str = formatOption ?\n                    format(formatOption, this) :\n                    options.formatter.call(this); // format the text in the label\n\n                // Change the text to reflect the new total and set visibility to hidden\n                // in case the serie is hidden\n                if (this.label) {\n                    this.label.attr({\n                        text: str,\n                        visibility: 'hidden'\n                    });\n                    // Create new label\n                } else {\n                    this.label =\n                        this.axis.chart.renderer.text(str, null, null, options.useHTML)\n                        .css(options.style)\n                        .attr({\n                            align: this.textAlign,\n                            rotation: options.rotation,\n                            visibility: 'hidden' // hidden until setOffset is called\n                        })\n                        .add(group); // add to the labels-group\n                }\n            },\n\n            /**\n             * Sets the offset that the stack has from the x value and repositions the\n             * label.\n             */\n            setOffset: function(xOffset, xWidth) {\n                var stackItem = this,\n                    axis = stackItem.axis,\n                    chart = axis.chart,\n                    inverted = chart.inverted,\n                    reversed = axis.reversed,\n                    neg = (this.isNegative && !reversed) ||\n                    (!this.isNegative && reversed), // #4056\n                    // stack value translated mapped to chart coordinates\n                    y = axis.translate(\n                        axis.usePercentage ? 100 : this.total,\n                        0,\n                        0,\n                        0,\n                        1\n                    ),\n                    yZero = axis.translate(0), // stack origin\n                    h = Math.abs(y - yZero), // stack height\n                    x = chart.xAxis[0].translate(this.x) + xOffset, // stack x position\n                    plotHeight = chart.plotHeight,\n                    stackBox = { // this is the box for the complete stack\n                        x: inverted ? (neg ? y : y - h) : x,\n                        y: inverted ?\n                            plotHeight - x - xWidth : (neg ? (plotHeight - y - h) :\n                                plotHeight - y),\n                        width: inverted ? h : xWidth,\n                        height: inverted ? xWidth : h\n                    },\n                    label = this.label,\n                    alignAttr;\n\n                if (label) {\n                    // Align the label to the box\n                    label.align(this.alignOptions, null, stackBox);\n\n                    // Set visibility (#678)\n                    alignAttr = label.alignAttr;\n                    label[\n                        this.options.crop === false || chart.isInsidePlot(\n                            alignAttr.x,\n                            alignAttr.y\n                        ) ? 'show' : 'hide'](true);\n                }\n            }\n        };\n\n        /**\n         * Generate stacks for each series and calculate stacks total values\n         */\n        Chart.prototype.getStacks = function() {\n            var chart = this;\n\n            // reset stacks for each yAxis\n            each(chart.yAxis, function(axis) {\n                if (axis.stacks && axis.hasVisibleSeries) {\n                    axis.oldStacks = axis.stacks;\n                }\n            });\n\n            each(chart.series, function(series) {\n                if (series.options.stacking && (series.visible === true ||\n                        chart.options.chart.ignoreHiddenSeries === false)) {\n                    series.stackKey = series.type + pick(series.options.stack, '');\n                }\n            });\n        };\n\n\n        // Stacking methods defined on the Axis prototype\n\n        /**\n         * Build the stacks from top down\n         */\n        Axis.prototype.buildStacks = function() {\n            var axisSeries = this.series,\n                series,\n                reversedStacks = pick(this.options.reversedStacks, true),\n                len = axisSeries.length,\n                i;\n            if (!this.isXAxis) {\n                this.usePercentage = false;\n                i = len;\n                while (i--) {\n                    axisSeries[reversedStacks ? i : len - i - 1].setStackedPoints();\n                }\n\n                i = len;\n                while (i--) {\n                    series = axisSeries[reversedStacks ? i : len - i - 1];\n                    if (series.setStackCliffs) {\n                        series.setStackCliffs();\n                    }\n                }\n                // Loop up again to compute percent stack\n                if (this.usePercentage) {\n                    for (i = 0; i < len; i++) {\n                        axisSeries[i].setPercentStacks();\n                    }\n                }\n            }\n        };\n\n        Axis.prototype.renderStackTotals = function() {\n            var axis = this,\n                chart = axis.chart,\n                renderer = chart.renderer,\n                stacks = axis.stacks,\n                stackTotalGroup = axis.stackTotalGroup;\n\n            // Create a separate group for the stack total labels\n            if (!stackTotalGroup) {\n                axis.stackTotalGroup = stackTotalGroup =\n                    renderer.g('stack-labels')\n                    .attr({\n                        visibility: 'visible',\n                        zIndex: 6\n                    })\n                    .add();\n            }\n\n            // plotLeft/Top will change when y axis gets wider so we need to translate\n            // the stackTotalGroup at every render call. See bug #506 and #516\n            stackTotalGroup.translate(chart.plotLeft, chart.plotTop);\n\n            // Render each stack total\n            objectEach(stacks, function(type) {\n                objectEach(type, function(stack) {\n                    stack.render(stackTotalGroup);\n                });\n            });\n        };\n\n        /**\n         * Set all the stacks to initial states and destroy unused ones.\n         */\n        Axis.prototype.resetStacks = function() {\n            var axis = this,\n                stacks = axis.stacks;\n            if (!axis.isXAxis) {\n                objectEach(stacks, function(type) {\n                    objectEach(type, function(stack, key) {\n                        // Clean up memory after point deletion (#1044, #4320)\n                        if (stack.touched < axis.stacksTouched) {\n                            stack.destroy();\n                            delete type[key];\n\n                            // Reset stacks\n                        } else {\n                            stack.total = null;\n                            stack.cum = null;\n                        }\n                    });\n                });\n            }\n        };\n\n        Axis.prototype.cleanStacks = function() {\n            var stacks;\n\n            if (!this.isXAxis) {\n                if (this.oldStacks) {\n                    stacks = this.stacks = this.oldStacks;\n                }\n\n                // reset stacks\n                objectEach(stacks, function(type) {\n                    objectEach(type, function(stack) {\n                        stack.cum = stack.total;\n                    });\n                });\n            }\n        };\n\n\n        // Stacking methods defnied for Series prototype\n\n        /**\n         * Adds series' points value to corresponding stack\n         */\n        Series.prototype.setStackedPoints = function() {\n            if (!this.options.stacking || (this.visible !== true &&\n                    this.chart.options.chart.ignoreHiddenSeries !== false)) {\n                return;\n            }\n\n            var series = this,\n                xData = series.processedXData,\n                yData = series.processedYData,\n                stackedYData = [],\n                yDataLength = yData.length,\n                seriesOptions = series.options,\n                threshold = seriesOptions.threshold,\n                stackThreshold = seriesOptions.startFromThreshold ? threshold : 0,\n                stackOption = seriesOptions.stack,\n                stacking = seriesOptions.stacking,\n                stackKey = series.stackKey,\n                negKey = '-' + stackKey,\n                negStacks = series.negStacks,\n                yAxis = series.yAxis,\n                stacks = yAxis.stacks,\n                oldStacks = yAxis.oldStacks,\n                stackIndicator,\n                isNegative,\n                stack,\n                other,\n                key,\n                pointKey,\n                i,\n                x,\n                y;\n\n\n            yAxis.stacksTouched += 1;\n\n            // loop over the non-null y values and read them into a local array\n            for (i = 0; i < yDataLength; i++) {\n                x = xData[i];\n                y = yData[i];\n                stackIndicator = series.getStackIndicator(\n                    stackIndicator,\n                    x,\n                    series.index\n                );\n                pointKey = stackIndicator.key;\n                // Read stacked values into a stack based on the x value,\n                // the sign of y and the stack key. Stacking is also handled for null\n                // values (#739)\n                isNegative = negStacks && y < (stackThreshold ? 0 : threshold);\n                key = isNegative ? negKey : stackKey;\n\n                // Create empty object for this stack if it doesn't exist yet\n                if (!stacks[key]) {\n                    stacks[key] = {};\n                }\n\n                // Initialize StackItem for this x\n                if (!stacks[key][x]) {\n                    if (oldStacks[key] && oldStacks[key][x]) {\n                        stacks[key][x] = oldStacks[key][x];\n                        stacks[key][x].total = null;\n                    } else {\n                        stacks[key][x] = new StackItem(\n                            yAxis,\n                            yAxis.options.stackLabels,\n                            isNegative,\n                            x,\n                            stackOption\n                        );\n                    }\n                }\n\n                // If the StackItem doesn't exist, create it first\n                stack = stacks[key][x];\n                if (y !== null) {\n                    stack.points[pointKey] = stack.points[series.index] = [pick(stack.cum, stackThreshold)];\n\n                    // Record the base of the stack\n                    if (!defined(stack.cum)) {\n                        stack.base = pointKey;\n                    }\n                    stack.touched = yAxis.stacksTouched;\n\n\n                    // In area charts, if there are multiple points on the same X value,\n                    // let the area fill the full span of those points\n                    if (stackIndicator.index > 0 && series.singleStacks === false) {\n                        stack.points[pointKey][0] =\n                            stack.points[series.index + ',' + x + ',0'][0];\n                    }\n                }\n\n                // Add value to the stack total\n                if (stacking === 'percent') {\n\n                    // Percent stacked column, totals are the same for the positive and\n                    // negative stacks\n                    other = isNegative ? stackKey : negKey;\n                    if (negStacks && stacks[other] && stacks[other][x]) {\n                        other = stacks[other][x];\n                        stack.total = other.total =\n                            Math.max(other.total, stack.total) + Math.abs(y) || 0;\n\n                        // Percent stacked areas\n                    } else {\n                        stack.total = correctFloat(stack.total + (Math.abs(y) || 0));\n                    }\n                } else {\n                    stack.total = correctFloat(stack.total + (y || 0));\n                }\n\n                stack.cum = pick(stack.cum, stackThreshold) + (y || 0);\n\n                if (y !== null) {\n                    stack.points[pointKey].push(stack.cum);\n                    stackedYData[i] = stack.cum;\n                }\n\n            }\n\n            if (stacking === 'percent') {\n                yAxis.usePercentage = true;\n            }\n\n            this.stackedYData = stackedYData; // To be used in getExtremes\n\n            // Reset old stacks\n            yAxis.oldStacks = {};\n        };\n\n        /**\n         * Iterate over all stacks and compute the absolute values to percent\n         */\n        Series.prototype.setPercentStacks = function() {\n            var series = this,\n                stackKey = series.stackKey,\n                stacks = series.yAxis.stacks,\n                processedXData = series.processedXData,\n                stackIndicator;\n\n            each([stackKey, '-' + stackKey], function(key) {\n                var i = processedXData.length,\n                    x,\n                    stack,\n                    pointExtremes,\n                    totalFactor;\n\n                while (i--) {\n                    x = processedXData[i];\n                    stackIndicator = series.getStackIndicator(\n                        stackIndicator,\n                        x,\n                        series.index,\n                        key\n                    );\n                    stack = stacks[key] && stacks[key][x];\n                    pointExtremes = stack && stack.points[stackIndicator.key];\n                    if (pointExtremes) {\n                        totalFactor = stack.total ? 100 / stack.total : 0;\n                        // Y bottom value\n                        pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor);\n                        // Y value\n                        pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor);\n                        series.stackedYData[i] = pointExtremes[1];\n                    }\n                }\n            });\n        };\n\n        /**\n         * Get stack indicator, according to it's x-value, to determine points with the\n         * same x-value\n         */\n        Series.prototype.getStackIndicator = function(stackIndicator, x, index, key) {\n            // Update stack indicator, when:\n            // first point in a stack || x changed || stack type (negative vs positive)\n            // changed:\n            if (!defined(stackIndicator) || stackIndicator.x !== x ||\n                (key && stackIndicator.key !== key)) {\n                stackIndicator = {\n                    x: x,\n                    index: 0,\n                    key: key\n                };\n            } else {\n                stackIndicator.index++;\n            }\n\n            stackIndicator.key = [index, x, stackIndicator.index].join(',');\n\n            return stackIndicator;\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            animate = H.animate,\n            Axis = H.Axis,\n            Chart = H.Chart,\n            createElement = H.createElement,\n            css = H.css,\n            defined = H.defined,\n            each = H.each,\n            erase = H.erase,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            inArray = H.inArray,\n            isNumber = H.isNumber,\n            isObject = H.isObject,\n            isArray = H.isArray,\n            merge = H.merge,\n            objectEach = H.objectEach,\n            pick = H.pick,\n            Point = H.Point,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            setAnimation = H.setAnimation,\n            splat = H.splat;\n\n        // Extend the Chart prototype for dynamic methods\n        extend(Chart.prototype, /** @lends Highcharts.Chart.prototype */ {\n\n            /**\n             * Add a series to the chart after render time. Note that this method should\n             * never be used when adding data synchronously at chart render time, as it\n             * adds expense to the calculations and rendering. When adding data at the\n             * same time as the chart is initiated, add the series as a configuration\n             * option instead. With multiple axes, the `offset` is dynamically adjusted.\n             *\n             * @param  {SeriesOptions} options\n             *         The config options for the series.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after adding.\n             * @param  {AnimationOptions} animation\n             *         Whether to apply animation, and optionally animation\n             *         configuration.\n             *\n             * @return {Highcharts.Series}\n             *         The newly created series object.\n             *\n             * @sample highcharts/members/chart-addseries/\n             *         Add a series from a button\n             * @sample stock/members/chart-addseries/\n             *         Add a series in Highstock\n             */\n            addSeries: function(options, redraw, animation) {\n                var series,\n                    chart = this;\n\n                if (options) {\n                    redraw = pick(redraw, true); // defaults to true\n\n                    fireEvent(chart, 'addSeries', {\n                        options: options\n                    }, function() {\n                        series = chart.initSeries(options);\n\n                        chart.isDirtyLegend = true; // the series array is out of sync with the display\n                        chart.linkSeries();\n                        if (redraw) {\n                            chart.redraw(animation);\n                        }\n                    });\n                }\n\n                return series;\n            },\n\n            /**\n             * Add an axis to the chart after render time. Note that this method should\n             * never be used when adding data synchronously at chart render time, as it\n             * adds expense to the calculations and rendering. When adding data at the\n             * same time as the chart is initiated, add the axis as a configuration\n             * option instead.\n             * @param  {AxisOptions} options\n             *         The axis options.\n             * @param  {Boolean} [isX=false]\n             *         Whether it is an X axis or a value axis.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after adding.\n             * @param  {AnimationOptions} [animation=true]\n             *         Whether and how to apply animation in the redraw.\n             *\n             * @sample highcharts/members/chart-addaxis/ Add and remove axes\n             */\n            addAxis: function(options, isX, redraw, animation) {\n                var key = isX ? 'xAxis' : 'yAxis',\n                    chartOptions = this.options,\n                    userOptions = merge(options, {\n                        index: this[key].length,\n                        isX: isX\n                    });\n\n                new Axis(this, userOptions); // eslint-disable-line no-new\n\n                // Push the new axis options to the chart options\n                chartOptions[key] = splat(chartOptions[key] || {});\n                chartOptions[key].push(userOptions);\n\n                if (pick(redraw, true)) {\n                    this.redraw(animation);\n                }\n            },\n\n            /**\n             * Dim the chart and show a loading text or symbol. Options for the loading\n             * screen are defined in {@link\n             * https://api.highcharts.com/highcharts/loading|the loading options}.\n             * \n             * @param  {String} str\n             *         An optional text to show in the loading label instead of the\n             *         default one. The default text is set in {@link\n             *         http://api.highcharts.com/highcharts/lang.loading|lang.loading}.\n             *\n             * @sample highcharts/members/chart-hideloading/\n             *         Show and hide loading from a button\n             * @sample highcharts/members/chart-showloading/\n             *         Apply different text labels\n             * @sample stock/members/chart-show-hide-loading/\n             *         Toggle loading in Highstock\n             */\n            showLoading: function(str) {\n                var chart = this,\n                    options = chart.options,\n                    loadingDiv = chart.loadingDiv,\n                    loadingOptions = options.loading,\n                    setLoadingSize = function() {\n                        if (loadingDiv) {\n                            css(loadingDiv, {\n                                left: chart.plotLeft + 'px',\n                                top: chart.plotTop + 'px',\n                                width: chart.plotWidth + 'px',\n                                height: chart.plotHeight + 'px'\n                            });\n                        }\n                    };\n\n                // create the layer at the first call\n                if (!loadingDiv) {\n                    chart.loadingDiv = loadingDiv = createElement('div', {\n                        className: 'highcharts-loading highcharts-loading-hidden'\n                    }, null, chart.container);\n\n                    chart.loadingSpan = createElement(\n                        'span', {\n                            className: 'highcharts-loading-inner'\n                        },\n                        null,\n                        loadingDiv\n                    );\n                    addEvent(chart, 'redraw', setLoadingSize); // #1080\n                }\n\n                loadingDiv.className = 'highcharts-loading';\n\n                // Update text\n                chart.loadingSpan.innerHTML = str || options.lang.loading;\n\n\n                // Update visuals\n                css(loadingDiv, extend(loadingOptions.style, {\n                    zIndex: 10\n                }));\n                css(chart.loadingSpan, loadingOptions.labelStyle);\n\n                // Show it\n                if (!chart.loadingShown) {\n                    css(loadingDiv, {\n                        opacity: 0,\n                        display: ''\n                    });\n                    animate(loadingDiv, {\n                        opacity: loadingOptions.style.opacity || 0.5\n                    }, {\n                        duration: loadingOptions.showDuration || 0\n                    });\n                }\n\n\n                chart.loadingShown = true;\n                setLoadingSize();\n            },\n\n            /**\n             * Hide the loading layer.\n             *\n             * @see    Highcharts.Chart#showLoading\n             * @sample highcharts/members/chart-hideloading/\n             *         Show and hide loading from a button\n             * @sample stock/members/chart-show-hide-loading/\n             *         Toggle loading in Highstock\n             */\n            hideLoading: function() {\n                var options = this.options,\n                    loadingDiv = this.loadingDiv;\n\n                if (loadingDiv) {\n                    loadingDiv.className = 'highcharts-loading highcharts-loading-hidden';\n\n                    animate(loadingDiv, {\n                        opacity: 0\n                    }, {\n                        duration: options.loading.hideDuration || 100,\n                        complete: function() {\n                            css(loadingDiv, {\n                                display: 'none'\n                            });\n                        }\n                    });\n\n                }\n                this.loadingShown = false;\n            },\n\n            /** \n             * These properties cause isDirtyBox to be set to true when updating. Can be extended from plugins.\n             */\n            propsRequireDirtyBox: ['backgroundColor', 'borderColor', 'borderWidth', 'margin', 'marginTop', 'marginRight',\n                'marginBottom', 'marginLeft', 'spacing', 'spacingTop', 'spacingRight', 'spacingBottom', 'spacingLeft',\n                'borderRadius', 'plotBackgroundColor', 'plotBackgroundImage', 'plotBorderColor', 'plotBorderWidth',\n                'plotShadow', 'shadow'\n            ],\n\n            /** \n             * These properties cause all series to be updated when updating. Can be\n             * extended from plugins.\n             */\n            propsRequireUpdateSeries: ['chart.inverted', 'chart.polar',\n                'chart.ignoreHiddenSeries', 'chart.type', 'colors', 'plotOptions',\n                'tooltip'\n            ],\n\n            /**\n             * A generic function to update any element of the chart. Elements can be\n             * enabled and disabled, moved, re-styled, re-formatted etc.\n             *\n             * A special case is configuration objects that take arrays, for example\n             * {@link https://api.highcharts.com/highcharts/xAxis|xAxis}, \n             * {@link https://api.highcharts.com/highcharts/yAxis|yAxis} or \n             * {@link https://api.highcharts.com/highcharts/series|series}. For these\n             * collections, an `id` option is used to map the new option set to an\n             * existing object. If an existing object of the same id is not found, the\n             * corresponding item is updated. So for example, running `chart.update`\n             * with a series item without an id, will cause the existing chart's series\n             * with the same index in the series array to be updated.\n             *\n             * See also the {@link https://api.highcharts.com/highcharts/responsive|\n             * responsive option set}. Switching between `responsive.rules` basically\n             * runs `chart.update` under the hood.\n             *\n             * @param  {Options} options\n             *         A configuration object for the new chart options.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart.\n             *\n             * @sample highcharts/members/chart-update/\n             *         Update chart geometry \n             */\n            update: function(options, redraw) {\n                var chart = this,\n                    adders = {\n                        credits: 'addCredits',\n                        title: 'setTitle',\n                        subtitle: 'setSubtitle'\n                    },\n                    optionsChart = options.chart,\n                    updateAllAxes,\n                    updateAllSeries,\n                    newWidth,\n                    newHeight;\n\n                // If the top-level chart option is present, some special updates are required\t\t\n                if (optionsChart) {\n                    merge(true, chart.options.chart, optionsChart);\n\n                    // Setter function\n                    if ('className' in optionsChart) {\n                        chart.setClassName(optionsChart.className);\n                    }\n\n                    if ('inverted' in optionsChart || 'polar' in optionsChart) {\n                        // Parse options.chart.inverted and options.chart.polar together\n                        // with the available series.\n                        chart.propFromSeries();\n                        updateAllAxes = true;\n                    }\n\n                    if ('alignTicks' in optionsChart) { // #6452\n                        updateAllAxes = true;\n                    }\n\n                    objectEach(optionsChart, function(val, key) {\n                        if (inArray('chart.' + key, chart.propsRequireUpdateSeries) !== -1) {\n                            updateAllSeries = true;\n                        }\n                        // Only dirty box\n                        if (inArray(key, chart.propsRequireDirtyBox) !== -1) {\n                            chart.isDirtyBox = true;\n                        }\n                    });\n\n\n                    if ('style' in optionsChart) {\n                        chart.renderer.setStyle(optionsChart.style);\n                    }\n\n                }\n\n                // Moved up, because tooltip needs updated plotOptions (#6218)\n\n                if (options.colors) {\n                    this.options.colors = options.colors;\n                }\n\n\n                if (options.plotOptions) {\n                    merge(true, this.options.plotOptions, options.plotOptions);\n                }\n\n                // Some option stuctures correspond one-to-one to chart objects that\n                // have update methods, for example\n                // options.credits => chart.credits\n                // options.legend => chart.legend\n                // options.title => chart.title\n                // options.tooltip => chart.tooltip\n                // options.subtitle => chart.subtitle\n                // options.mapNavigation => chart.mapNavigation\n                // options.navigator => chart.navigator\n                // options.scrollbar => chart.scrollbar\n                objectEach(options, function(val, key) {\n                    if (chart[key] && typeof chart[key].update === 'function') {\n                        chart[key].update(val, false);\n\n                        // If a one-to-one object does not exist, look for an adder function\n                    } else if (typeof chart[adders[key]] === 'function') {\n                        chart[adders[key]](val);\n                    }\n\n                    if (\n                        key !== 'chart' &&\n                        inArray(key, chart.propsRequireUpdateSeries) !== -1\n                    ) {\n                        updateAllSeries = true;\n                    }\n                });\n\n                // Setters for collections. For axes and series, each item is referred\n                // by an id. If the id is not found, it defaults to the corresponding\n                // item in the collection, so setting one series without an id, will\n                // update the first series in the chart. Setting two series without\n                // an id will update the first and the second respectively (#6019)\n                // chart.update and responsive.\n                each([\n                    'xAxis',\n                    'yAxis',\n                    'zAxis',\n                    'series',\n                    'colorAxis',\n                    'pane'\n                ], function(coll) {\n                    if (options[coll]) {\n                        each(splat(options[coll]), function(newOptions, i) {\n                            var item = (\n                                defined(newOptions.id) &&\n                                chart.get(newOptions.id)\n                            ) || chart[coll][i];\n                            if (item && item.coll === coll) {\n                                item.update(newOptions, false);\n                            }\n                        });\n                    }\n                });\n\n                if (updateAllAxes) {\n                    each(chart.axes, function(axis) {\n                        axis.update({}, false);\n                    });\n                }\n\n                // Certain options require the whole series structure to be thrown away\n                // and rebuilt\n                if (updateAllSeries) {\n                    each(chart.series, function(series) {\n                        series.update({}, false);\n                    });\n                }\n\n                // For loading, just update the options, do not redraw\n                if (options.loading) {\n                    merge(true, chart.options.loading, options.loading);\n                }\n\n                // Update size. Redraw is forced.\n                newWidth = optionsChart && optionsChart.width;\n                newHeight = optionsChart && optionsChart.height;\n                if ((isNumber(newWidth) && newWidth !== chart.chartWidth) ||\n                    (isNumber(newHeight) && newHeight !== chart.chartHeight)) {\n                    chart.setSize(newWidth, newHeight);\n                } else if (pick(redraw, true)) {\n                    chart.redraw();\n                }\n            },\n\n            /**\n             * Setter function to allow use from chart.update\n             */\n            setSubtitle: function(options) {\n                this.setTitle(undefined, options);\n            }\n\n\n        });\n\n        // extend the Point prototype for dynamic methods\n        extend(Point.prototype, /** @lends Highcharts.Point.prototype */ {\n            /**\n             * Update point with new options (typically x/y data) and optionally redraw\n             * the series.\n             *\n             * @param  {Object} options\n             *         The point options. Point options are handled as described under\n             *         the `series<type>.data` item for each series type. For example\n             *         for a line series, if options is a single number, the point will\n             *         be given that number as the main y value. If it is an array, it\n             *         will be interpreted as x and y values respectively. If it is an\n             *         object, advanced options are applied. \n             * @param  {Boolean} [redraw=true]\n             *          Whether to redraw the chart after the point is updated. If doing\n             *          more operations on the chart, it is best practice to set\n             *          `redraw` to false and call `chart.redraw()` after.\n             * @param  {AnimationOptions} [animation=true]\n             *         Whether to apply animation, and optionally animation\n             *         configuration.\n             *\n             * @sample highcharts/members/point-update-column/\n             *         Update column value\n             * @sample highcharts/members/point-update-pie/\n             *         Update pie slice\n             * @sample maps/members/point-update/\n             *         Update map area value in Highmaps\n             */\n            update: function(options, redraw, animation, runEvent) {\n                var point = this,\n                    series = point.series,\n                    graphic = point.graphic,\n                    i,\n                    chart = series.chart,\n                    seriesOptions = series.options;\n\n                redraw = pick(redraw, true);\n\n                function update() {\n\n                    point.applyOptions(options);\n\n                    // Update visuals\n                    if (point.y === null && graphic) { // #4146\n                        point.graphic = graphic.destroy();\n                    }\n                    if (isObject(options, true)) {\n                        // Destroy so we can get new elements\n                        if (graphic && graphic.element) {\n                            if (options && options.marker && options.marker.symbol) {\n                                point.graphic = graphic.destroy();\n                            }\n                        }\n                        if (options && options.dataLabels && point.dataLabel) { // #2468\n                            point.dataLabel = point.dataLabel.destroy();\n                        }\n                    }\n\n                    // record changes in the parallel arrays\n                    i = point.index;\n                    series.updateParallelArrays(point, i);\n\n                    // Record the options to options.data. If the old or the new config\n                    // is an object, use point options, otherwise use raw options\n                    // (#4701, #4916).\n                    seriesOptions.data[i] = (\n                            isObject(seriesOptions.data[i], true) ||\n                            isObject(options, true)\n                        ) ?\n                        point.options :\n                        options;\n\n                    // redraw\n                    series.isDirty = series.isDirtyData = true;\n                    if (!series.fixedBox && series.hasCartesianSeries) { // #1906, #2320\n                        chart.isDirtyBox = true;\n                    }\n\n                    if (seriesOptions.legendType === 'point') { // #1831, #1885\n                        chart.isDirtyLegend = true;\n                    }\n                    if (redraw) {\n                        chart.redraw(animation);\n                    }\n                }\n\n                // Fire the event with a default handler of doing the update\n                if (runEvent === false) { // When called from setData\n                    update();\n                } else {\n                    point.firePointEvent('update', {\n                        options: options\n                    }, update);\n                }\n            },\n\n            /**\n             * Remove a point and optionally redraw the series and if necessary the axes\n             * @param  {Boolean} redraw\n             *         Whether to redraw the chart or wait for an explicit call. When\n             *         doing more operations on the chart, for example running\n             *         `point.remove()` in a loop, it is best practice to set `redraw`\n             *         to false and call `chart.redraw()` after.         \n             * @param  {AnimationOptions} [animation=false]\n             *         Whether to apply animation, and optionally animation\n             *         configuration.\n             *\n             * @sample highcharts/plotoptions/series-point-events-remove/\n             *         Remove point and confirm\n             * @sample highcharts/members/point-remove/\n             *         Remove pie slice\n             * @sample maps/members/point-remove/\n             *         Remove selected points in Highmaps\n             */\n            remove: function(redraw, animation) {\n                this.series.removePoint(inArray(this, this.series.data), redraw, animation);\n            }\n        });\n\n        // Extend the series prototype for dynamic methods\n        extend(Series.prototype, /** @lends Series.prototype */ {\n            /**\n             * Add a point to the series after render time. The point can be added at\n             * the end, or by giving it an X value, to the start or in the middle of the\n             * series.\n             * \n             * @param  {Number|Array|Object} options\n             *         The point options. If options is a single number, a point with\n             *         that y value is appended to the series.If it is an array, it will\n             *         be interpreted as x and y values respectively. If it is an\n             *         object, advanced options as outlined under `series.data` are\n             *         applied.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after the point is added. When adding\n             *         more than one point, it is highly recommended that the redraw\n             *         option be set to false, and instead {@link Chart#redraw}\n             *         is explicitly called after the adding of points is finished.\n             *         Otherwise, the chart will redraw after adding each point.\n             * @param  {Boolean} [shift=false]\n             *         If true, a point is shifted off the start of the series as one is\n             *         appended to the end.\n             * @param  {AnimationOptions} [animation]\n             *         Whether to apply animation, and optionally animation\n             *         configuration.\n             *\n             * @sample highcharts/members/series-addpoint-append/\n             *         Append point\n             * @sample highcharts/members/series-addpoint-append-and-shift/\n             *         Append and shift\n             * @sample highcharts/members/series-addpoint-x-and-y/\n             *         Both X and Y values given\n             * @sample highcharts/members/series-addpoint-pie/\n             *         Append pie slice\n             * @sample stock/members/series-addpoint/\n             *         Append 100 points in Highstock\n             * @sample stock/members/series-addpoint-shift/\n             *         Append and shift in Highstock\n             * @sample maps/members/series-addpoint/\n             *         Add a point in Highmaps\n             */\n            addPoint: function(options, redraw, shift, animation) {\n                var series = this,\n                    seriesOptions = series.options,\n                    data = series.data,\n                    chart = series.chart,\n                    xAxis = series.xAxis,\n                    names = xAxis && xAxis.hasNames && xAxis.names,\n                    dataOptions = seriesOptions.data,\n                    point,\n                    isInTheMiddle,\n                    xData = series.xData,\n                    i,\n                    x;\n\n                // Optional redraw, defaults to true\n                redraw = pick(redraw, true);\n\n                // Get options and push the point to xData, yData and series.options. In series.generatePoints\n                // the Point instance will be created on demand and pushed to the series.data array.\n                point = {\n                    series: series\n                };\n                series.pointClass.prototype.applyOptions.apply(point, [options]);\n                x = point.x;\n\n                // Get the insertion point\n                i = xData.length;\n                if (series.requireSorting && x < xData[i - 1]) {\n                    isInTheMiddle = true;\n                    while (i && xData[i - 1] > x) {\n                        i--;\n                    }\n                }\n\n                series.updateParallelArrays(point, 'splice', i, 0, 0); // insert undefined item\n                series.updateParallelArrays(point, i); // update it\n\n                if (names && point.name) {\n                    names[x] = point.name;\n                }\n                dataOptions.splice(i, 0, options);\n\n                if (isInTheMiddle) {\n                    series.data.splice(i, 0, null);\n                    series.processData();\n                }\n\n                // Generate points to be added to the legend (#1329)\n                if (seriesOptions.legendType === 'point') {\n                    series.generatePoints();\n                }\n\n                // Shift the first point off the parallel arrays\n                if (shift) {\n                    if (data[0] && data[0].remove) {\n                        data[0].remove(false);\n                    } else {\n                        data.shift();\n                        series.updateParallelArrays(point, 'shift');\n\n                        dataOptions.shift();\n                    }\n                }\n\n                // redraw\n                series.isDirty = true;\n                series.isDirtyData = true;\n\n                if (redraw) {\n                    chart.redraw(animation); // Animation is set anyway on redraw, #5665\n                }\n            },\n\n            /**\n             * Remove a point from the series. Unlike the {@link Highcharts.Point#remove}\n             * method, this can also be done on a point that is not instanciated because\n             * it is outside the view or subject to Highstock data grouping.\n             *\n             * @param  {Number} i\n             *         The index of the point in the {@link Highcharts.Series.data|data}\n             *         array.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after the point is added. When \n             *         removing more than one point, it is highly recommended that the\n             *         `redraw` option be set to `false`, and instead {@link\n             *         Highcharts.Chart#redraw} is explicitly called after the adding of\n             *         points is finished.\n             * @param  {AnimationOptions} [animation]\n             *         Whether and optionally how the series should be animated.\n             *\n             * @sample highcharts/members/series-removepoint/\n             *         Remove cropped point\n             */\n            removePoint: function(i, redraw, animation) {\n\n                var series = this,\n                    data = series.data,\n                    point = data[i],\n                    points = series.points,\n                    chart = series.chart,\n                    remove = function() {\n\n                        if (points && points.length === data.length) { // #4935\n                            points.splice(i, 1);\n                        }\n                        data.splice(i, 1);\n                        series.options.data.splice(i, 1);\n                        series.updateParallelArrays(point || {\n                            series: series\n                        }, 'splice', i, 1);\n\n                        if (point) {\n                            point.destroy();\n                        }\n\n                        // redraw\n                        series.isDirty = true;\n                        series.isDirtyData = true;\n                        if (redraw) {\n                            chart.redraw();\n                        }\n                    };\n\n                setAnimation(animation, chart);\n                redraw = pick(redraw, true);\n\n                // Fire the event with a default handler of removing the point\n                if (point) {\n                    point.firePointEvent('remove', null, remove);\n                } else {\n                    remove();\n                }\n            },\n\n            /**\n             * Remove a series and optionally redraw the chart.\n             *\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart or wait for an explicit call to\n             *         {@link Highcharts.Chart#redraw}.\n             * @param  {AnimationOptions} [animation]\n             *         Whether to apply animation, and optionally animation\n             *         configuration\n             * @param  {Boolean} [withEvent=true]\n             *         Used internally, whether to fire the series `remove` event.\n             *\n             * @sample highcharts/members/series-remove/\n             *         Remove first series from a button\n             */\n            remove: function(redraw, animation, withEvent) {\n                var series = this,\n                    chart = series.chart;\n\n                function remove() {\n\n                    // Destroy elements\n                    series.destroy();\n\n                    // Redraw\n                    chart.isDirtyLegend = chart.isDirtyBox = true;\n                    chart.linkSeries();\n\n                    if (pick(redraw, true)) {\n                        chart.redraw(animation);\n                    }\n                }\n\n                // Fire the event with a default handler of removing the point\n                if (withEvent !== false) {\n                    fireEvent(series, 'remove', null, remove);\n                } else {\n                    remove();\n                }\n            },\n\n            /**\n             * Update the series with a new set of options. For a clean and precise\n             * handling of new options, all methods and elements from the series are\n             * removed, and it is initiated from scratch. Therefore, this method is more\n             * performance expensive than some other utility methods like {@link\n             * Series#setData} or {@link Series#setVisible}.\n             *\n             * @param  {SeriesOptions} options\n             *         New options that will be merged with the series' existing\n             *         options.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after the series is altered. If doing\n             *         more operations on the chart, it is a good idea to set redraw to\n             *         false and call {@link Chart#redraw} after.\n             *\n             * @sample highcharts/members/series-update/\n             *         Updating series options\n             * @sample maps/members/series-update/\n             *         Update series options in Highmaps\n             */\n            update: function(newOptions, redraw) {\n                var series = this,\n                    chart = series.chart,\n                    // must use user options when changing type because series.options\n                    // is merged in with type specific plotOptions\n                    oldOptions = series.userOptions,\n                    oldType = series.oldType || series.type,\n                    newType = newOptions.type || oldOptions.type || chart.options.chart.type,\n                    proto = seriesTypes[oldType].prototype,\n                    preserve = ['group', 'markerGroup', 'dataLabelsGroup'],\n                    n;\n\n                // Running Series.update to update the data only is an intuitive usage,\n                // so we want to make sure that when used like this, we run the\n                // cheaper setData function and allow animation instead of completely\n                // recreating the series instance.\n                if (Object.keys && Object.keys(newOptions).toString() === 'data') {\n                    return this.setData(newOptions.data, redraw);\n                }\n\n                // If we're changing type or zIndex, create new groups (#3380, #3404)\n                if ((newType && newType !== oldType) || newOptions.zIndex !== undefined) {\n                    preserve.length = 0;\n                }\n\n                // Make sure groups are not destroyed (#3094)\n                each(preserve, function(prop) {\n                    preserve[prop] = series[prop];\n                    delete series[prop];\n                });\n\n                // Do the merge, with some forced options\n                newOptions = merge(oldOptions, {\n                    animation: false,\n                    index: series.index,\n                    pointStart: series.xData[0] // when updating after addPoint\n                }, {\n                    data: series.options.data\n                }, newOptions);\n\n                // Destroy the series and delete all properties. Reinsert all methods\n                // and properties from the new type prototype (#2270, #3719)\n                series.remove(false, null, false);\n                for (n in proto) {\n                    series[n] = undefined;\n                }\n                extend(series, seriesTypes[newType || oldType].prototype);\n\n                // Re-register groups (#3094)\n                each(preserve, function(prop) {\n                    series[prop] = preserve[prop];\n                });\n\n                series.init(chart, newOptions);\n                series.oldType = oldType;\n                chart.linkSeries(); // Links are lost in series.remove (#3028)\n                if (pick(redraw, true)) {\n                    chart.redraw(false);\n                }\n            }\n        });\n\n        // Extend the Axis.prototype for dynamic methods\n        extend(Axis.prototype, /** @lends Highcharts.Axis.prototype */ {\n\n            /**\n             * Update an axis object with a new set of options. The options are merged\n             * with the existing options, so only new or altered options need to be\n             * specified.\n             *\n             * @param  {Object} options\n             *         The new options that will be merged in with existing options on\n             *         the axis.\n             * @sample highcharts/members/axis-update/ Axis update demo\n             */\n            update: function(options, redraw) {\n                var chart = this.chart;\n\n                options = chart.options[this.coll][this.options.index] =\n                    merge(this.userOptions, options);\n\n                this.destroy(true);\n\n                this.init(chart, extend(options, {\n                    events: undefined\n                }));\n\n                chart.isDirtyBox = true;\n                if (pick(redraw, true)) {\n                    chart.redraw();\n                }\n            },\n\n            /**\n             * Remove the axis from the chart.\n             *\n             * @param {Boolean} [redraw=true] Whether to redraw the chart following the\n             * remove.\n             *\n             * @sample highcharts/members/chart-addaxis/ Add and remove axes\n             */\n            remove: function(redraw) {\n                var chart = this.chart,\n                    key = this.coll, // xAxis or yAxis\n                    axisSeries = this.series,\n                    i = axisSeries.length;\n\n                // Remove associated series (#2687)\n                while (i--) {\n                    if (axisSeries[i]) {\n                        axisSeries[i].remove(false);\n                    }\n                }\n\n                // Remove the axis\n                erase(chart.axes, this);\n                erase(chart[key], this);\n\n                if (isArray(chart.options[key])) {\n                    chart.options[key].splice(this.options.index, 1);\n                } else { // color axis, #6488\n                    delete chart.options[key];\n                }\n\n                each(chart[key], function(axis, i) { // Re-index, #1706\n                    axis.options.index = i;\n                });\n                this.destroy();\n                chart.isDirtyBox = true;\n\n                if (pick(redraw, true)) {\n                    chart.redraw();\n                }\n            },\n\n            /**\n             * Update the axis title by options after render time.\n             *\n             * @param  {TitleOptions} titleOptions\n             *         The additional title options.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after setting the title.\n             * @sample highcharts/members/axis-settitle/ Set a new Y axis title\n             */\n            setTitle: function(titleOptions, redraw) {\n                this.update({\n                    title: titleOptions\n                }, redraw);\n            },\n\n            /**\n             * Set new axis categories and optionally redraw.\n             * @param {Array.<String>} categories - The new categories.\n             * @param {Boolean} [redraw=true] - Whether to redraw the chart.\n             * @sample highcharts/members/axis-setcategories/ Set categories by click on\n             * a button\n             */\n            setCategories: function(categories, redraw) {\n                this.update({\n                    categories: categories\n                }, redraw);\n            }\n\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var color = H.color,\n            each = H.each,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            map = H.map,\n            pick = H.pick,\n            Series = H.Series,\n            seriesType = H.seriesType;\n\n        /**\n         * Area series type.\n         * @constructor seriesTypes.area\n         * @extends {Series}\n         */\n        seriesType('area', 'line', {\n            softThreshold: false,\n            threshold: 0\n            // trackByArea: false,\n            // lineColor: null, // overrides color, but lets fillColor be unaltered\n            // fillOpacity: 0.75,\n            // fillColor: null\n        }, /** @lends seriesTypes.area.prototype */ {\n            singleStacks: false,\n            /** \n             * Return an array of stacked points, where null and missing points are replaced by \n             * dummy points in order for gaps to be drawn correctly in stacks.\n             */\n            getStackPoints: function() {\n                var series = this,\n                    segment = [],\n                    keys = [],\n                    xAxis = this.xAxis,\n                    yAxis = this.yAxis,\n                    stack = yAxis.stacks[this.stackKey],\n                    pointMap = {},\n                    points = this.points,\n                    seriesIndex = series.index,\n                    yAxisSeries = yAxis.series,\n                    seriesLength = yAxisSeries.length,\n                    visibleSeries,\n                    upOrDown = pick(yAxis.options.reversedStacks, true) ? 1 : -1,\n                    i;\n\n                if (this.options.stacking) {\n                    // Create a map where we can quickly look up the points by their X value.\n                    for (i = 0; i < points.length; i++) {\n                        pointMap[points[i].x] = points[i];\n                    }\n\n                    // Sort the keys (#1651)\n                    H.objectEach(stack, function(stackX, x) {\n                        if (stackX.total !== null) { // nulled after switching between grouping and not (#1651, #2336)\n                            keys.push(x);\n                        }\n                    });\n                    keys.sort(function(a, b) {\n                        return a - b;\n                    });\n\n                    visibleSeries = map(yAxisSeries, function() {\n                        return this.visible;\n                    });\n\n                    each(keys, function(x, idx) {\n                        var y = 0,\n                            stackPoint,\n                            stackedValues;\n\n                        if (pointMap[x] && !pointMap[x].isNull) {\n                            segment.push(pointMap[x]);\n\n                            // Find left and right cliff. -1 goes left, 1 goes right.\n                            each([-1, 1], function(direction) {\n                                var nullName = direction === 1 ? 'rightNull' : 'leftNull',\n                                    cliffName = direction === 1 ? 'rightCliff' : 'leftCliff',\n                                    cliff = 0,\n                                    otherStack = stack[keys[idx + direction]];\n\n                                // If there is a stack next to this one, to the left or to the right...\n                                if (otherStack) {\n                                    i = seriesIndex;\n                                    while (i >= 0 && i < seriesLength) { // Can go either up or down, depending on reversedStacks\n                                        stackPoint = otherStack.points[i];\n                                        if (!stackPoint) {\n                                            // If the next point in this series is missing, mark the point\n                                            // with point.leftNull or point.rightNull = true.\n                                            if (i === seriesIndex) {\n                                                pointMap[x][nullName] = true;\n\n                                                // If there are missing points in the next stack in any of the \n                                                // series below this one, we need to substract the missing values\n                                                // and add a hiatus to the left or right.\n                                            } else if (visibleSeries[i]) {\n                                                stackedValues = stack[x].points[i];\n                                                if (stackedValues) {\n                                                    cliff -= stackedValues[1] - stackedValues[0];\n                                                }\n                                            }\n                                        }\n                                        // When reversedStacks is true, loop up, else loop down\n                                        i += upOrDown;\n                                    }\n                                }\n                                pointMap[x][cliffName] = cliff;\n                            });\n\n\n                            // There is no point for this X value in this series, so we \n                            // insert a dummy point in order for the areas to be drawn\n                            // correctly.\n                        } else {\n\n                            // Loop down the stack to find the series below this one that has\n                            // a value (#1991)\n                            i = seriesIndex;\n                            while (i >= 0 && i < seriesLength) {\n                                stackPoint = stack[x].points[i];\n                                if (stackPoint) {\n                                    y = stackPoint[1];\n                                    break;\n                                }\n                                // When reversedStacks is true, loop up, else loop down\n                                i += upOrDown;\n                            }\n                            y = yAxis.translate(y, 0, 1, 0, 1); // #6272\n                            segment.push({\n                                isNull: true,\n                                plotX: xAxis.translate(x, 0, 0, 0, 1), // #6272\n                                x: x,\n                                plotY: y,\n                                yBottom: y\n                            });\n                        }\n                    });\n\n                }\n\n                return segment;\n            },\n\n            getGraphPath: function(points) {\n                var getGraphPath = Series.prototype.getGraphPath,\n                    graphPath,\n                    options = this.options,\n                    stacking = options.stacking,\n                    yAxis = this.yAxis,\n                    topPath,\n                    //topPoints = [],\n                    bottomPath,\n                    bottomPoints = [],\n                    graphPoints = [],\n                    seriesIndex = this.index,\n                    i,\n                    areaPath,\n                    plotX,\n                    stacks = yAxis.stacks[this.stackKey],\n                    threshold = options.threshold,\n                    translatedThreshold = yAxis.getThreshold(options.threshold),\n                    isNull,\n                    yBottom,\n                    connectNulls = options.connectNulls || stacking === 'percent',\n                    /**\n                     * To display null points in underlying stacked series, this series graph must be \n                     * broken, and the area also fall down to fill the gap left by the null point. #2069\n                     */\n                    addDummyPoints = function(i, otherI, side) {\n                        var point = points[i],\n                            stackedValues = stacking && stacks[point.x].points[seriesIndex],\n                            nullVal = point[side + 'Null'] || 0,\n                            cliffVal = point[side + 'Cliff'] || 0,\n                            top,\n                            bottom,\n                            isNull = true;\n\n                        if (cliffVal || nullVal) {\n\n                            top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;\n                            bottom = stackedValues[0] + cliffVal;\n                            isNull = !!nullVal;\n\n                        } else if (!stacking && points[otherI] && points[otherI].isNull) {\n                            top = bottom = threshold;\n                        }\n\n                        // Add to the top and bottom line of the area\n                        if (top !== undefined) {\n                            graphPoints.push({\n                                plotX: plotX,\n                                plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),\n                                isNull: isNull,\n                                isCliff: true\n                            });\n                            bottomPoints.push({\n                                plotX: plotX,\n                                plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),\n                                doCurve: false // #1041, gaps in areaspline areas\n                            });\n                        }\n                    };\n\n                // Find what points to use\n                points = points || this.points;\n\n                // Fill in missing points\n                if (stacking) {\n                    points = this.getStackPoints();\n                }\n\n                for (i = 0; i < points.length; i++) {\n                    isNull = points[i].isNull;\n                    plotX = pick(points[i].rectPlotX, points[i].plotX);\n                    yBottom = pick(points[i].yBottom, translatedThreshold);\n\n                    if (!isNull || connectNulls) {\n\n                        if (!connectNulls) {\n                            addDummyPoints(i, i - 1, 'left');\n                        }\n\n                        if (!(isNull && !stacking && connectNulls)) { // Skip null point when stacking is false and connectNulls true\n                            graphPoints.push(points[i]);\n                            bottomPoints.push({\n                                x: i,\n                                plotX: plotX,\n                                plotY: yBottom\n                            });\n                        }\n\n                        if (!connectNulls) {\n                            addDummyPoints(i, i + 1, 'right');\n                        }\n                    }\n                }\n\n                topPath = getGraphPath.call(this, graphPoints, true, true);\n\n                bottomPoints.reversed = true;\n                bottomPath = getGraphPath.call(this, bottomPoints, true, true);\n                if (bottomPath.length) {\n                    bottomPath[0] = 'L';\n                }\n\n                areaPath = topPath.concat(bottomPath);\n                graphPath = getGraphPath.call(this, graphPoints, false, connectNulls); // TODO: don't set leftCliff and rightCliff when connectNulls?\n\n                areaPath.xMap = topPath.xMap;\n                this.areaPath = areaPath;\n\n                return graphPath;\n            },\n\n            /**\n             * Draw the graph and the underlying area. This method calls the Series base\n             * function and adds the area. The areaPath is calculated in the getSegmentPath\n             * method called from Series.prototype.drawGraph.\n             */\n            drawGraph: function() {\n\n                // Define or reset areaPath\n                this.areaPath = [];\n\n                // Call the base method\n                Series.prototype.drawGraph.apply(this);\n\n                // Define local variables\n                var series = this,\n                    areaPath = this.areaPath,\n                    options = this.options,\n                    zones = this.zones,\n                    props = [\n                        [\n                            'area',\n                            'highcharts-area',\n\n                            this.color,\n                            options.fillColor\n\n                        ]\n                    ]; // area name, main color, fill color\n\n                each(zones, function(zone, i) {\n                    props.push([\n                        'zone-area-' + i,\n                        'highcharts-area highcharts-zone-area-' + i + ' ' + zone.className,\n\n                        zone.color || series.color,\n                        zone.fillColor || options.fillColor\n\n                    ]);\n                });\n\n                each(props, function(prop) {\n                    var areaKey = prop[0],\n                        area = series[areaKey];\n\n                    // Create or update the area\n                    if (area) { // update\n                        area.endX = areaPath.xMap;\n                        area.animate({\n                            d: areaPath\n                        });\n\n                    } else { // create\n                        area = series[areaKey] = series.chart.renderer.path(areaPath)\n                            .addClass(prop[1])\n                            .attr({\n\n                                fill: pick(\n                                    prop[3],\n                                    color(prop[2]).setOpacity(pick(options.fillOpacity, 0.75)).get()\n                                ),\n\n                                zIndex: 0 // #1069\n                            }).add(series.group);\n                        area.isArea = true;\n                    }\n                    area.startX = areaPath.xMap;\n                    area.shiftUnit = options.step ? 2 : 1;\n                });\n            },\n\n            drawLegendSymbol: LegendSymbolMixin.drawRectangle\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var pick = H.pick,\n            seriesType = H.seriesType;\n\n        /**\n         * Spline series type.\n         * @constructor seriesTypes.spline\n         * @extends {Series}\n         */\n        seriesType('spline', 'line', {}, /** @lends seriesTypes.spline.prototype */ {\n            /**\n             * Get the spline segment from a given point's previous neighbour to the given point\n             */\n            getPointSpline: function(points, point, i) {\n                var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc\n                    denom = smoothing + 1,\n                    plotX = point.plotX,\n                    plotY = point.plotY,\n                    lastPoint = points[i - 1],\n                    nextPoint = points[i + 1],\n                    leftContX,\n                    leftContY,\n                    rightContX,\n                    rightContY,\n                    ret;\n\n                function doCurve(otherPoint) {\n                    return otherPoint &&\n                        !otherPoint.isNull &&\n                        otherPoint.doCurve !== false &&\n                        !point.isCliff; // #6387, area splines next to null\n                }\n\n                // Find control points\n                if (doCurve(lastPoint) && doCurve(nextPoint)) {\n                    var lastX = lastPoint.plotX,\n                        lastY = lastPoint.plotY,\n                        nextX = nextPoint.plotX,\n                        nextY = nextPoint.plotY,\n                        correction = 0;\n\n                    leftContX = (smoothing * plotX + lastX) / denom;\n                    leftContY = (smoothing * plotY + lastY) / denom;\n                    rightContX = (smoothing * plotX + nextX) / denom;\n                    rightContY = (smoothing * plotY + nextY) / denom;\n\n                    // Have the two control points make a straight line through main point\n                    if (rightContX !== leftContX) { // #5016, division by zero\n                        correction = ((rightContY - leftContY) * (rightContX - plotX)) /\n                            (rightContX - leftContX) + plotY - rightContY;\n                    }\n\n                    leftContY += correction;\n                    rightContY += correction;\n\n                    // to prevent false extremes, check that control points are between\n                    // neighbouring points' y values\n                    if (leftContY > lastY && leftContY > plotY) {\n                        leftContY = Math.max(lastY, plotY);\n                        rightContY = 2 * plotY - leftContY; // mirror of left control point\n                    } else if (leftContY < lastY && leftContY < plotY) {\n                        leftContY = Math.min(lastY, plotY);\n                        rightContY = 2 * plotY - leftContY;\n                    }\n                    if (rightContY > nextY && rightContY > plotY) {\n                        rightContY = Math.max(nextY, plotY);\n                        leftContY = 2 * plotY - rightContY;\n                    } else if (rightContY < nextY && rightContY < plotY) {\n                        rightContY = Math.min(nextY, plotY);\n                        leftContY = 2 * plotY - rightContY;\n                    }\n\n                    // record for drawing in next point\n                    point.rightContX = rightContX;\n                    point.rightContY = rightContY;\n\n\n                }\n\n                // Visualize control points for debugging\n                /*\n                if (leftContX) {\n                \tthis.chart.renderer.circle(leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop, 2)\n                \t\t.attr({\n                \t\t\tstroke: 'red',\n                \t\t\t'stroke-width': 2,\n                \t\t\tfill: 'none',\n                \t\t\tzIndex: 9\n                \t\t})\n                \t\t.add();\n                \tthis.chart.renderer.path(['M', leftContX + this.chart.plotLeft, leftContY + this.chart.plotTop,\n                \t\t'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n                \t\t.attr({\n                \t\t\tstroke: 'red',\n                \t\t\t'stroke-width': 2,\n                \t\t\tzIndex: 9\n                \t\t})\n                \t\t.add();\n                }\n                if (rightContX) {\n                \tthis.chart.renderer.circle(rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop, 2)\n                \t\t.attr({\n                \t\t\tstroke: 'green',\n                \t\t\t'stroke-width': 2,\n                \t\t\tfill: 'none',\n                \t\t\tzIndex: 9\n                \t\t})\n                \t\t.add();\n                \tthis.chart.renderer.path(['M', rightContX + this.chart.plotLeft, rightContY + this.chart.plotTop,\n                \t\t'L', plotX + this.chart.plotLeft, plotY + this.chart.plotTop])\n                \t\t.attr({\n                \t\t\tstroke: 'green',\n                \t\t\t'stroke-width': 2,\n                \t\t\tzIndex: 9\n                \t\t})\n                \t\t.add();\n                }\n                // */\n                ret = [\n                    'C',\n                    pick(lastPoint.rightContX, lastPoint.plotX),\n                    pick(lastPoint.rightContY, lastPoint.plotY),\n                    pick(leftContX, plotX),\n                    pick(leftContY, plotY),\n                    plotX,\n                    plotY\n                ];\n                lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later\n                return ret;\n            }\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var areaProto = H.seriesTypes.area.prototype,\n            defaultPlotOptions = H.defaultPlotOptions,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            seriesType = H.seriesType;\n        /**\n         * AreaSplineSeries object\n         */\n        seriesType('areaspline', 'spline', defaultPlotOptions.area, {\n            getStackPoints: areaProto.getStackPoints,\n            getGraphPath: areaProto.getGraphPath,\n            setStackCliffs: areaProto.setStackCliffs,\n            drawGraph: areaProto.drawGraph,\n            drawLegendSymbol: LegendSymbolMixin.drawRectangle\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var animObject = H.animObject,\n            color = H.color,\n            each = H.each,\n            extend = H.extend,\n            isNumber = H.isNumber,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            Series = H.Series,\n            seriesType = H.seriesType,\n            svg = H.svg;\n        /**\n         * The column series type.\n         *\n         * @constructor seriesTypes.column\n         * @augments Series\n         */\n        seriesType('column', 'line', {\n            borderRadius: 0,\n            //colorByPoint: undefined,\n            crisp: true,\n            groupPadding: 0.2,\n            //grouping: true,\n            marker: null, // point options are specified in the base options\n            pointPadding: 0.1,\n            //pointWidth: null,\n            minPointLength: 0,\n            cropThreshold: 50, // when there are more points, they will not animate out of the chart on xAxis.setExtremes\n            pointRange: null, // null means auto, meaning 1 in a categorized axis and least distance between points if not categories\n            states: {\n                hover: {\n                    halo: false,\n\n                    brightness: 0.1,\n                    shadow: false\n\n                },\n\n                select: {\n                    color: '#cccccc',\n                    borderColor: '#000000',\n                    shadow: false\n                }\n\n            },\n            dataLabels: {\n                align: null, // auto\n                verticalAlign: null, // auto\n                y: null\n            },\n            softThreshold: false,\n            startFromThreshold: true, // false doesn't work well: http://jsfiddle.net/highcharts/hz8fopan/14/\n            stickyTracking: false,\n            tooltip: {\n                distance: 6\n            },\n            threshold: 0,\n\n            borderColor: '#ffffff'\n            // borderWidth: 1\n\n\n        }, /** @lends seriesTypes.column.prototype */ {\n            cropShoulder: 0,\n            directTouch: true, // When tooltip is not shared, this series (and derivatives) requires direct touch/hover. KD-tree does not apply.\n            trackerGroups: ['group', 'dataLabelsGroup'],\n            negStacks: true, // use separate negative stacks, unlike area stacks where a negative\n            // point is substracted from previous (#1910)\n\n            /**\n             * Initialize the series. Extends the basic Series.init method by\n             * marking other series of the same type as dirty.\n             *\n             * @function #init\n             * @memberOf seriesTypes.column\n             * @returns {void}\n             */\n            init: function() {\n                Series.prototype.init.apply(this, arguments);\n\n                var series = this,\n                    chart = series.chart;\n\n                // if the series is added dynamically, force redraw of other\n                // series affected by a new column\n                if (chart.hasRendered) {\n                    each(chart.series, function(otherSeries) {\n                        if (otherSeries.type === series.type) {\n                            otherSeries.isDirty = true;\n                        }\n                    });\n                }\n            },\n\n            /**\n             * Return the width and x offset of the columns adjusted for grouping, groupPadding, pointPadding,\n             * pointWidth etc.\n             */\n            getColumnMetrics: function() {\n\n                var series = this,\n                    options = series.options,\n                    xAxis = series.xAxis,\n                    yAxis = series.yAxis,\n                    reversedXAxis = xAxis.reversed,\n                    stackKey,\n                    stackGroups = {},\n                    columnCount = 0;\n\n                // Get the total number of column type series.\n                // This is called on every series. Consider moving this logic to a\n                // chart.orderStacks() function and call it on init, addSeries and removeSeries\n                if (options.grouping === false) {\n                    columnCount = 1;\n                } else {\n                    each(series.chart.series, function(otherSeries) {\n                        var otherOptions = otherSeries.options,\n                            otherYAxis = otherSeries.yAxis,\n                            columnIndex;\n                        if (\n                            otherSeries.type === series.type &&\n                            (\n                                otherSeries.visible ||\n                                !series.chart.options.chart.ignoreHiddenSeries\n                            ) &&\n                            yAxis.len === otherYAxis.len &&\n                            yAxis.pos === otherYAxis.pos\n                        ) { // #642, #2086\n                            if (otherOptions.stacking) {\n                                stackKey = otherSeries.stackKey;\n                                if (stackGroups[stackKey] === undefined) {\n                                    stackGroups[stackKey] = columnCount++;\n                                }\n                                columnIndex = stackGroups[stackKey];\n                            } else if (otherOptions.grouping !== false) { // #1162\n                                columnIndex = columnCount++;\n                            }\n                            otherSeries.columnIndex = columnIndex;\n                        }\n                    });\n                }\n\n                var categoryWidth = Math.min(\n                        Math.abs(xAxis.transA) * (xAxis.ordinalSlope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1), // #2610\n                        xAxis.len // #1535\n                    ),\n                    groupPadding = categoryWidth * options.groupPadding,\n                    groupWidth = categoryWidth - 2 * groupPadding,\n                    pointOffsetWidth = groupWidth / (columnCount || 1),\n                    pointWidth = Math.min(\n                        options.maxPointWidth || xAxis.len,\n                        pick(options.pointWidth, pointOffsetWidth * (1 - 2 * options.pointPadding))\n                    ),\n                    pointPadding = (pointOffsetWidth - pointWidth) / 2,\n                    colIndex = (series.columnIndex || 0) + (reversedXAxis ? 1 : 0), // #1251, #3737\n                    pointXOffset = pointPadding + (groupPadding + colIndex *\n                        pointOffsetWidth - (categoryWidth / 2)) *\n                    (reversedXAxis ? -1 : 1);\n\n                // Save it for reading in linked series (Error bars particularly)\n                series.columnMetrics = {\n                    width: pointWidth,\n                    offset: pointXOffset\n                };\n                return series.columnMetrics;\n\n            },\n\n            /**\n             * Make the columns crisp. The edges are rounded to the nearest full pixel.\n             */\n            crispCol: function(x, y, w, h) {\n                var chart = this.chart,\n                    borderWidth = this.borderWidth,\n                    xCrisp = -(borderWidth % 2 ? 0.5 : 0),\n                    yCrisp = borderWidth % 2 ? 0.5 : 1,\n                    right,\n                    bottom,\n                    fromTop;\n\n                if (chart.inverted && chart.renderer.isVML) {\n                    yCrisp += 1;\n                }\n\n                // Horizontal. We need to first compute the exact right edge, then round it\n                // and compute the width from there.\n                if (this.options.crisp) {\n                    right = Math.round(x + w) + xCrisp;\n                    x = Math.round(x) + xCrisp;\n                    w = right - x;\n                }\n\n                // Vertical\n                bottom = Math.round(y + h) + yCrisp;\n                fromTop = Math.abs(y) <= 0.5 && bottom > 0.5; // #4504, #4656\n                y = Math.round(y) + yCrisp;\n                h = bottom - y;\n\n                // Top edges are exceptions\n                if (fromTop && h) { // #5146\n                    y -= 1;\n                    h += 1;\n                }\n\n                return {\n                    x: x,\n                    y: y,\n                    width: w,\n                    height: h\n                };\n            },\n\n            /**\n             * Translate each point to the plot area coordinate system and find shape positions\n             */\n            translate: function() {\n                var series = this,\n                    chart = series.chart,\n                    options = series.options,\n                    dense = series.dense = series.closestPointRange * series.xAxis.transA < 2,\n                    borderWidth = series.borderWidth = pick(\n                        options.borderWidth,\n                        dense ? 0 : 1 // #3635\n                    ),\n                    yAxis = series.yAxis,\n                    threshold = options.threshold,\n                    translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold),\n                    minPointLength = pick(options.minPointLength, 5),\n                    metrics = series.getColumnMetrics(),\n                    pointWidth = metrics.width,\n                    seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth), // postprocessed for border width\n                    pointXOffset = series.pointXOffset = metrics.offset;\n\n                if (chart.inverted) {\n                    translatedThreshold -= 0.5; // #3355\n                }\n\n                // When the pointPadding is 0, we want the columns to be packed tightly, so we allow individual\n                // columns to have individual sizes. When pointPadding is greater, we strive for equal-width\n                // columns (#2694).\n                if (options.pointPadding) {\n                    seriesBarW = Math.ceil(seriesBarW);\n                }\n\n                Series.prototype.translate.apply(series);\n\n                // Record the new values\n                each(series.points, function(point) {\n                    var yBottom = pick(point.yBottom, translatedThreshold),\n                        safeDistance = 999 + Math.abs(yBottom),\n                        plotY = Math.min(Math.max(-safeDistance, point.plotY), yAxis.len + safeDistance), // Don't draw too far outside plot area (#1303, #2241, #4264)\n                        barX = point.plotX + pointXOffset,\n                        barW = seriesBarW,\n                        barY = Math.min(plotY, yBottom),\n                        up,\n                        barH = Math.max(plotY, yBottom) - barY;\n\n                    // Handle options.minPointLength\n                    if (Math.abs(barH) < minPointLength) {\n                        if (minPointLength) {\n                            barH = minPointLength;\n                            up = (!yAxis.reversed && !point.negative) || (yAxis.reversed && point.negative);\n                            barY = Math.abs(barY - translatedThreshold) > minPointLength ? // stacked\n                                yBottom - minPointLength : // keep position\n                                translatedThreshold - (up ? minPointLength : 0); // #1485, #4051\n                        }\n                    }\n\n                    // Cache for access in polar\n                    point.barX = barX;\n                    point.pointWidth = pointWidth;\n\n                    // Fix the tooltip on center of grouped columns (#1216, #424, #3648)\n                    point.tooltipPos = chart.inverted ? [yAxis.len + yAxis.pos - chart.plotLeft - plotY, series.xAxis.len - barX - barW / 2, barH] : [barX + barW / 2, plotY + yAxis.pos - chart.plotTop, barH];\n\n                    // Register shape type and arguments to be used in drawPoints\n                    point.shapeType = 'rect';\n                    point.shapeArgs = series.crispCol.apply(\n                        series,\n                        point.isNull ?\n                        // #3169, drilldown from null must have a position to work from\n                        // #6585, dataLabel should be placed on xAxis, not floating in the middle of the chart\n                        [barX, translatedThreshold, barW, 0] : [barX, barY, barW, barH]\n                    );\n                });\n\n            },\n\n            getSymbol: noop,\n\n            /**\n             * Use a solid rectangle like the area series types\n             */\n            drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n\n            /**\n             * Columns have no graph\n             */\n            drawGraph: function() {\n                this.group[this.dense ? 'addClass' : 'removeClass']('highcharts-dense-data');\n            },\n\n\n            /**\n             * Get presentational attributes\n             */\n            pointAttribs: function(point, state) {\n                var options = this.options,\n                    stateOptions,\n                    ret,\n                    p2o = this.pointAttrToOptions || {},\n                    strokeOption = p2o.stroke || 'borderColor',\n                    strokeWidthOption = p2o['stroke-width'] || 'borderWidth',\n                    fill = (point && point.color) || this.color,\n                    stroke = point[strokeOption] || options[strokeOption] ||\n                    this.color || fill, // set to fill when borderColor null\n                    strokeWidth = point[strokeWidthOption] ||\n                    options[strokeWidthOption] || this[strokeWidthOption] || 0,\n                    dashstyle = options.dashStyle,\n                    zone,\n                    brightness;\n\n                // Handle zone colors\n                if (point && this.zones.length) {\n                    zone = point.getZone();\n                    fill = point.options.color || (zone && zone.color) || this.color; // When zones are present, don't use point.color (#4267). Changed order (#6527)\n                }\n\n                // Select or hover states\n                if (state) {\n                    stateOptions = merge(\n                        options.states[state],\n                        point.options.states && point.options.states[state] || {} // #6401\n                    );\n                    brightness = stateOptions.brightness;\n                    fill = stateOptions.color ||\n                        (brightness !== undefined && color(fill).brighten(stateOptions.brightness).get()) ||\n                        fill;\n                    stroke = stateOptions[strokeOption] || stroke;\n                    strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;\n                    dashstyle = stateOptions.dashStyle || dashstyle;\n                }\n\n                ret = {\n                    'fill': fill,\n                    'stroke': stroke,\n                    'stroke-width': strokeWidth\n                };\n                if (options.borderRadius) {\n                    ret.r = options.borderRadius;\n                }\n\n                if (dashstyle) {\n                    ret.dashstyle = dashstyle;\n                }\n\n                return ret;\n            },\n\n\n            /**\n             * Draw the columns. For bars, the series.group is rotated, so the same coordinates\n             * apply for columns and bars. This method is inherited by scatter series.\n             *\n             */\n            drawPoints: function() {\n                var series = this,\n                    chart = this.chart,\n                    options = series.options,\n                    renderer = chart.renderer,\n                    animationLimit = options.animationLimit || 250,\n                    shapeArgs;\n\n                // draw the columns\n                each(series.points, function(point) {\n                    var plotY = point.plotY,\n                        graphic = point.graphic;\n\n                    if (isNumber(plotY) && point.y !== null) {\n                        shapeArgs = point.shapeArgs;\n\n                        if (graphic) { // update\n                            graphic[chart.pointCount < animationLimit ? 'animate' : 'attr'](\n                                merge(shapeArgs)\n                            );\n\n                        } else {\n                            point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n                                .add(point.group || series.group);\n                        }\n\n\n                        // Presentational\n                        graphic\n                            .attr(series.pointAttribs(point, point.selected && 'select'))\n                            .shadow(options.shadow, null, options.stacking && !options.borderRadius);\n\n\n                        graphic.addClass(point.getClassName(), true);\n\n\n                    } else if (graphic) {\n                        point.graphic = graphic.destroy(); // #1269\n                    }\n                });\n            },\n\n            /**\n             * Animate the column heights one by one from zero\n             * @param {Boolean} init Whether to initialize the animation or run it\n             */\n            animate: function(init) {\n                var series = this,\n                    yAxis = this.yAxis,\n                    options = series.options,\n                    inverted = this.chart.inverted,\n                    attr = {},\n                    translatedThreshold;\n\n                if (svg) { // VML is too slow anyway\n                    if (init) {\n                        attr.scaleY = 0.001;\n                        translatedThreshold = Math.min(yAxis.pos + yAxis.len, Math.max(yAxis.pos, yAxis.toPixels(options.threshold)));\n                        if (inverted) {\n                            attr.translateX = translatedThreshold - yAxis.len;\n                        } else {\n                            attr.translateY = translatedThreshold;\n                        }\n                        series.group.attr(attr);\n\n                    } else { // run the animation\n\n                        attr[inverted ? 'translateX' : 'translateY'] = yAxis.pos;\n                        series.group.animate(attr, extend(animObject(series.options.animation), {\n                            // Do the scale synchronously to ensure smooth updating (#5030)\n                            step: function(val, fx) {\n                                series.group.attr({\n                                    scaleY: Math.max(0.001, fx.pos) // #5250\n                                });\n                            }\n                        }));\n\n                        // delete this function to allow it only once\n                        series.animate = null;\n                    }\n                }\n            },\n\n            /**\n             * Remove this series from the chart\n             */\n            remove: function() {\n                var series = this,\n                    chart = series.chart;\n\n                // column and bar series affects other series of the same type\n                // as they are either stacked or grouped\n                if (chart.hasRendered) {\n                    each(chart.series, function(otherSeries) {\n                        if (otherSeries.type === series.type) {\n                            otherSeries.isDirty = true;\n                        }\n                    });\n                }\n\n                Series.prototype.remove.apply(series, arguments);\n            }\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n\n        var seriesType = H.seriesType;\n\n        /**\n         * The Bar series class\n         */\n        seriesType('bar', 'column', null, {\n            inverted: true\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var Series = H.Series,\n            seriesType = H.seriesType;\n        /**\n         * The scatter series type\n         */\n        seriesType('scatter', 'line', {\n            lineWidth: 0,\n            findNearestPointBy: 'xy',\n            marker: {\n                enabled: true // Overrides auto-enabling in line series (#3647)\n            },\n            tooltip: {\n\n                headerFormat: '<span style=\"color:{point.color}\">\\u25CF</span> ' +\n                    '<span style=\"font-size: 0.85em\"> {series.name}</span><br/>',\n\n                pointFormat: 'x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>'\n            }\n\n            // Prototype members\n        }, {\n            sorted: false,\n            requireSorting: false,\n            noSharedTooltip: true,\n            trackerGroups: ['group', 'markerGroup', 'dataLabelsGroup'],\n            takeOrdinalPosition: false, // #2342\n            drawGraph: function() {\n                if (this.options.lineWidth) {\n                    Series.prototype.drawGraph.call(this);\n                }\n            }\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var pick = H.pick,\n            relativeLength = H.relativeLength;\n\n        H.CenteredSeriesMixin = {\n            /**\n             * Get the center of the pie based on the size and center options relative to the\n             * plot area. Borrowed by the polar and gauge series types.\n             */\n            getCenter: function() {\n\n                var options = this.options,\n                    chart = this.chart,\n                    slicingRoom = 2 * (options.slicedOffset || 0),\n                    handleSlicingRoom,\n                    plotWidth = chart.plotWidth - 2 * slicingRoom,\n                    plotHeight = chart.plotHeight - 2 * slicingRoom,\n                    centerOption = options.center,\n                    positions = [pick(centerOption[0], '50%'), pick(centerOption[1], '50%'), options.size || '100%', options.innerSize || 0],\n                    smallestSize = Math.min(plotWidth, plotHeight),\n                    i,\n                    value;\n\n                for (i = 0; i < 4; ++i) {\n                    value = positions[i];\n                    handleSlicingRoom = i < 2 || (i === 2 && /%$/.test(value));\n\n                    // i == 0: centerX, relative to width\n                    // i == 1: centerY, relative to height\n                    // i == 2: size, relative to smallestSize\n                    // i == 3: innerSize, relative to size\n                    positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) +\n                        (handleSlicingRoom ? slicingRoom : 0);\n\n                }\n                // innerSize cannot be larger than size (#3632)\n                if (positions[3] > positions[2]) {\n                    positions[3] = positions[2];\n                }\n                return positions;\n            }\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            CenteredSeriesMixin = H.CenteredSeriesMixin,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            inArray = H.inArray,\n            LegendSymbolMixin = H.LegendSymbolMixin,\n            noop = H.noop,\n            pick = H.pick,\n            Point = H.Point,\n            Series = H.Series,\n            seriesType = H.seriesType,\n            seriesTypes = H.seriesTypes,\n            setAnimation = H.setAnimation;\n\n        /**\n         * The pie series type.\n         *\n         * @constructor seriesTypes.pie\n         * @augments Series\n         */\n        seriesType('pie', 'line', {\n            center: [null, null],\n            clip: false,\n            colorByPoint: true, // always true for pies\n            dataLabels: {\n                // align: null,\n                // connectorWidth: 1,\n                // connectorColor: point.color,\n                // connectorPadding: 5,\n                distance: 30,\n                enabled: true,\n                formatter: function() { // #2945\n                    return this.point.isNull ? undefined : this.point.name;\n                },\n                // softConnector: true,\n                x: 0\n                // y: 0\n            },\n            ignoreHiddenPoint: true,\n            //innerSize: 0,\n            legendType: 'point',\n            marker: null, // point options are specified in the base options\n            size: null,\n            showInLegend: false,\n            slicedOffset: 10,\n            stickyTracking: false,\n            tooltip: {\n                followPointer: true\n            },\n\n            borderColor: '#ffffff',\n            borderWidth: 1,\n            states: {\n                hover: {\n                    brightness: 0.1,\n                    shadow: false\n                }\n            }\n\n\n        }, /** @lends seriesTypes.pie.prototype */ {\n            isCartesian: false,\n            requireSorting: false,\n            directTouch: true,\n            noSharedTooltip: true,\n            trackerGroups: ['group', 'dataLabelsGroup'],\n            axisTypes: [],\n            pointAttribs: seriesTypes.column.prototype.pointAttribs,\n            /**\n             * Animate the pies in\n             */\n            animate: function(init) {\n                var series = this,\n                    points = series.points,\n                    startAngleRad = series.startAngleRad;\n\n                if (!init) {\n                    each(points, function(point) {\n                        var graphic = point.graphic,\n                            args = point.shapeArgs;\n\n                        if (graphic) {\n                            // start values\n                            graphic.attr({\n                                r: point.startR || (series.center[3] / 2), // animate from inner radius (#779)\n                                start: startAngleRad,\n                                end: startAngleRad\n                            });\n\n                            // animate\n                            graphic.animate({\n                                r: args.r,\n                                start: args.start,\n                                end: args.end\n                            }, series.options.animation);\n                        }\n                    });\n\n                    // delete this function to allow it only once\n                    series.animate = null;\n                }\n            },\n\n            /**\n             * Recompute total chart sum and update percentages of points.\n             */\n            updateTotals: function() {\n                var i,\n                    total = 0,\n                    points = this.points,\n                    len = points.length,\n                    point,\n                    ignoreHiddenPoint = this.options.ignoreHiddenPoint;\n\n                // Get the total sum\n                for (i = 0; i < len; i++) {\n                    point = points[i];\n                    total += (ignoreHiddenPoint && !point.visible) ?\n                        0 :\n                        point.isNull ? 0 : point.y;\n                }\n                this.total = total;\n\n                // Set each point's properties\n                for (i = 0; i < len; i++) {\n                    point = points[i];\n                    point.percentage = (total > 0 && (point.visible || !ignoreHiddenPoint)) ? point.y / total * 100 : 0;\n                    point.total = total;\n                }\n            },\n\n            /**\n             * Extend the generatePoints method by adding total and percentage properties to each point\n             */\n            generatePoints: function() {\n                Series.prototype.generatePoints.call(this);\n                this.updateTotals();\n            },\n\n            /**\n             * Do translation for pie slices\n             */\n            translate: function(positions) {\n                this.generatePoints();\n\n                var series = this,\n                    cumulative = 0,\n                    precision = 1000, // issue #172\n                    options = series.options,\n                    slicedOffset = options.slicedOffset,\n                    connectorOffset = slicedOffset + (options.borderWidth || 0),\n                    finalConnectorOffset,\n                    start,\n                    end,\n                    angle,\n                    startAngle = options.startAngle || 0,\n                    startAngleRad = series.startAngleRad = Math.PI / 180 * (startAngle - 90),\n                    endAngleRad = series.endAngleRad = Math.PI / 180 * ((pick(options.endAngle, startAngle + 360)) - 90),\n                    circ = endAngleRad - startAngleRad, //2 * Math.PI,\n                    points = series.points,\n                    radiusX, // the x component of the radius vector for a given point\n                    radiusY,\n                    labelDistance = options.dataLabels.distance,\n                    ignoreHiddenPoint = options.ignoreHiddenPoint,\n                    i,\n                    len = points.length,\n                    point;\n\n                // Get positions - either an integer or a percentage string must be given.\n                // If positions are passed as a parameter, we're in a recursive loop for adjusting\n                // space for data labels.\n                if (!positions) {\n                    series.center = positions = series.getCenter();\n                }\n\n                // Utility for getting the x value from a given y, used for anticollision\n                // logic in data labels.\n                // Added point for using specific points' label distance.\n                series.getX = function(y, left, point) {\n                    angle = Math.asin(Math.min((y - positions[1]) / (positions[2] / 2 + point.labelDistance), 1));\n                    return positions[0] +\n                        (left ? -1 : 1) *\n                        (Math.cos(angle) * (positions[2] / 2 + point.labelDistance));\n                };\n\n                // Calculate the geometry for each point\n                for (i = 0; i < len; i++) {\n\n                    point = points[i];\n\n                    // Used for distance calculation for specific point.\n                    point.labelDistance = pick(\n                        point.options.dataLabels && point.options.dataLabels.distance,\n                        labelDistance\n                    );\n\n                    // Saved for later dataLabels distance calculation.\n                    series.maxLabelDistance = Math.max(series.maxLabelDistance || 0, point.labelDistance);\n\n                    // set start and end angle\n                    start = startAngleRad + (cumulative * circ);\n                    if (!ignoreHiddenPoint || point.visible) {\n                        cumulative += point.percentage / 100;\n                    }\n                    end = startAngleRad + (cumulative * circ);\n\n                    // set the shape\n                    point.shapeType = 'arc';\n                    point.shapeArgs = {\n                        x: positions[0],\n                        y: positions[1],\n                        r: positions[2] / 2,\n                        innerR: positions[3] / 2,\n                        start: Math.round(start * precision) / precision,\n                        end: Math.round(end * precision) / precision\n                    };\n\n                    // The angle must stay within -90 and 270 (#2645)\n                    angle = (end + start) / 2;\n                    if (angle > 1.5 * Math.PI) {\n                        angle -= 2 * Math.PI;\n                    } else if (angle < -Math.PI / 2) {\n                        angle += 2 * Math.PI;\n                    }\n\n                    // Center for the sliced out slice\n                    point.slicedTranslation = {\n                        translateX: Math.round(Math.cos(angle) * slicedOffset),\n                        translateY: Math.round(Math.sin(angle) * slicedOffset)\n                    };\n\n                    // set the anchor point for tooltips\n                    radiusX = Math.cos(angle) * positions[2] / 2;\n                    radiusY = Math.sin(angle) * positions[2] / 2;\n                    point.tooltipPos = [\n                        positions[0] + radiusX * 0.7,\n                        positions[1] + radiusY * 0.7\n                    ];\n\n                    point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;\n                    point.angle = angle;\n\n                    // Set the anchor point for data labels. Use point.labelDistance \n                    // instead of labelDistance // #1174\n                    // finalConnectorOffset - not override connectorOffset value.\n                    finalConnectorOffset = Math.min(connectorOffset, point.labelDistance / 5); // #1678\n                    point.labelPos = [\n                        positions[0] + radiusX + Math.cos(angle) * point.labelDistance, // first break of connector\n                        positions[1] + radiusY + Math.sin(angle) * point.labelDistance, // a/a\n                        positions[0] + radiusX + Math.cos(angle) * finalConnectorOffset, // second break, right outside pie\n                        positions[1] + radiusY + Math.sin(angle) * finalConnectorOffset, // a/a\n                        positions[0] + radiusX, // landing point for connector\n                        positions[1] + radiusY, // a/a\n                        point.labelDistance < 0 ? // alignment\n                        'center' :\n                        point.half ? 'right' : 'left', // alignment\n                        angle // center angle\n                    ];\n\n                }\n            },\n\n            drawGraph: null,\n\n            /**\n             * Draw the data points\n             */\n            drawPoints: function() {\n                var series = this,\n                    chart = series.chart,\n                    renderer = chart.renderer,\n                    groupTranslation,\n                    //center,\n                    graphic,\n                    //group,\n                    pointAttr,\n                    shapeArgs;\n\n\n                var shadow = series.options.shadow;\n                if (shadow && !series.shadowGroup) {\n                    series.shadowGroup = renderer.g('shadow')\n                        .add(series.group);\n                }\n\n\n                // draw the slices\n                each(series.points, function(point) {\n                    if (!point.isNull) {\n                        graphic = point.graphic;\n                        shapeArgs = point.shapeArgs;\n\n\n                        // If the point is sliced, use special translation, else use\n                        // plot area traslation\n                        groupTranslation = point.getTranslate();\n\n\n                        // Put the shadow behind all points\n                        var shadowGroup = point.shadowGroup;\n                        if (shadow && !shadowGroup) {\n                            shadowGroup = point.shadowGroup = renderer.g('shadow')\n                                .add(series.shadowGroup);\n                        }\n\n                        if (shadowGroup) {\n                            shadowGroup.attr(groupTranslation);\n                        }\n                        pointAttr = series.pointAttribs(point, point.selected && 'select');\n\n\n                        // Draw the slice\n                        if (graphic) {\n                            graphic\n                                .setRadialReference(series.center)\n\n                                .attr(pointAttr)\n\n                                .animate(extend(shapeArgs, groupTranslation));\n                        } else {\n\n                            point.graphic = graphic = renderer[point.shapeType](shapeArgs)\n                                .setRadialReference(series.center)\n                                .attr(groupTranslation)\n                                .add(series.group);\n\n                            if (!point.visible) {\n                                graphic.attr({\n                                    visibility: 'hidden'\n                                });\n                            }\n\n\n                            graphic\n                                .attr(pointAttr)\n                                .attr({\n                                    'stroke-linejoin': 'round'\n                                })\n                                .shadow(shadow, shadowGroup);\n\n                        }\n\n                        graphic.addClass(point.getClassName());\n\n                    }\n                });\n\n            },\n\n\n            searchPoint: noop,\n\n            /**\n             * Utility for sorting data labels\n             */\n            sortByAngle: function(points, sign) {\n                points.sort(function(a, b) {\n                    return a.angle !== undefined && (b.angle - a.angle) * sign;\n                });\n            },\n\n            /**\n             * Use a simple symbol from LegendSymbolMixin\n             */\n            drawLegendSymbol: LegendSymbolMixin.drawRectangle,\n\n            /**\n             * Use the getCenter method from drawLegendSymbol\n             */\n            getCenter: CenteredSeriesMixin.getCenter,\n\n            /**\n             * Pies don't have point marker symbols\n             */\n            getSymbol: noop\n\n\n            /**\n             * @constructor seriesTypes.pie.prototype.pointClass\n             * @extends {Point}\n             */\n        }, /** @lends seriesTypes.pie.prototype.pointClass.prototype */ {\n            /**\n             * Initiate the pie slice\n             */\n            init: function() {\n\n                Point.prototype.init.apply(this, arguments);\n\n                var point = this,\n                    toggleSlice;\n\n                point.name = pick(point.name, 'Slice');\n\n                // add event listener for select\n                toggleSlice = function(e) {\n                    point.slice(e.type === 'select');\n                };\n                addEvent(point, 'select', toggleSlice);\n                addEvent(point, 'unselect', toggleSlice);\n\n                return point;\n            },\n\n            /**\n             * Negative points are not valid (#1530, #3623, #5322)\n             */\n            isValid: function() {\n                return H.isNumber(this.y, true) && this.y >= 0;\n            },\n\n            /**\n             * Toggle the visibility of the pie slice\n             * @param {Boolean} vis Whether to show the slice or not. If undefined, the\n             *    visibility is toggled\n             */\n            setVisible: function(vis, redraw) {\n                var point = this,\n                    series = point.series,\n                    chart = series.chart,\n                    ignoreHiddenPoint = series.options.ignoreHiddenPoint;\n\n                redraw = pick(redraw, ignoreHiddenPoint);\n\n                if (vis !== point.visible) {\n\n                    // If called without an argument, toggle visibility\n                    point.visible = point.options.visible = vis = vis === undefined ? !point.visible : vis;\n                    series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n                    // Show and hide associated elements. This is performed regardless of redraw or not,\n                    // because chart.redraw only handles full series.\n                    each(['graphic', 'dataLabel', 'connector', 'shadowGroup'], function(key) {\n                        if (point[key]) {\n                            point[key][vis ? 'show' : 'hide'](true);\n                        }\n                    });\n\n                    if (point.legendItem) {\n                        chart.legend.colorizeItem(point, vis);\n                    }\n\n                    // #4170, hide halo after hiding point\n                    if (!vis && point.state === 'hover') {\n                        point.setState('');\n                    }\n\n                    // Handle ignore hidden slices\n                    if (ignoreHiddenPoint) {\n                        series.isDirty = true;\n                    }\n\n                    if (redraw) {\n                        chart.redraw();\n                    }\n                }\n            },\n\n            /**\n             * Set or toggle whether the slice is cut out from the pie\n             * @param {Boolean} sliced When undefined, the slice state is toggled\n             * @param {Boolean} redraw Whether to redraw the chart. True by default.\n             */\n            slice: function(sliced, redraw, animation) {\n                var point = this,\n                    series = point.series,\n                    chart = series.chart;\n\n                setAnimation(animation, chart);\n\n                // redraw is true by default\n                redraw = pick(redraw, true);\n\n                // if called without an argument, toggle\n                point.sliced = point.options.sliced = sliced = defined(sliced) ? sliced : !point.sliced;\n                series.options.data[inArray(point, series.data)] = point.options; // update userOptions.data\n\n                point.graphic.animate(this.getTranslate());\n\n\n                if (point.shadowGroup) {\n                    point.shadowGroup.animate(this.getTranslate());\n                }\n\n            },\n\n            getTranslate: function() {\n                return this.sliced ? this.slicedTranslation : {\n                    translateX: 0,\n                    translateY: 0\n                };\n            },\n\n            haloPath: function(size) {\n                var shapeArgs = this.shapeArgs;\n\n                return this.sliced || !this.visible ? [] :\n                    this.series.chart.renderer.symbols.arc(\n                        shapeArgs.x,\n                        shapeArgs.y,\n                        shapeArgs.r + size,\n                        shapeArgs.r + size, {\n                            innerR: this.shapeArgs.r,\n                            start: shapeArgs.start,\n                            end: shapeArgs.end\n                        }\n                    );\n            }\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            arrayMax = H.arrayMax,\n            defined = H.defined,\n            each = H.each,\n            extend = H.extend,\n            format = H.format,\n            map = H.map,\n            merge = H.merge,\n            noop = H.noop,\n            pick = H.pick,\n            relativeLength = H.relativeLength,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            stableSort = H.stableSort;\n\n\n        /**\n         * Generatl distribution algorithm for distributing labels of differing size along a\n         * confined length in two dimensions. The algorithm takes an array of objects containing\n         * a size, a target and a rank. It will place the labels as close as possible to their \n         * targets, skipping the lowest ranked labels if necessary.\n         */\n        H.distribute = function(boxes, len) {\n\n            var i,\n                overlapping = true,\n                origBoxes = boxes, // Original array will be altered with added .pos\n                restBoxes = [], // The outranked overshoot\n                box,\n                target,\n                total = 0;\n\n            function sortByTarget(a, b) {\n                return a.target - b.target;\n            }\n\n            // If the total size exceeds the len, remove those boxes with the lowest rank\n            i = boxes.length;\n            while (i--) {\n                total += boxes[i].size;\n            }\n\n            // Sort by rank, then slice away overshoot\n            if (total > len) {\n                stableSort(boxes, function(a, b) {\n                    return (b.rank || 0) - (a.rank || 0);\n                });\n                i = 0;\n                total = 0;\n                while (total <= len) {\n                    total += boxes[i].size;\n                    i++;\n                }\n                restBoxes = boxes.splice(i - 1, boxes.length);\n            }\n\n            // Order by target\n            stableSort(boxes, sortByTarget);\n\n\n            // So far we have been mutating the original array. Now\n            // create a copy with target arrays\n            boxes = map(boxes, function(box) {\n                return {\n                    size: box.size,\n                    targets: [box.target]\n                };\n            });\n\n            while (overlapping) {\n                // Initial positions: target centered in box\n                i = boxes.length;\n                while (i--) {\n                    box = boxes[i];\n                    // Composite box, average of targets\n                    target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;\n                    box.pos = Math.min(Math.max(0, target - box.size / 2), len - box.size);\n                }\n\n                // Detect overlap and join boxes\n                i = boxes.length;\n                overlapping = false;\n                while (i--) {\n                    if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) { // Overlap\n                        boxes[i - 1].size += boxes[i].size; // Add this size to the previous box\n                        boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);\n\n                        // Overlapping right, push left\n                        if (boxes[i - 1].pos + boxes[i - 1].size > len) {\n                            boxes[i - 1].pos = len - boxes[i - 1].size;\n                        }\n                        boxes.splice(i, 1); // Remove this item\n                        overlapping = true;\n                    }\n                }\n            }\n\n            // Now the composite boxes are placed, we need to put the original boxes within them\n            i = 0;\n            each(boxes, function(box) {\n                var posInCompositeBox = 0;\n                each(box.targets, function() {\n                    origBoxes[i].pos = box.pos + posInCompositeBox;\n                    posInCompositeBox += origBoxes[i].size;\n                    i++;\n                });\n            });\n\n            // Add the rest (hidden) boxes and sort by target\n            origBoxes.push.apply(origBoxes, restBoxes);\n            stableSort(origBoxes, sortByTarget);\n        };\n\n\n        /**\n         * Draw the data labels\n         */\n        Series.prototype.drawDataLabels = function() {\n            var series = this,\n                seriesOptions = series.options,\n                options = seriesOptions.dataLabels,\n                points = series.points,\n                pointOptions,\n                generalOptions,\n                hasRendered = series.hasRendered || 0,\n                str,\n                dataLabelsGroup,\n                defer = pick(options.defer, !!seriesOptions.animation),\n                renderer = series.chart.renderer;\n\n            if (options.enabled || series._hasPointLabels) {\n\n                // Process default alignment of data labels for columns\n                if (series.dlProcessOptions) {\n                    series.dlProcessOptions(options);\n                }\n\n                // Create a separate group for the data labels to avoid rotation\n                dataLabelsGroup = series.plotGroup(\n                    'dataLabelsGroup',\n                    'data-labels',\n                    defer && !hasRendered ? 'hidden' : 'visible', // #5133\n                    options.zIndex || 6\n                );\n\n                if (defer) {\n                    dataLabelsGroup.attr({\n                        opacity: +hasRendered\n                    }); // #3300\n                    if (!hasRendered) {\n                        addEvent(series, 'afterAnimate', function() {\n                            if (series.visible) { // #2597, #3023, #3024\n                                dataLabelsGroup.show(true);\n                            }\n                            dataLabelsGroup[seriesOptions.animation ? 'animate' : 'attr']({\n                                opacity: 1\n                            }, {\n                                duration: 200\n                            });\n                        });\n                    }\n                }\n\n                // Make the labels for each point\n                generalOptions = options;\n                each(points, function(point) {\n                    var enabled,\n                        dataLabel = point.dataLabel,\n                        labelConfig,\n                        attr,\n                        rotation,\n                        connector = point.connector,\n                        isNew = !dataLabel,\n                        style;\n                    // Determine if each data label is enabled\n                    // @note dataLabelAttribs (like pointAttribs) would eradicate\n                    // the need for dlOptions, and simplify the section below.\n                    pointOptions = point.dlOptions || (point.options && point.options.dataLabels); // dlOptions is used in treemaps\n                    enabled = pick(pointOptions && pointOptions.enabled, generalOptions.enabled) && point.y !== null; // #2282, #4641\n                    if (enabled) {\n                        // Create individual options structure that can be extended without\n                        // affecting others\n                        options = merge(generalOptions, pointOptions);\n                        labelConfig = point.getLabelConfig();\n                        str = options.format ?\n                            format(options.format, labelConfig) :\n                            options.formatter.call(labelConfig, options);\n                        style = options.style;\n                        rotation = options.rotation;\n\n                        // Determine the color\n                        style.color = pick(options.color, style.color, series.color, '#000000');\n                        // Get automated contrast color\n                        if (style.color === 'contrast') {\n                            point.contrastColor = renderer.getContrast(point.color || series.color);\n                            style.color = options.inside || pick(point.labelDistance, options.distance) < 0 ||\n                                !!seriesOptions.stacking ? point.contrastColor : '#000000';\n                        }\n                        if (seriesOptions.cursor) {\n                            style.cursor = seriesOptions.cursor;\n                        }\n\n\n                        attr = {\n                            //align: align,\n\n                            fill: options.backgroundColor,\n                            stroke: options.borderColor,\n                            'stroke-width': options.borderWidth,\n\n                            r: options.borderRadius || 0,\n                            rotation: rotation,\n                            padding: options.padding,\n                            zIndex: 1\n                        };\n\n                        // Remove unused attributes (#947)\n                        H.objectEach(attr, function(val, name) {\n                            if (val === undefined) {\n                                delete attr[name];\n                            }\n                        });\n                    }\n                    // If the point is outside the plot area, destroy it. #678, #820\n                    if (dataLabel && (!enabled || !defined(str))) {\n                        point.dataLabel = dataLabel = dataLabel.destroy();\n                        if (connector) {\n                            point.connector = connector.destroy();\n                        }\n                        // Individual labels are disabled if the are explicitly disabled\n                        // in the point options, or if they fall outside the plot area.\n                    } else if (enabled && defined(str)) {\n                        // create new label\n                        if (!dataLabel) {\n                            dataLabel = point.dataLabel = renderer[rotation ? 'text' : 'label']( // labels don't support rotation\n                                str,\n                                0, -9999,\n                                options.shape,\n                                null,\n                                null,\n                                options.useHTML,\n                                null,\n                                'data-label'\n                            );\n                            dataLabel.addClass(\n                                'highcharts-data-label-color-' + point.colorIndex +\n                                ' ' + (options.className || '') +\n                                (options.useHTML ? 'highcharts-tracker' : '') // #3398\n                            );\n                        } else {\n                            attr.text = str;\n                        }\n                        dataLabel.attr(attr);\n\n                        // Styles must be applied before add in order to read text bounding box\n                        dataLabel.css(style).shadow(options.shadow);\n\n\n                        if (!dataLabel.added) {\n                            dataLabel.add(dataLabelsGroup);\n                        }\n                        // Now the data label is created and placed at 0,0, so we need to align it\n                        series.alignDataLabel(point, dataLabel, options, null, isNew);\n                    }\n                });\n            }\n        };\n\n        /**\n         * Align each individual data label\n         */\n        Series.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {\n            var chart = this.chart,\n                inverted = chart.inverted,\n                plotX = pick(point.plotX, -9999),\n                plotY = pick(point.plotY, -9999),\n                bBox = dataLabel.getBBox(),\n                fontSize,\n                baseline,\n                rotation = options.rotation,\n                normRotation,\n                negRotation,\n                align = options.align,\n                rotCorr, // rotation correction\n                // Math.round for rounding errors (#2683), alignTo to allow column labels (#2700)\n                visible =\n                this.visible &&\n                (\n                    point.series.forceDL ||\n                    chart.isInsidePlot(plotX, Math.round(plotY), inverted) ||\n                    (\n                        alignTo && chart.isInsidePlot(\n                            plotX,\n                            inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1,\n                            inverted\n                        )\n                    )\n                ),\n                alignAttr, // the final position;\n                justify = pick(options.overflow, 'justify') === 'justify';\n\n            if (visible) {\n\n\n                fontSize = options.style.fontSize;\n\n\n                baseline = chart.renderer.fontMetrics(fontSize, dataLabel).b;\n\n                // The alignment box is a singular point\n                alignTo = extend({\n                    x: inverted ? chart.plotWidth - plotY : plotX,\n                    y: Math.round(inverted ? chart.plotHeight - plotX : plotY),\n                    width: 0,\n                    height: 0\n                }, alignTo);\n\n                // Add the text size for alignment calculation\n                extend(options, {\n                    width: bBox.width,\n                    height: bBox.height\n                });\n\n                // Allow a hook for changing alignment in the last moment, then do the alignment\n                if (rotation) {\n                    justify = false; // Not supported for rotated text\n                    rotCorr = chart.renderer.rotCorr(baseline, rotation); // #3723\n                    alignAttr = {\n                        x: alignTo.x + options.x + alignTo.width / 2 + rotCorr.x,\n                        y: alignTo.y + options.y + {\n                            top: 0,\n                            middle: 0.5,\n                            bottom: 1\n                        }[options.verticalAlign] * alignTo.height\n                    };\n                    dataLabel[isNew ? 'attr' : 'animate'](alignAttr)\n                        .attr({ // #3003\n                            align: align\n                        });\n\n                    // Compensate for the rotated label sticking out on the sides\n                    normRotation = (rotation + 720) % 360;\n                    negRotation = normRotation > 180 && normRotation < 360;\n\n                    if (align === 'left') {\n                        alignAttr.y -= negRotation ? bBox.height : 0;\n                    } else if (align === 'center') {\n                        alignAttr.x -= bBox.width / 2;\n                        alignAttr.y -= bBox.height / 2;\n                    } else if (align === 'right') {\n                        alignAttr.x -= bBox.width;\n                        alignAttr.y -= negRotation ? 0 : bBox.height;\n                    }\n\n\n                } else {\n                    dataLabel.align(options, null, alignTo);\n                    alignAttr = dataLabel.alignAttr;\n                }\n\n                // Handle justify or crop\n                if (justify) {\n                    point.isLabelJustified = this.justifyDataLabel(\n                        dataLabel,\n                        options,\n                        alignAttr,\n                        bBox,\n                        alignTo,\n                        isNew\n                    );\n\n                    // Now check that the data label is within the plot area\n                } else if (pick(options.crop, true)) {\n                    visible = chart.isInsidePlot(alignAttr.x, alignAttr.y) && chart.isInsidePlot(alignAttr.x + bBox.width, alignAttr.y + bBox.height);\n                }\n\n                // When we're using a shape, make it possible with a connector or an arrow pointing to thie point\n                if (options.shape && !rotation) {\n                    dataLabel[isNew ? 'attr' : 'animate']({\n                        anchorX: inverted ? chart.plotWidth - point.plotY : point.plotX,\n                        anchorY: inverted ? chart.plotHeight - point.plotX : point.plotY\n                    });\n                }\n            }\n\n            // Show or hide based on the final aligned position\n            if (!visible) {\n                dataLabel.attr({\n                    y: -9999\n                });\n                dataLabel.placed = false; // don't animate back in\n            }\n\n        };\n\n        /**\n         * If data labels fall partly outside the plot area, align them back in, in a way that\n         * doesn't hide the point.\n         */\n        Series.prototype.justifyDataLabel = function(dataLabel, options, alignAttr, bBox, alignTo, isNew) {\n            var chart = this.chart,\n                align = options.align,\n                verticalAlign = options.verticalAlign,\n                off,\n                justified,\n                padding = dataLabel.box ? 0 : (dataLabel.padding || 0);\n\n            // Off left\n            off = alignAttr.x + padding;\n            if (off < 0) {\n                if (align === 'right') {\n                    options.align = 'left';\n                } else {\n                    options.x = -off;\n                }\n                justified = true;\n            }\n\n            // Off right\n            off = alignAttr.x + bBox.width - padding;\n            if (off > chart.plotWidth) {\n                if (align === 'left') {\n                    options.align = 'right';\n                } else {\n                    options.x = chart.plotWidth - off;\n                }\n                justified = true;\n            }\n\n            // Off top\n            off = alignAttr.y + padding;\n            if (off < 0) {\n                if (verticalAlign === 'bottom') {\n                    options.verticalAlign = 'top';\n                } else {\n                    options.y = -off;\n                }\n                justified = true;\n            }\n\n            // Off bottom\n            off = alignAttr.y + bBox.height - padding;\n            if (off > chart.plotHeight) {\n                if (verticalAlign === 'top') {\n                    options.verticalAlign = 'bottom';\n                } else {\n                    options.y = chart.plotHeight - off;\n                }\n                justified = true;\n            }\n\n            if (justified) {\n                dataLabel.placed = !isNew;\n                dataLabel.align(options, null, alignTo);\n            }\n\n            return justified;\n        };\n\n        /**\n         * Override the base drawDataLabels method by pie specific functionality\n         */\n        if (seriesTypes.pie) {\n            seriesTypes.pie.prototype.drawDataLabels = function() {\n                var series = this,\n                    data = series.data,\n                    point,\n                    chart = series.chart,\n                    options = series.options.dataLabels,\n                    connectorPadding = pick(options.connectorPadding, 10),\n                    connectorWidth = pick(options.connectorWidth, 1),\n                    plotWidth = chart.plotWidth,\n                    plotHeight = chart.plotHeight,\n                    connector,\n                    seriesCenter = series.center,\n                    radius = seriesCenter[2] / 2,\n                    centerY = seriesCenter[1],\n                    dataLabel,\n                    dataLabelWidth,\n                    labelPos,\n                    labelHeight,\n                    halves = [ // divide the points into right and left halves for anti collision\n                        [], // right\n                        [] // left\n                    ],\n                    x,\n                    y,\n                    visibility,\n                    j,\n                    overflow = [0, 0, 0, 0]; // top, right, bottom, left\n\n                // get out if not enabled\n                if (!series.visible || (!options.enabled && !series._hasPointLabels)) {\n                    return;\n                }\n\n                // Reset all labels that have been shortened\n                each(data, function(point) {\n                    if (point.dataLabel && point.visible && point.dataLabel.shortened) {\n                        point.dataLabel\n                            .attr({\n                                width: 'auto'\n                            }).css({\n                                width: 'auto',\n                                textOverflow: 'clip'\n                            });\n                        point.dataLabel.shortened = false;\n                    }\n                });\n\n\n                // run parent method\n                Series.prototype.drawDataLabels.apply(series);\n\n                each(data, function(point) {\n                    if (point.dataLabel && point.visible) { // #407, #2510\n\n                        // Arrange points for detection collision\n                        halves[point.half].push(point);\n\n                        // Reset positions (#4905)\n                        point.dataLabel._pos = null;\n                    }\n                });\n\n                /* Loop over the points in each half, starting from the top and bottom\n                 * of the pie to detect overlapping labels.\n                 */\n                each(halves, function(points, i) {\n\n                    var top,\n                        bottom,\n                        length = points.length,\n                        positions = [],\n                        naturalY,\n                        sideOverflow,\n                        positionsIndex, // Point index in positions array.\n                        size;\n\n                    if (!length) {\n                        return;\n                    }\n\n                    // Sort by angle\n                    series.sortByAngle(points, i - 0.5);\n                    // Only do anti-collision when we have dataLabels outside the pie \n                    // and have connectors. (#856)\n                    if (series.maxLabelDistance > 0) {\n                        top = Math.max(\n                            0,\n                            centerY - radius - series.maxLabelDistance\n                        );\n                        bottom = Math.min(\n                            centerY + radius + series.maxLabelDistance,\n                            chart.plotHeight\n                        );\n                        each(points, function(point) {\n                            // check if specific points' label is outside the pie\n                            if (point.labelDistance > 0 && point.dataLabel) {\n                                // point.top depends on point.labelDistance value\n                                // Used for calculation of y value in getX method \n                                point.top = Math.max(\n                                    0,\n                                    centerY - radius - point.labelDistance\n                                );\n                                point.bottom = Math.min(\n                                    centerY + radius + point.labelDistance,\n                                    chart.plotHeight\n                                );\n                                size = point.dataLabel.getBBox().height || 21;\n\n                                // point.positionsIndex is needed for getting index of \n                                // parameter related to specific point inside positions \n                                // array - not every point is in positions array.\n                                point.positionsIndex = positions.push({\n                                    target: point.labelPos[1] - point.top + size / 2,\n                                    size: size,\n                                    rank: point.y\n                                }) - 1;\n                            }\n                        });\n                        H.distribute(positions, bottom + size - top);\n                    }\n\n                    // Now the used slots are sorted, fill them up sequentially\n                    for (j = 0; j < length; j++) {\n\n                        point = points[j];\n                        positionsIndex = point.positionsIndex;\n                        labelPos = point.labelPos;\n                        dataLabel = point.dataLabel;\n                        visibility = point.visible === false ? 'hidden' : 'inherit';\n                        naturalY = labelPos[1];\n\n                        if (positions && defined(positions[positionsIndex])) {\n                            if (positions[positionsIndex].pos === undefined) {\n                                visibility = 'hidden';\n                            } else {\n                                labelHeight = positions[positionsIndex].size;\n                                y = point.top + positions[positionsIndex].pos;\n                            }\n\n                        } else {\n                            y = naturalY;\n                        }\n\n                        // It is needed to delete point.positionIndex for \n                        // dynamically added points etc.\n\n                        delete point.positionIndex;\n\n                        // get the x - use the natural x position for labels near the \n                        // top and bottom, to prevent the top and botton slice connectors \n                        // from touching each other on either side\n                        if (options.justify) {\n                            x = seriesCenter[0] + (i ? -1 : 1) * (radius + point.labelDistance);\n                        } else {\n                            x = series.getX(y < point.top + 2 || y > point.bottom - 2 ? naturalY : y, i, point);\n                        }\n\n\n                        // Record the placement and visibility\n                        dataLabel._attr = {\n                            visibility: visibility,\n                            align: labelPos[6]\n                        };\n                        dataLabel._pos = {\n                            x: x + options.x +\n                                ({\n                                    left: connectorPadding,\n                                    right: -connectorPadding\n                                }[labelPos[6]] || 0),\n                            y: y + options.y - 10 // 10 is for the baseline (label vs text)\n                        };\n                        labelPos.x = x;\n                        labelPos.y = y;\n\n\n                        // Detect overflowing data labels\n                        dataLabelWidth = dataLabel.getBBox().width;\n\n                        sideOverflow = null;\n                        // Overflow left\n                        if (x - dataLabelWidth < connectorPadding) {\n                            sideOverflow = Math.round(\n                                dataLabelWidth - x + connectorPadding\n                            );\n                            overflow[3] = Math.max(sideOverflow, overflow[3]);\n\n                            // Overflow right\n                        } else if (x + dataLabelWidth > plotWidth - connectorPadding) {\n                            sideOverflow = Math.round(\n                                x + dataLabelWidth - plotWidth + connectorPadding\n                            );\n                            overflow[1] = Math.max(sideOverflow, overflow[1]);\n                        }\n\n                        // Overflow top\n                        if (y - labelHeight / 2 < 0) {\n                            overflow[0] = Math.max(\n                                Math.round(-y + labelHeight / 2),\n                                overflow[0]\n                            );\n\n                            // Overflow left\n                        } else if (y + labelHeight / 2 > plotHeight) {\n                            overflow[2] = Math.max(\n                                Math.round(y + labelHeight / 2 - plotHeight),\n                                overflow[2]\n                            );\n                        }\n                        dataLabel.sideOverflow = sideOverflow;\n                    } // for each point\n                }); // for each half\n\n                // Do not apply the final placement and draw the connectors until we have verified\n                // that labels are not spilling over.\n                if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {\n\n                    // Place the labels in the final position\n                    this.placeDataLabels();\n\n                    // Draw the connectors\n                    if (connectorWidth) {\n                        each(this.points, function(point) {\n                            var isNew;\n\n                            connector = point.connector;\n                            dataLabel = point.dataLabel;\n\n                            if (\n                                dataLabel &&\n                                dataLabel._pos &&\n                                point.visible &&\n                                point.labelDistance > 0\n                            ) {\n                                visibility = dataLabel._attr.visibility;\n\n                                isNew = !connector;\n\n                                if (isNew) {\n                                    point.connector = connector = chart.renderer.path()\n                                        .addClass('highcharts-data-label-connector highcharts-color-' + point.colorIndex)\n                                        .add(series.dataLabelsGroup);\n\n\n                                    connector.attr({\n                                        'stroke-width': connectorWidth,\n                                        'stroke': options.connectorColor || point.color || '#666666'\n                                    });\n\n                                }\n                                connector[isNew ? 'attr' : 'animate']({\n                                    d: series.connectorPath(point.labelPos)\n                                });\n                                connector.attr('visibility', visibility);\n\n                            } else if (connector) {\n                                point.connector = connector.destroy();\n                            }\n                        });\n                    }\n                }\n            };\n\n            /**\n             * Extendable method for getting the path of the connector between the data label\n             * and the pie slice.\n             */\n            seriesTypes.pie.prototype.connectorPath = function(labelPos) {\n                var x = labelPos.x,\n                    y = labelPos.y;\n                return pick(this.options.dataLabels.softConnector, true) ? [\n                    'M',\n                    x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n                    'C',\n                    x, y, // first break, next to the label\n                    2 * labelPos[2] - labelPos[4], 2 * labelPos[3] - labelPos[5],\n                    labelPos[2], labelPos[3], // second break\n                    'L',\n                    labelPos[4], labelPos[5] // base\n                ] : [\n                    'M',\n                    x + (labelPos[6] === 'left' ? 5 : -5), y, // end of the string at the label\n                    'L',\n                    labelPos[2], labelPos[3], // second break\n                    'L',\n                    labelPos[4], labelPos[5] // base\n                ];\n            };\n\n            /**\n             * Perform the final placement of the data labels after we have verified that they\n             * fall within the plot area.\n             */\n            seriesTypes.pie.prototype.placeDataLabels = function() {\n                each(this.points, function(point) {\n                    var dataLabel = point.dataLabel,\n                        _pos;\n                    if (dataLabel && point.visible) {\n                        _pos = dataLabel._pos;\n                        if (_pos) {\n\n                            // Shorten data labels with ellipsis if they still overflow\n                            // after the pie has reached minSize (#223).\n                            if (dataLabel.sideOverflow) {\n                                dataLabel._attr.width =\n                                    dataLabel.getBBox().width - dataLabel.sideOverflow;\n                                dataLabel.css({\n                                    width: dataLabel._attr.width + 'px',\n                                    textOverflow: 'ellipsis'\n                                });\n                                dataLabel.shortened = true;\n                            }\n\n                            dataLabel.attr(dataLabel._attr);\n                            dataLabel[dataLabel.moved ? 'animate' : 'attr'](_pos);\n                            dataLabel.moved = true;\n                        } else if (dataLabel) {\n                            dataLabel.attr({\n                                y: -9999\n                            });\n                        }\n                    }\n                }, this);\n            };\n\n            seriesTypes.pie.prototype.alignDataLabel = noop;\n\n            /**\n             * Verify whether the data labels are allowed to draw, or we should run more translation and data\n             * label positioning to keep them inside the plot area. Returns true when data labels are ready\n             * to draw.\n             */\n            seriesTypes.pie.prototype.verifyDataLabelOverflow = function(overflow) {\n\n                var center = this.center,\n                    options = this.options,\n                    centerOption = options.center,\n                    minSize = options.minSize || 80,\n                    newSize = minSize,\n                    // If a size is set, return true and don't try to shrink the pie\n                    // to fit the labels.\n                    ret = options.size !== null;\n\n                if (!ret) {\n                    // Handle horizontal size and center\n                    if (centerOption[0] !== null) { // Fixed center\n                        newSize = Math.max(center[2] -\n                            Math.max(overflow[1], overflow[3]), minSize);\n\n                    } else { // Auto center\n                        newSize = Math.max(\n                            // horizontal overflow\n                            center[2] - overflow[1] - overflow[3],\n                            minSize\n                        );\n                        // horizontal center\n                        center[0] += (overflow[3] - overflow[1]) / 2;\n                    }\n\n                    // Handle vertical size and center\n                    if (centerOption[1] !== null) { // Fixed center\n                        newSize = Math.max(Math.min(newSize, center[2] -\n                            Math.max(overflow[0], overflow[2])), minSize);\n\n                    } else { // Auto center\n                        newSize = Math.max(\n                            Math.min(\n                                newSize,\n                                // vertical overflow\n                                center[2] - overflow[0] - overflow[2]\n                            ),\n                            minSize\n                        );\n                        // vertical center\n                        center[1] += (overflow[0] - overflow[2]) / 2;\n                    }\n\n                    // If the size must be decreased, we need to run translate and\n                    // drawDataLabels again\n                    if (newSize < center[2]) {\n                        center[2] = newSize;\n                        center[3] = Math.min( // #3632\n                            relativeLength(options.innerSize || 0, newSize),\n                            newSize\n                        );\n                        this.translate(center);\n\n                        if (this.drawDataLabels) {\n                            this.drawDataLabels();\n                        }\n                        // Else, return true to indicate that the pie and its labels is\n                        // within the plot area\n                    } else {\n                        ret = true;\n                    }\n                }\n                return ret;\n            };\n        }\n\n        if (seriesTypes.column) {\n\n            /**\n             * Override the basic data label alignment by adjusting for the position of the column\n             */\n            seriesTypes.column.prototype.alignDataLabel = function(point, dataLabel, options, alignTo, isNew) {\n                var inverted = this.chart.inverted,\n                    series = point.series,\n                    dlBox = point.dlBox || point.shapeArgs, // data label box for alignment\n                    below = pick(point.below, point.plotY > pick(this.translatedThreshold, series.yAxis.len)), // point.below is used in range series\n                    inside = pick(options.inside, !!this.options.stacking), // draw it inside the box?\n                    overshoot;\n\n                // Align to the column itself, or the top of it\n                if (dlBox) { // Area range uses this method but not alignTo\n                    alignTo = merge(dlBox);\n\n                    if (alignTo.y < 0) {\n                        alignTo.height += alignTo.y;\n                        alignTo.y = 0;\n                    }\n                    overshoot = alignTo.y + alignTo.height - series.yAxis.len;\n                    if (overshoot > 0) {\n                        alignTo.height -= overshoot;\n                    }\n\n                    if (inverted) {\n                        alignTo = {\n                            x: series.yAxis.len - alignTo.y - alignTo.height,\n                            y: series.xAxis.len - alignTo.x - alignTo.width,\n                            width: alignTo.height,\n                            height: alignTo.width\n                        };\n                    }\n\n                    // Compute the alignment box\n                    if (!inside) {\n                        if (inverted) {\n                            alignTo.x += below ? 0 : alignTo.width;\n                            alignTo.width = 0;\n                        } else {\n                            alignTo.y += below ? alignTo.height : 0;\n                            alignTo.height = 0;\n                        }\n                    }\n                }\n\n\n                // When alignment is undefined (typically columns and bars), display the individual\n                // point below or above the point depending on the threshold\n                options.align = pick(\n                    options.align, !inverted || inside ? 'center' : below ? 'right' : 'left'\n                );\n                options.verticalAlign = pick(\n                    options.verticalAlign,\n                    inverted || inside ? 'middle' : below ? 'top' : 'bottom'\n                );\n\n                // Call the parent method\n                Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n\n                // If label was justified and we have contrast, set it:\n                if (point.isLabelJustified && point.contrastColor) {\n                    point.dataLabel.css({\n                        color: point.contrastColor\n                    });\n                }\n            };\n        }\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2009-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        /**\n         * Highcharts module to hide overlapping data labels. This module is included in\n         * Highcharts.\n         */\n        var Chart = H.Chart,\n            each = H.each,\n            pick = H.pick,\n            addEvent = H.addEvent;\n\n        // Collect potensial overlapping data labels. Stack labels probably don't need\n        // to be considered because they are usually accompanied by data labels that lie\n        // inside the columns.\n        Chart.prototype.callbacks.push(function(chart) {\n            function collectAndHide() {\n                var labels = [];\n\n                each(chart.series || [], function(series) {\n                    var dlOptions = series.options.dataLabels,\n                        // Range series have two collections\n                        collections = series.dataLabelCollections || ['dataLabel'];\n\n                    if (\n                        (dlOptions.enabled || series._hasPointLabels) &&\n                        !dlOptions.allowOverlap &&\n                        series.visible\n                    ) { // #3866\n                        each(collections, function(coll) {\n                            each(series.points, function(point) {\n                                if (point[coll]) {\n                                    point[coll].labelrank = pick(\n                                        point.labelrank,\n                                        point.shapeArgs && point.shapeArgs.height\n                                    ); // #4118\n                                    labels.push(point[coll]);\n                                }\n                            });\n                        });\n                    }\n                });\n                chart.hideOverlappingLabels(labels);\n            }\n\n            // Do it now ...\n            collectAndHide();\n\n            // ... and after each chart redraw\n            addEvent(chart, 'redraw', collectAndHide);\n\n        });\n\n        /**\n         * Hide overlapping labels. Labels are moved and faded in and out on zoom to\n         * provide a smooth visual imression.\n         */\n        Chart.prototype.hideOverlappingLabels = function(labels) {\n\n            var len = labels.length,\n                label,\n                i,\n                j,\n                label1,\n                label2,\n                isIntersecting,\n                pos1,\n                pos2,\n                parent1,\n                parent2,\n                padding,\n                intersectRect = function(x1, y1, w1, h1, x2, y2, w2, h2) {\n                    return !(\n                        x2 > x1 + w1 ||\n                        x2 + w2 < x1 ||\n                        y2 > y1 + h1 ||\n                        y2 + h2 < y1\n                    );\n                };\n\n            // Mark with initial opacity\n            for (i = 0; i < len; i++) {\n                label = labels[i];\n                if (label) {\n                    label.oldOpacity = label.opacity;\n                    label.newOpacity = 1;\n                }\n            }\n\n            // Prevent a situation in a gradually rising slope, that each label will\n            // hide the previous one because the previous one always has lower rank.\n            labels.sort(function(a, b) {\n                return (b.labelrank || 0) - (a.labelrank || 0);\n            });\n\n            // Detect overlapping labels\n            for (i = 0; i < len; i++) {\n                label1 = labels[i];\n\n                for (j = i + 1; j < len; ++j) {\n                    label2 = labels[j];\n                    if (\n                        label1 && label2 &&\n                        label1 !== label2 && // #6465, polar chart with connectEnds\n                        label1.placed && label2.placed &&\n                        label1.newOpacity !== 0 && label2.newOpacity !== 0\n                    ) {\n                        pos1 = label1.alignAttr;\n                        pos2 = label2.alignAttr;\n                        // Different panes have different positions\n                        parent1 = label1.parentGroup;\n                        parent2 = label2.parentGroup;\n                        // Substract the padding if no background or border (#4333)\n                        padding = 2 * (label1.box ? 0 : label1.padding);\n                        isIntersecting = intersectRect(\n                            pos1.x + parent1.translateX,\n                            pos1.y + parent1.translateY,\n                            label1.width - padding,\n                            label1.height - padding,\n                            pos2.x + parent2.translateX,\n                            pos2.y + parent2.translateY,\n                            label2.width - padding,\n                            label2.height - padding\n                        );\n\n                        if (isIntersecting) {\n                            (label1.labelrank < label2.labelrank ? label1 : label2)\n                            .newOpacity = 0;\n                        }\n                    }\n                }\n            }\n\n            // Hide or show\n            each(labels, function(label) {\n                var complete,\n                    newOpacity;\n\n                if (label) {\n                    newOpacity = label.newOpacity;\n\n                    if (label.oldOpacity !== newOpacity && label.placed) {\n\n                        // Make sure the label is completely hidden to avoid catching\n                        // clicks (#4362)\n                        if (newOpacity) {\n                            label.show(true);\n                        } else {\n                            complete = function() {\n                                label.hide();\n                            };\n                        }\n\n                        // Animate or set the opacity\t\t\t\t\t\n                        label.alignAttr.opacity = newOpacity;\n                        label[label.isOld ? 'animate' : 'attr'](\n                            label.alignAttr,\n                            null,\n                            complete\n                        );\n\n                    }\n                    label.isOld = true;\n                }\n            });\n        };\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var addEvent = H.addEvent,\n            Chart = H.Chart,\n            createElement = H.createElement,\n            css = H.css,\n            defaultOptions = H.defaultOptions,\n            defaultPlotOptions = H.defaultPlotOptions,\n            each = H.each,\n            extend = H.extend,\n            fireEvent = H.fireEvent,\n            hasTouch = H.hasTouch,\n            inArray = H.inArray,\n            isObject = H.isObject,\n            Legend = H.Legend,\n            merge = H.merge,\n            pick = H.pick,\n            Point = H.Point,\n            Series = H.Series,\n            seriesTypes = H.seriesTypes,\n            svg = H.svg,\n            TrackerMixin;\n\n        /**\n         * TrackerMixin for points and graphs.\n         *\n         * @mixin\n         */\n        TrackerMixin = H.TrackerMixin = {\n\n            /**\n             * Draw the tracker for a point.\n             */\n            drawTrackerPoint: function() {\n                var series = this,\n                    chart = series.chart,\n                    pointer = chart.pointer,\n                    onMouseOver = function(e) {\n                        var point = pointer.getPointFromEvent(e);\n                        // undefined on graph in scatterchart\n                        if (point !== undefined) {\n                            pointer.isDirectTouch = true;\n                            point.onMouseOver(e);\n                        }\n                    };\n\n                // Add reference to the point\n                each(series.points, function(point) {\n                    if (point.graphic) {\n                        point.graphic.element.point = point;\n                    }\n                    if (point.dataLabel) {\n                        if (point.dataLabel.div) {\n                            point.dataLabel.div.point = point;\n                        } else {\n                            point.dataLabel.element.point = point;\n                        }\n                    }\n                });\n\n                // Add the event listeners, we need to do this only once\n                if (!series._hasTracking) {\n                    each(series.trackerGroups, function(key) {\n                        if (series[key]) { // we don't always have dataLabelsGroup\n                            series[key]\n                                .addClass('highcharts-tracker')\n                                .on('mouseover', onMouseOver)\n                                .on('mouseout', function(e) {\n                                    pointer.onTrackerMouseOut(e);\n                                });\n                            if (hasTouch) {\n                                series[key].on('touchstart', onMouseOver);\n                            }\n\n\n                            if (series.options.cursor) {\n                                series[key]\n                                    .css(css)\n                                    .css({\n                                        cursor: series.options.cursor\n                                    });\n                            }\n\n                        }\n                    });\n                    series._hasTracking = true;\n                }\n            },\n\n            /**\n             * Draw the tracker object that sits above all data labels and markers to\n             * track mouse events on the graph or points. For the line type charts\n             * the tracker uses the same graphPath, but with a greater stroke width\n             * for better control.\n             */\n            drawTrackerGraph: function() {\n                var series = this,\n                    options = series.options,\n                    trackByArea = options.trackByArea,\n                    trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath),\n                    trackerPathLength = trackerPath.length,\n                    chart = series.chart,\n                    pointer = chart.pointer,\n                    renderer = chart.renderer,\n                    snap = chart.options.tooltip.snap,\n                    tracker = series.tracker,\n                    i,\n                    onMouseOver = function() {\n                        if (chart.hoverSeries !== series) {\n                            series.onMouseOver();\n                        }\n                    },\n                    /*\n                     * Empirical lowest possible opacities for TRACKER_FILL for an element to stay invisible but clickable\n                     * IE6: 0.002\n                     * IE7: 0.002\n                     * IE8: 0.002\n                     * IE9: 0.00000000001 (unlimited)\n                     * IE10: 0.0001 (exporting only)\n                     * FF: 0.00000000001 (unlimited)\n                     * Chrome: 0.000001\n                     * Safari: 0.000001\n                     * Opera: 0.00000000001 (unlimited)\n                     */\n                    TRACKER_FILL = 'rgba(192,192,192,' + (svg ? 0.0001 : 0.002) + ')';\n\n                // Extend end points. A better way would be to use round linecaps,\n                // but those are not clickable in VML.\n                if (trackerPathLength && !trackByArea) {\n                    i = trackerPathLength + 1;\n                    while (i--) {\n                        if (trackerPath[i] === 'M') { // extend left side\n                            trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], 'L');\n                        }\n                        if ((i && trackerPath[i] === 'M') || i === trackerPathLength) { // extend right side\n                            trackerPath.splice(i, 0, 'L', trackerPath[i - 2] + snap, trackerPath[i - 1]);\n                        }\n                    }\n                }\n\n                // handle single points\n                /*for (i = 0; i < singlePoints.length; i++) {\n                \tsinglePoint = singlePoints[i];\n                \ttrackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,\n                \tL, singlePoint.plotX + snap, singlePoint.plotY);\n                }*/\n\n                // draw the tracker\n                if (tracker) {\n                    tracker.attr({\n                        d: trackerPath\n                    });\n                } else if (series.graph) { // create\n\n                    series.tracker = renderer.path(trackerPath)\n                        .attr({\n                            'stroke-linejoin': 'round', // #1225\n                            visibility: series.visible ? 'visible' : 'hidden',\n                            stroke: TRACKER_FILL,\n                            fill: trackByArea ? TRACKER_FILL : 'none',\n                            'stroke-width': series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap),\n                            zIndex: 2\n                        })\n                        .add(series.group);\n\n                    // The tracker is added to the series group, which is clipped, but is covered\n                    // by the marker group. So the marker group also needs to capture events.\n                    each([series.tracker, series.markerGroup], function(tracker) {\n                        tracker.addClass('highcharts-tracker')\n                            .on('mouseover', onMouseOver)\n                            .on('mouseout', function(e) {\n                                pointer.onTrackerMouseOut(e);\n                            });\n\n\n                        if (options.cursor) {\n                            tracker.css({\n                                cursor: options.cursor\n                            });\n                        }\n\n\n                        if (hasTouch) {\n                            tracker.on('touchstart', onMouseOver);\n                        }\n                    });\n                }\n            }\n        };\n        /* End TrackerMixin */\n\n\n        /**\n         * Add tracking event listener to the series group, so the point graphics\n         * themselves act as trackers\n         */\n\n        if (seriesTypes.column) {\n            seriesTypes.column.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n        }\n\n        if (seriesTypes.pie) {\n            seriesTypes.pie.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n        }\n\n        if (seriesTypes.scatter) {\n            seriesTypes.scatter.prototype.drawTracker = TrackerMixin.drawTrackerPoint;\n        }\n\n        /*\n         * Extend Legend for item events\n         */\n        extend(Legend.prototype, {\n\n            setItemEvents: function(item, legendItem, useHTML) {\n                var legend = this,\n                    boxWrapper = legend.chart.renderer.boxWrapper,\n                    activeClass = 'highcharts-legend-' + (item.series ? 'point' : 'series') + '-active';\n\n                // Set the events on the item group, or in case of useHTML, the item itself (#1249)\n                (useHTML ? legendItem : item.legendGroup).on('mouseover', function() {\n                        item.setState('hover');\n\n                        // A CSS class to dim or hide other than the hovered series\n                        boxWrapper.addClass(activeClass);\n\n\n                        legendItem.css(legend.options.itemHoverStyle);\n\n                    })\n                    .on('mouseout', function() {\n\n                        legendItem.css(merge(item.visible ? legend.itemStyle : legend.itemHiddenStyle));\n\n\n                        // A CSS class to dim or hide other than the hovered series\n                        boxWrapper.removeClass(activeClass);\n\n                        item.setState();\n                    })\n                    .on('click', function(event) {\n                        var strLegendItemClick = 'legendItemClick',\n                            fnLegendItemClick = function() {\n                                if (item.setVisible) {\n                                    item.setVisible();\n                                }\n                            };\n\n                        // Pass over the click/touch event. #4.\n                        event = {\n                            browserEvent: event\n                        };\n\n                        // click the name or symbol\n                        if (item.firePointEvent) { // point\n                            item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);\n                        } else {\n                            fireEvent(item, strLegendItemClick, event, fnLegendItemClick);\n                        }\n                    });\n            },\n\n            createCheckboxForItem: function(item) {\n                var legend = this;\n\n                item.checkbox = createElement('input', {\n                    type: 'checkbox',\n                    checked: item.selected,\n                    defaultChecked: item.selected // required by IE7\n                }, legend.options.itemCheckboxStyle, legend.chart.container);\n\n                addEvent(item.checkbox, 'click', function(event) {\n                    var target = event.target;\n                    fireEvent(\n                        item.series || item,\n                        'checkboxClick', { // #3712\n                            checked: target.checked,\n                            item: item\n                        },\n                        function() {\n                            item.select();\n                        }\n                    );\n                });\n            }\n        });\n\n\n\n        // Add pointer cursor to legend itemstyle in defaultOptions\n        defaultOptions.legend.itemStyle.cursor = 'pointer';\n\n\n\n        /*\n         * Extend the Chart object with interaction\n         */\n\n        extend(Chart.prototype, /** @lends Chart.prototype */ {\n            /**\n             * Display the zoom button\n             */\n            showResetZoom: function() {\n                var chart = this,\n                    lang = defaultOptions.lang,\n                    btnOptions = chart.options.chart.resetZoomButton,\n                    theme = btnOptions.theme,\n                    states = theme.states,\n                    alignTo = btnOptions.relativeTo === 'chart' ? null : 'plotBox';\n\n                function zoomOut() {\n                    chart.zoomOut();\n                }\n\n                this.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme, states && states.hover)\n                    .attr({\n                        align: btnOptions.position.align,\n                        title: lang.resetZoomTitle\n                    })\n                    .addClass('highcharts-reset-zoom')\n                    .add()\n                    .align(btnOptions.position, false, alignTo);\n\n            },\n\n            /**\n             * Zoom out to 1:1\n             */\n            zoomOut: function() {\n                var chart = this;\n                fireEvent(chart, 'selection', {\n                    resetSelection: true\n                }, function() {\n                    chart.zoom();\n                });\n            },\n\n            /**\n             * Zoom into a given portion of the chart given by axis coordinates\n             * @param {Object} event\n             */\n            zoom: function(event) {\n                var chart = this,\n                    hasZoomed,\n                    pointer = chart.pointer,\n                    displayButton = false,\n                    resetZoomButton;\n\n                // If zoom is called with no arguments, reset the axes\n                if (!event || event.resetSelection) {\n                    each(chart.axes, function(axis) {\n                        hasZoomed = axis.zoom();\n                    });\n                } else { // else, zoom in on all axes\n                    each(event.xAxis.concat(event.yAxis), function(axisData) {\n                        var axis = axisData.axis,\n                            isXAxis = axis.isXAxis;\n\n                        // don't zoom more than minRange\n                        if (pointer[isXAxis ? 'zoomX' : 'zoomY']) {\n                            hasZoomed = axis.zoom(axisData.min, axisData.max);\n                            if (axis.displayBtn) {\n                                displayButton = true;\n                            }\n                        }\n                    });\n                }\n\n                // Show or hide the Reset zoom button\n                resetZoomButton = chart.resetZoomButton;\n                if (displayButton && !resetZoomButton) {\n                    chart.showResetZoom();\n                } else if (!displayButton && isObject(resetZoomButton)) {\n                    chart.resetZoomButton = resetZoomButton.destroy();\n                }\n\n\n                // Redraw\n                if (hasZoomed) {\n                    chart.redraw(\n                        pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100) // animation\n                    );\n                }\n            },\n\n            /**\n             * Pan the chart by dragging the mouse across the pane. This function is called\n             * on mouse move, and the distance to pan is computed from chartX compared to\n             * the first chartX position in the dragging operation.\n             */\n            pan: function(e, panning) {\n\n                var chart = this,\n                    hoverPoints = chart.hoverPoints,\n                    doRedraw;\n\n                // remove active points for shared tooltip\n                if (hoverPoints) {\n                    each(hoverPoints, function(point) {\n                        point.setState();\n                    });\n                }\n\n                each(panning === 'xy' ? [1, 0] : [1], function(isX) { // xy is used in maps\n                    var axis = chart[isX ? 'xAxis' : 'yAxis'][0],\n                        horiz = axis.horiz,\n                        mousePos = e[horiz ? 'chartX' : 'chartY'],\n                        mouseDown = horiz ? 'mouseDownX' : 'mouseDownY',\n                        startPos = chart[mouseDown],\n                        halfPointRange = (axis.pointRange || 0) / 2,\n                        extremes = axis.getExtremes(),\n                        panMin = axis.toValue(startPos - mousePos, true) +\n                        halfPointRange,\n                        panMax = axis.toValue(startPos + axis.len - mousePos, true) -\n                        halfPointRange,\n                        flipped = panMax < panMin,\n                        newMin = flipped ? panMax : panMin,\n                        newMax = flipped ? panMin : panMax,\n                        paddedMin = Math.min(\n                            extremes.dataMin,\n                            axis.toValue(\n                                axis.toPixels(extremes.min) - axis.minPixelPadding\n                            )\n                        ),\n                        paddedMax = Math.max(\n                            extremes.dataMax,\n                            axis.toValue(\n                                axis.toPixels(extremes.max) + axis.minPixelPadding\n                            )\n                        ),\n                        spill;\n\n                    // If the new range spills over, either to the min or max, adjust\n                    // the new range.\n                    spill = paddedMin - newMin;\n                    if (spill > 0) {\n                        newMax += spill;\n                        newMin = paddedMin;\n                    }\n                    spill = newMax - paddedMax;\n                    if (spill > 0) {\n                        newMax = paddedMax;\n                        newMin -= spill;\n                    }\n\n                    // Set new extremes if they are actually new\n                    if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max) {\n                        axis.setExtremes(\n                            newMin,\n                            newMax,\n                            false,\n                            false, {\n                                trigger: 'pan'\n                            }\n                        );\n                        doRedraw = true;\n                    }\n\n                    chart[mouseDown] = mousePos; // set new reference for next run\n                });\n\n                if (doRedraw) {\n                    chart.redraw(false);\n                }\n                css(chart.container, {\n                    cursor: 'move'\n                });\n            }\n        });\n\n        /*\n         * Extend the Point object with interaction\n         */\n        extend(Point.prototype, /** @lends Highcharts.Point.prototype */ {\n            /**\n             * Toggle the selection status of a point.\n             * @param  {Boolean} [selected]\n             *         When `true`, the point is selected. When `false`, the point is\n             *         unselected. When `null` or `undefined`, the selection state is\n             *         toggled.\n             * @param  {Boolean} [accumulate=false]\n             *         When `true`, the selection is added to other selected points.\n             *         When `false`, other selected points are deselected. Internally in\n             *         Highcharts, when {@link http://api.highcharts.com/highcharts/plotOptions.series.allowPointSelect|allowPointSelect}\n             *         is `true`, selected points are accumulated on Control, Shift or\n             *         Cmd clicking the point.\n             *\n             * @see    Highcharts.Chart#getSelectedPoints\n             *\n             * @sample highcharts/members/point-select/\n             *         Select a point from a button\n             * @sample highcharts/chart/events-selection-points/\n             *         Select a range of points through a drag selection\n             * @sample maps/series/data-id/\n             *         Select a point in Highmaps\n             */\n            select: function(selected, accumulate) {\n                var point = this,\n                    series = point.series,\n                    chart = series.chart;\n\n                selected = pick(selected, !point.selected);\n\n                // fire the event with the default handler\n                point.firePointEvent(selected ? 'select' : 'unselect', {\n                    accumulate: accumulate\n                }, function() {\n\n                    /**\n                     * Whether the point is selected or not. \n                     * @see Highcharts.Point#select\n                     * @memberof Highcharts.Point\n                     * @name selected\n                     * @type {Boolean}\n                     */\n                    point.selected = point.options.selected = selected;\n                    series.options.data[inArray(point, series.data)] = point.options;\n\n                    point.setState(selected && 'select');\n\n                    // unselect all other points unless Ctrl or Cmd + click\n                    if (!accumulate) {\n                        each(chart.getSelectedPoints(), function(loopPoint) {\n                            if (loopPoint.selected && loopPoint !== point) {\n                                loopPoint.selected = loopPoint.options.selected = false;\n                                series.options.data[inArray(loopPoint, series.data)] = loopPoint.options;\n                                loopPoint.setState('');\n                                loopPoint.firePointEvent('unselect');\n                            }\n                        });\n                    }\n                });\n            },\n\n            /**\n             * Runs on mouse over the point\n             * \n             * @param {Object} e The event arguments\n             */\n            onMouseOver: function(e) {\n                var point = this,\n                    series = point.series,\n                    chart = series.chart,\n                    pointer = chart.pointer;\n                e = e ?\n                    pointer.normalize(e) :\n                    // In cases where onMouseOver is called directly without an event\n                    pointer.getChartCoordinatesFromPoint(point, chart.inverted);\n                pointer.runPointActions(e, point);\n            },\n\n            /**\n             * Runs on mouse out from the point\n             */\n            onMouseOut: function() {\n                var point = this,\n                    chart = point.series.chart;\n                point.firePointEvent('mouseOut');\n                each(chart.hoverPoints || [], function(p) {\n                    p.setState();\n                });\n                chart.hoverPoints = chart.hoverPoint = null;\n            },\n\n            /**\n             * Import events from the series' and point's options. Only do it on\n             * demand, to save processing time on hovering.\n             */\n            importEvents: function() {\n                if (!this.hasImportedEvents) {\n                    var point = this,\n                        options = merge(point.series.options.point, point.options),\n                        events = options.events;\n\n                    point.events = events;\n\n                    H.objectEach(events, function(event, eventType) {\n                        addEvent(point, eventType, event);\n                    });\n                    this.hasImportedEvents = true;\n\n                }\n            },\n\n            /**\n             * Set the point's state\n             * @param {String} state\n             */\n            setState: function(state, move) {\n                var point = this,\n                    plotX = Math.floor(point.plotX), // #4586\n                    plotY = point.plotY,\n                    series = point.series,\n                    stateOptions = series.options.states[state] || {},\n                    markerOptions = defaultPlotOptions[series.type].marker &&\n                    series.options.marker,\n                    normalDisabled = markerOptions && markerOptions.enabled === false,\n                    markerStateOptions = (markerOptions && markerOptions.states &&\n                        markerOptions.states[state]) || {},\n                    stateDisabled = markerStateOptions.enabled === false,\n                    stateMarkerGraphic = series.stateMarkerGraphic,\n                    pointMarker = point.marker || {},\n                    chart = series.chart,\n                    halo = series.halo,\n                    haloOptions,\n                    markerAttribs,\n                    hasMarkers = markerOptions && series.markerAttribs,\n                    newSymbol;\n\n                state = state || ''; // empty string\n\n                if (\n                    // already has this state\n                    (state === point.state && !move) ||\n                    // selected points don't respond to hover\n                    (point.selected && state !== 'select') ||\n                    // series' state options is disabled\n                    (stateOptions.enabled === false) ||\n                    // general point marker's state options is disabled\n                    (state && (stateDisabled || (normalDisabled && markerStateOptions.enabled === false))) ||\n                    // individual point marker's state options is disabled\n                    (state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false) // #1610\n\n                ) {\n                    return;\n                }\n\n                if (hasMarkers) {\n                    markerAttribs = series.markerAttribs(point, state);\n                }\n\n                // Apply hover styles to the existing point\n                if (point.graphic) {\n\n                    if (point.state) {\n                        point.graphic.removeClass('highcharts-point-' + point.state);\n                    }\n                    if (state) {\n                        point.graphic.addClass('highcharts-point-' + state);\n                    }\n\n                    /*attribs = radius ? { // new symbol attributes (#507, #612)\n                    \tx: plotX - radius,\n                    \ty: plotY - radius,\n                    \twidth: 2 * radius,\n                    \theight: 2 * radius\n                    } : {};*/\n\n\n                    //attribs = merge(series.pointAttribs(point, state), attribs);\n                    point.graphic.attr(series.pointAttribs(point, state));\n\n\n                    if (markerAttribs) {\n                        point.graphic.animate(\n                            markerAttribs,\n                            pick(\n                                chart.options.chart.animation, // Turn off globally\n                                markerStateOptions.animation,\n                                markerOptions.animation\n                            )\n                        );\n                    }\n\n                    // Zooming in from a range with no markers to a range with markers\n                    if (stateMarkerGraphic) {\n                        stateMarkerGraphic.hide();\n                    }\n                } else {\n                    // if a graphic is not applied to each point in the normal state, create a shared\n                    // graphic for the hover state\n                    if (state && markerStateOptions) {\n                        newSymbol = pointMarker.symbol || series.symbol;\n\n                        // If the point has another symbol than the previous one, throw away the\n                        // state marker graphic and force a new one (#1459)\n                        if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {\n                            stateMarkerGraphic = stateMarkerGraphic.destroy();\n                        }\n\n                        // Add a new state marker graphic\n                        if (!stateMarkerGraphic) {\n                            if (newSymbol) {\n                                series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(\n                                        newSymbol,\n                                        markerAttribs.x,\n                                        markerAttribs.y,\n                                        markerAttribs.width,\n                                        markerAttribs.height\n                                    )\n                                    .add(series.markerGroup);\n                                stateMarkerGraphic.currentSymbol = newSymbol;\n                            }\n\n                            // Move the existing graphic\n                        } else {\n                            stateMarkerGraphic[move ? 'animate' : 'attr']({ // #1054\n                                x: markerAttribs.x,\n                                y: markerAttribs.y\n                            });\n                        }\n\n                        if (stateMarkerGraphic) {\n                            stateMarkerGraphic.attr(series.pointAttribs(point, state));\n                        }\n\n                    }\n\n                    if (stateMarkerGraphic) {\n                        stateMarkerGraphic[state && chart.isInsidePlot(plotX, plotY, chart.inverted) ? 'show' : 'hide'](); // #2450\n                        stateMarkerGraphic.element.point = point; // #4310\n                    }\n                }\n\n                // Show me your halo\n                haloOptions = stateOptions.halo;\n                if (haloOptions && haloOptions.size) {\n                    if (!halo) {\n                        series.halo = halo = chart.renderer.path()\n                            // #5818, #5903, #6705\n                            .add((point.graphic || stateMarkerGraphic).parentGroup);\n                    }\n                    halo[move ? 'animate' : 'attr']({\n                        d: point.haloPath(haloOptions.size)\n                    });\n                    halo.attr({\n                        'class': 'highcharts-halo highcharts-color-' +\n                            pick(point.colorIndex, series.colorIndex)\n                    });\n                    halo.point = point; // #6055\n\n\n                    halo.attr(extend({\n                        'fill': point.color || series.color,\n                        'fill-opacity': haloOptions.opacity,\n                        'zIndex': -1 // #4929, IE8 added halo above everything\n                    }, haloOptions.attributes));\n\n\n                } else if (halo && halo.point && halo.point.haloPath) {\n                    // Animate back to 0 on the current halo point (#6055)\n                    halo.animate({\n                        d: halo.point.haloPath(0)\n                    });\n                }\n\n                point.state = state;\n            },\n\n            /**\n             * Get the circular path definition for the halo\n             * @param  {Number} size The radius of the circular halo.\n             * @returns {Array} The path definition\n             */\n            haloPath: function(size) {\n                var series = this.series,\n                    chart = series.chart;\n\n                return chart.renderer.symbols.circle(\n                    Math.floor(this.plotX) - size,\n                    this.plotY - size,\n                    size * 2,\n                    size * 2\n                );\n            }\n        });\n\n        /*\n         * Extend the Series object with interaction\n         */\n\n        extend(Series.prototype, /** @lends Highcharts.Series.prototype */ {\n            /**\n             * Series mouse over handler\n             */\n            onMouseOver: function() {\n                var series = this,\n                    chart = series.chart,\n                    hoverSeries = chart.hoverSeries;\n\n                // set normal state to previous series\n                if (hoverSeries && hoverSeries !== series) {\n                    hoverSeries.onMouseOut();\n                }\n\n                // trigger the event, but to save processing time,\n                // only if defined\n                if (series.options.events.mouseOver) {\n                    fireEvent(series, 'mouseOver');\n                }\n\n                // hover this\n                series.setState('hover');\n                chart.hoverSeries = series;\n            },\n\n            /**\n             * Series mouse out handler\n             */\n            onMouseOut: function() {\n                // trigger the event only if listeners exist\n                var series = this,\n                    options = series.options,\n                    chart = series.chart,\n                    tooltip = chart.tooltip,\n                    hoverPoint = chart.hoverPoint;\n\n                chart.hoverSeries = null; // #182, set to null before the mouseOut event fires\n\n                // trigger mouse out on the point, which must be in this series\n                if (hoverPoint) {\n                    hoverPoint.onMouseOut();\n                }\n\n                // fire the mouse out event\n                if (series && options.events.mouseOut) {\n                    fireEvent(series, 'mouseOut');\n                }\n\n\n                // hide the tooltip\n                if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {\n                    tooltip.hide();\n                }\n\n                // set normal state\n                series.setState();\n            },\n\n            /**\n             * Set the state of the graph\n             */\n            setState: function(state) {\n                var series = this,\n                    options = series.options,\n                    graph = series.graph,\n                    stateOptions = options.states,\n                    lineWidth = options.lineWidth,\n                    attribs,\n                    i = 0;\n\n                state = state || '';\n\n                if (series.state !== state) {\n\n                    // Toggle class names\n                    each([\n                        series.group,\n                        series.markerGroup,\n                        series.dataLabelsGroup\n                    ], function(group) {\n                        if (group) {\n                            // Old state\n                            if (series.state) {\n                                group.removeClass('highcharts-series-' + series.state);\n                            }\n                            // New state\n                            if (state) {\n                                group.addClass('highcharts-series-' + state);\n                            }\n                        }\n                    });\n\n                    series.state = state;\n\n\n\n                    if (stateOptions[state] && stateOptions[state].enabled === false) {\n                        return;\n                    }\n\n                    if (state) {\n                        lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0); // #4035\n                    }\n\n                    if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML\n                        attribs = {\n                            'stroke-width': lineWidth\n                        };\n\n                        // Animate the graph stroke-width. By default a quick animation\n                        // to hover, slower to un-hover.\n                        graph.animate(\n                            attribs,\n                            pick(\n                                series.chart.options.chart.animation,\n                                stateOptions[state] && stateOptions[state].animation\n                            )\n                        );\n                        while (series['zone-graph-' + i]) {\n                            series['zone-graph-' + i].attr(attribs);\n                            i = i + 1;\n                        }\n                    }\n\n                }\n            },\n\n            /**\n             * Show or hide the series.\n             *\n             * @param  {Boolean} [visible]\n             *         True to show the series, false to hide. If undefined, the\n             *         visibility is toggled.\n             * @param  {Boolean} [redraw=true]\n             *         Whether to redraw the chart after the series is altered. If doing\n             *         more operations on the chart, it is a good idea to set redraw to\n             *         false and call {@link Chart#redraw|chart.redraw()} after.\n             */\n            setVisible: function(vis, redraw) {\n                var series = this,\n                    chart = series.chart,\n                    legendItem = series.legendItem,\n                    showOrHide,\n                    ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,\n                    oldVisibility = series.visible;\n\n                // if called without an argument, toggle visibility\n                series.visible = vis = series.options.visible = series.userOptions.visible = vis === undefined ? !oldVisibility : vis; // #5618\n                showOrHide = vis ? 'show' : 'hide';\n\n                // show or hide elements\n                each(['group', 'dataLabelsGroup', 'markerGroup', 'tracker', 'tt'], function(key) {\n                    if (series[key]) {\n                        series[key][showOrHide]();\n                    }\n                });\n\n\n                // hide tooltip (#1361)\n                if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {\n                    series.onMouseOut();\n                }\n\n\n                if (legendItem) {\n                    chart.legend.colorizeItem(series, vis);\n                }\n\n\n                // rescale or adapt to resized chart\n                series.isDirty = true;\n                // in a stack, all other series are affected\n                if (series.options.stacking) {\n                    each(chart.series, function(otherSeries) {\n                        if (otherSeries.options.stacking && otherSeries.visible) {\n                            otherSeries.isDirty = true;\n                        }\n                    });\n                }\n\n                // show or hide linked series\n                each(series.linkedSeries, function(otherSeries) {\n                    otherSeries.setVisible(vis, false);\n                });\n\n                if (ignoreHiddenSeries) {\n                    chart.isDirtyBox = true;\n                }\n                if (redraw !== false) {\n                    chart.redraw();\n                }\n\n                fireEvent(series, showOrHide);\n            },\n\n            /**\n             * Show the series if hidden.\n             *\n             * @sample highcharts/members/series-hide/\n             *         Toggle visibility from a button\n             */\n            show: function() {\n                this.setVisible(true);\n            },\n\n            /**\n             * Hide the series if visible. If the {@link\n             * https://api.highcharts.com/highcharts/chart.ignoreHiddenSeries|\n             * chart.ignoreHiddenSeries} option is true, the chart is redrawn without\n             * this series.\n             *\n             * @sample highcharts/members/series-hide/\n             *         Toggle visibility from a button\n             */\n            hide: function() {\n                this.setVisible(false);\n            },\n\n\n            /**\n             * Select or unselect the series. This means its {@link\n             * Highcharts.Series.selected|selected} property is set, the checkbox in the\n             * legend is toggled and when selected, the series is returned by the\n             * {@link Highcharts.Chart#getSelectedSeries} function.\n             *\n             * @param  {Boolean} [selected]\n             *         True to select the series, false to unselect. If\tundefined, the\n             *         selection state is toggled.\n             *\n             * @sample highcharts/members/series-select/\n             *         Select a series from a button\n             */\n            select: function(selected) {\n                var series = this;\n\n                series.selected = selected = (selected === undefined) ?\n                    !series.selected :\n                    selected;\n\n                if (series.checkbox) {\n                    series.checkbox.checked = selected;\n                }\n\n                fireEvent(series, selected ? 'select' : 'unselect');\n            },\n\n            drawTracker: TrackerMixin.drawTrackerGraph\n        });\n\n    }(Highcharts));\n    (function(H) {\n        /**\n         * (c) 2010-2017 Torstein Honsi\n         *\n         * License: www.highcharts.com/license\n         */\n        var Chart = H.Chart,\n            each = H.each,\n            inArray = H.inArray,\n            isArray = H.isArray,\n            isObject = H.isObject,\n            pick = H.pick,\n            splat = H.splat;\n\n        /**\n         * Update the chart based on the current chart/document size and options for\n         * responsiveness.\n         */\n        Chart.prototype.setResponsive = function(redraw) {\n            var options = this.options.responsive,\n                ruleIds = [],\n                currentResponsive = this.currentResponsive,\n                currentRuleIds;\n\n            if (options && options.rules) {\n                each(options.rules, function(rule) {\n                    if (rule._id === undefined) {\n                        rule._id = H.uniqueKey();\n                    }\n\n                    this.matchResponsiveRule(rule, ruleIds, redraw);\n                }, this);\n            }\n\n            // Merge matching rules\n            var mergedOptions = H.merge.apply(0, H.map(ruleIds, function(ruleId) {\n                return H.find(options.rules, function(rule) {\n                    return rule._id === ruleId;\n                }).chartOptions;\n            }));\n\n            // Stringified key for the rules that currently apply.\n            ruleIds = ruleIds.toString() || undefined;\n            currentRuleIds = currentResponsive && currentResponsive.ruleIds;\n\n\n            // Changes in what rules apply\n            if (ruleIds !== currentRuleIds) {\n\n                // Undo previous rules. Before we apply a new set of rules, we need to\n                // roll back completely to base options (#6291).\n                if (currentResponsive) {\n                    this.update(currentResponsive.undoOptions, redraw);\n                }\n\n                if (ruleIds) {\n                    // Get undo-options for matching rules\n                    this.currentResponsive = {\n                        ruleIds: ruleIds,\n                        mergedOptions: mergedOptions,\n                        undoOptions: this.currentOptions(mergedOptions)\n                    };\n\n                    this.update(mergedOptions, redraw);\n\n                } else {\n                    this.currentResponsive = undefined;\n                }\n            }\n        };\n\n        /**\n         * Handle a single responsiveness rule\n         */\n        Chart.prototype.matchResponsiveRule = function(rule, matches) {\n            var condition = rule.condition,\n                fn = condition.callback || function() {\n                    return this.chartWidth <= pick(condition.maxWidth, Number.MAX_VALUE) &&\n                        this.chartHeight <= pick(condition.maxHeight, Number.MAX_VALUE) &&\n                        this.chartWidth >= pick(condition.minWidth, 0) &&\n                        this.chartHeight >= pick(condition.minHeight, 0);\n                };\n\n            if (fn.call(this)) {\n                matches.push(rule._id);\n            }\n\n        };\n\n        /**\n         * Get the current values for a given set of options. Used before we update\n         * the chart with a new responsiveness rule.\n         * TODO: Restore axis options (by id?)\n         */\n        Chart.prototype.currentOptions = function(options) {\n\n            var ret = {};\n\n            /**\n             * Recurse over a set of options and its current values,\n             * and store the current values in the ret object.\n             */\n            function getCurrent(options, curr, ret, depth) {\n                var i;\n                H.objectEach(options, function(val, key) {\n                    if (!depth && inArray(key, ['series', 'xAxis', 'yAxis']) > -1) {\n                        options[key] = splat(options[key]);\n\n                        ret[key] = [];\n\n                        // Iterate over collections like series, xAxis or yAxis and map\n                        // the items by index.\n                        for (i = 0; i < options[key].length; i++) {\n                            if (curr[key][i]) { // Item exists in current data (#6347)\n                                ret[key][i] = {};\n                                getCurrent(\n                                    val[i],\n                                    curr[key][i],\n                                    ret[key][i],\n                                    depth + 1\n                                );\n                            }\n                        }\n                    } else if (isObject(val)) {\n                        ret[key] = isArray(val) ? [] : {};\n                        getCurrent(val, curr[key] || {}, ret[key], depth + 1);\n                    } else {\n                        ret[key] = curr[key] || null;\n                    }\n                });\n            }\n\n            getCurrent(options, this.options, ret, 0);\n            return ret;\n        };\n\n    }(Highcharts));\n    return Highcharts\n}));\n";
}])},578:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=15)}({0:function(e,n){e.exports=t("require/underscore")},1:function(e,n){e.exports=t("shim/jquery")},15:function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}function r(e){this.renderer=e,this.ELLIPSIS="..."}Object.defineProperty(n,"__esModule",{value:!0});var a=t(1),o=i(a),s=t(0),l=i(s);r.prototype={ellipsize:function(e,n,t,i,r){(0,l["default"])(e).isArray()&&(e=e.join(",")),e=o["default"].trim(e);var a=e.length;if(!e||""===e)return"";if(a<=3||!t||isNaN(t)||t<=0)return e;if(!n||isNaN(n)||n<=0)return this.ELLIPSIS;var s=this._predictLineWidth(e,t,i),h=s-n;if(!(h>0))return e;var d=this._predictLineWidth(this.ELLIPSIS,t,i);switch(r){case"end":return this.trimStringToWidth(e,n-d,t,i)+"...";case"start":return"..."+this.reverseString(this.trimStringToWidth(this.reverseString(e),n-d,t,i));default:var c=(n-d)/2,p=this.trimStringToWidth(e,c,t,i),u=this.reverseString(this.trimStringToWidth(this.reverseString(e),c,t,i));return p+"..."+u}},trimStringToWidth:function(e,n,t,i){var r=this,a=function(a,o){for(var s=void 0;o>a+1;)s=Math.floor((a+o)/2),r.predictTextWidth(e.substr(0,s),t,i)>n?o=s:a=s;return a},o=a(0,e.length);return e.substr(0,o)},reverseString:function(e){return e.split("").reverse().join("")},predictTextWidth:function(e,n,t){if((0,l["default"])(e).isArray()&&(e=e.join(",")),!e||""===e||!n||isNaN(n))return 0;var i=e.split(/\s*<br\s*\/?>\s*/),r=i.length;if(r>1){for(var a=0,s=0;s<r;s++)if(i[s]&&""!==i[s]){var h=this._predictLineWidth(i[s],n,t);h>a&&(a=h)}return a}var d=this._predictLineWidth(o["default"].trim(e),n,t);return d},_predictLineWidth:function(e,n,t){if(!e||!n)return 0;var i=this.getTextBBox(e,n,t);return i?i.width:0},predictTextHeight:function(e,n,t){if((0,l["default"])(e).isArray()&&(e=e.join(",")),!n||!e)return 0;var i=this.getTextBBox(e,n,t);return i?i.height:0},getTextBBox:function(e,n,t){if(t=o["default"].extend(t,{fontSize:n+"px"}),!isNaN(parseFloat(n,10)))return this.textPredicter&&this.textPredicter.destroy(),this.textPredicter=this.renderer.text(e,0,0).attr({visibility:"hidden"}).css(t).add(),this.textPredicter.getBBox()},adjustLabels:function(e,n,t,i,r){var a=void 0,s=void 0,l=void 0,h=o["default"].extend(!0,[],e),d=this.getMaxWidthForFontRange(h,t,i);if(d[i]<=n)l=!1,s=i;else for(l=!0,s=i-1;s>t;s--)if(d[s]<=n){l=!1;break}if(l&&"none"!==r)for(a=0;a<h.length;a++)h[a]=this.ellipsize(h[a],n,s,{},r);return{labels:h,fontSize:s,areEllipsized:l,longestWidth:d[s]}},getMaxWidthForFontRange:function(e,n,t){var i=void 0,r={};r[n]=0;for(var a=0;a<e.length;a++){var o=this.predictTextWidth(e[a]||"",n);o>r[n]&&(i=a,r[n]=o)}for(var s=n+1;s<=t;s++)r[s]=this.predictTextWidth(e[i]||"",s);return r},bBoxesOverlap:function(e,n,t,i){t=t||0,i=i||0;var r=e.x-t,a=n.x-t,o=e.x+e.width+2*t,s=n.x+n.width+2*t,l=e.y-i,h=n.y-i,d=e.y+e.height+2*i,c=n.y+n.height+2*i;return r<s&&o>a&&l<c&&d>h},destroy:function(){this.textPredicter&&(this.textPredicter.destroy(),this.textPredicter=!1)}},n["default"]=r,e.exports=n["default"]}})},579:function(e,n){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=2)}({2:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),window.locale_name()in{ko_KR:!0,zh_CN:!0,zh_TW:!0}&&(window._i18n_locale.date_formats["short"]={pattern:"yy/MM/dd",format:"%(yy)s/%(MM)s/%(dd)s"},window._i18n_locale.date_formats.medium={pattern:"yyyy/MM/dd",format:"%(yyyy)s/%(MM)s/%(dd)s"},window._i18n_locale.time_formats["short"]={pattern:"H:mm",format:"%(H)s:%(mm)s"},window._i18n_locale.time_formats.medium={pattern:"H:mm:ss",format:"%(H)s:%(mm)s:%(ss)s"});var i=[[/^ccc MMM d$/,"M/d (ccc)"],[/^YYYY-MM/,"YYYY/MM"],[/MM-dd/,"MM/dd"]],r={ja_JP:i,ko_KR:i,zh_CN:i,zh_TW:i},a=[["MMM d","d MMM"]],o=window.format_date;window.format_date=function(e,n){n=n||"medium";var t,i,s=window.locale_name();if(n&&"string"==typeof n&&window.locale_uses_day_before_month())for(i=a,t=0;t<i.length;t++)n=n.replace(i[t][0],i[t][1]);if(n&&"string"==typeof n&&s in r)for(i=r[s],t=0;t<i.length;t++){var l=i[t];n=n.replace(l[0],l[1])}return o(e,n)},n["default"]={_:window.gettext,ungettext:window.ungettext,format_decimal:window.format_decimal,format_number:window.format_number,format_percent:window.format_percent,format_scientific:window.format_scientific,format_date:window.format_date,format_datetime:window.format_datetime,format_time:window.format_time,format_datetime_microseconds:window.format_datetime_microseconds,format_time_microseconds:window.format_time_microseconds,locale_uses_day_before_month:window.locale_uses_day_before_month,format_datetime_range:window.format_datetime_range,locale_name:window.locale_name,DateTime:window.DateTime,moment_install:window.moment_install,numeral_install:window.numeral_install,jQuery_ui_datepicker_install:window.jQuery_ui_datepicker_install},e.exports=n["default"]}})},580:function(e,n,t){/*!
	 * Bowser - a browser detector
	 * https://github.com/ded/bowser
	 * MIT License | (c) Dustin Diaz 2015
	 */
!function(n,i,r){"undefined"!=typeof e&&e.exports?e.exports=r():t(581)(i,r)}(this,"bowser",function(){function e(e){function n(n){var t=e.match(n);return t&&t.length>1&&t[1]||""}function t(n){var t=e.match(n);return t&&t.length>1&&t[2]||""}function i(e){switch(e){case"NT":return"NT";case"XP":return"XP";case"NT 5.0":return"2000";case"NT 5.1":return"XP";case"NT 5.2":return"2003";case"NT 6.0":return"Vista";case"NT 6.1":return"7";case"NT 6.2":return"8";case"NT 6.3":return"8.1";case"NT 10.0":return"10";default:return}}var r,a=n(/(ipod|iphone|ipad)/i).toLowerCase(),s=/like android/i.test(e),l=!s&&/android/i.test(e),h=/nexus\s*[0-6]\s*/i.test(e),d=!h&&/nexus\s*[0-9]+/i.test(e),c=/CrOS/.test(e),p=/silk/i.test(e),u=/sailfish/i.test(e),f=/tizen/i.test(e),m=/(web|hpw)os/i.test(e),g=/windows phone/i.test(e),x=(/SamsungBrowser/i.test(e),!g&&/windows/i.test(e)),b=!a&&!p&&/macintosh/i.test(e),y=!l&&!u&&!f&&!m&&/linux/i.test(e),v=t(/edg([ea]|ios)\/(\d+(\.\d+)?)/i),w=n(/version\/(\d+(\.\d+)?)/i),k=/tablet/i.test(e)&&!/tablet pc/i.test(e),S=!k&&/[^-]mobi/i.test(e),T=/xbox/i.test(e);/opera/i.test(e)?r={name:"Opera",opera:o,version:w||n(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)}:/opr\/|opios/i.test(e)?r={name:"Opera",opera:o,version:n(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i)||w}:/SamsungBrowser/i.test(e)?r={name:"Samsung Internet for Android",samsungBrowser:o,version:w||n(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)}:/coast/i.test(e)?r={name:"Opera Coast",coast:o,version:w||n(/(?:coast)[\s\/](\d+(\.\d+)?)/i)}:/yabrowser/i.test(e)?r={name:"Yandex Browser",yandexbrowser:o,version:w||n(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)}:/ucbrowser/i.test(e)?r={name:"UC Browser",ucbrowser:o,version:n(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)}:/mxios/i.test(e)?r={name:"Maxthon",maxthon:o,version:n(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)}:/epiphany/i.test(e)?r={name:"Epiphany",epiphany:o,version:n(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)}:/puffin/i.test(e)?r={name:"Puffin",puffin:o,version:n(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)}:/sleipnir/i.test(e)?r={name:"Sleipnir",sleipnir:o,version:n(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)}:/k-meleon/i.test(e)?r={name:"K-Meleon",kMeleon:o,version:n(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)}:g?(r={name:"Windows Phone",osname:"Windows Phone",windowsphone:o},v?(r.msedge=o,r.version=v):(r.msie=o,r.version=n(/iemobile\/(\d+(\.\d+)?)/i))):/msie|trident/i.test(e)?r={name:"Internet Explorer",msie:o,version:n(/(?:msie |rv:)(\d+(\.\d+)?)/i)}:c?r={name:"Chrome",osname:"Chrome OS",chromeos:o,chromeBook:o,chrome:o,version:n(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)}:/edg([ea]|ios)/i.test(e)?r={name:"Microsoft Edge",msedge:o,version:v}:/vivaldi/i.test(e)?r={name:"Vivaldi",vivaldi:o,version:n(/vivaldi\/(\d+(\.\d+)?)/i)||w}:u?r={name:"Sailfish",osname:"Sailfish OS",sailfish:o,version:n(/sailfish\s?browser\/(\d+(\.\d+)?)/i)}:/seamonkey\//i.test(e)?r={name:"SeaMonkey",seamonkey:o,version:n(/seamonkey\/(\d+(\.\d+)?)/i)}:/firefox|iceweasel|fxios/i.test(e)?(r={name:"Firefox",firefox:o,version:n(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)},/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(e)&&(r.firefoxos=o,r.osname="Firefox OS")):p?r={name:"Amazon Silk",silk:o,version:n(/silk\/(\d+(\.\d+)?)/i)}:/phantom/i.test(e)?r={name:"PhantomJS",phantom:o,version:n(/phantomjs\/(\d+(\.\d+)?)/i)}:/slimerjs/i.test(e)?r={name:"SlimerJS",slimer:o,version:n(/slimerjs\/(\d+(\.\d+)?)/i)}:/blackberry|\bbb\d+/i.test(e)||/rim\stablet/i.test(e)?r={name:"BlackBerry",osname:"BlackBerry OS",blackberry:o,version:w||n(/blackberry[\d]+\/(\d+(\.\d+)?)/i)}:m?(r={name:"WebOS",osname:"WebOS",webos:o,version:w||n(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)},/touchpad\//i.test(e)&&(r.touchpad=o)):/bada/i.test(e)?r={name:"Bada",osname:"Bada",bada:o,version:n(/dolfin\/(\d+(\.\d+)?)/i)}:f?r={name:"Tizen",osname:"Tizen",tizen:o,version:n(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i)||w}:/qupzilla/i.test(e)?r={name:"QupZilla",qupzilla:o,version:n(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i)||w}:/chromium/i.test(e)?r={name:"Chromium",chromium:o,version:n(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i)||w}:/chrome|crios|crmo/i.test(e)?r={name:"Chrome",chrome:o,version:n(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)}:l?r={name:"Android",version:w}:/safari|applewebkit/i.test(e)?(r={name:"Safari",safari:o},w&&(r.version=w)):a?(r={name:"iphone"==a?"iPhone":"ipad"==a?"iPad":"iPod"},w&&(r.version=w)):r=/googlebot/i.test(e)?{name:"Googlebot",googlebot:o,version:n(/googlebot\/(\d+(\.\d+))/i)||w}:{name:n(/^(.*)\/(.*) /),version:t(/^(.*)\/(.*) /)},!r.msedge&&/(apple)?webkit/i.test(e)?(/(apple)?webkit\/537\.36/i.test(e)?(r.name=r.name||"Blink",r.blink=o):(r.name=r.name||"Webkit",r.webkit=o),!r.version&&w&&(r.version=w)):!r.opera&&/gecko\//i.test(e)&&(r.name=r.name||"Gecko",r.gecko=o,r.version=r.version||n(/gecko\/(\d+(\.\d+)?)/i)),r.windowsphone||!l&&!r.silk?!r.windowsphone&&a?(r[a]=o,r.ios=o,r.osname="iOS"):b?(r.mac=o,r.osname="macOS"):T?(r.xbox=o,r.osname="Xbox"):x?(r.windows=o,r.osname="Windows"):y&&(r.linux=o,r.osname="Linux"):(r.android=o,r.osname="Android");var O="";r.windows?O=i(n(/Windows ((NT|XP)( \d\d?.\d)?)/i)):r.windowsphone?O=n(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i):r.mac?(O=n(/Mac OS X (\d+([_\.\s]\d+)*)/i),O=O.replace(/[_\s]/g,".")):a?(O=n(/os (\d+([_\s]\d+)*) like mac os x/i),O=O.replace(/[_\s]/g,".")):l?O=n(/android[ \/-](\d+(\.\d+)*)/i):r.webos?O=n(/(?:web|hpw)os\/(\d+(\.\d+)*)/i):r.blackberry?O=n(/rim\stablet\sos\s(\d+(\.\d+)*)/i):r.bada?O=n(/bada\/(\d+(\.\d+)*)/i):r.tizen&&(O=n(/tizen[\/\s](\d+(\.\d+)*)/i)),O&&(r.osversion=O);var M=!r.windows&&O.split(".")[0];return k||d||"ipad"==a||l&&(3==M||M>=4&&!S)||r.silk?r.tablet=o:(S||"iphone"==a||"ipod"==a||l||h||r.blackberry||r.webos||r.bada)&&(r.mobile=o),r.msedge||r.msie&&r.version>=10||r.yandexbrowser&&r.version>=15||r.vivaldi&&r.version>=1||r.chrome&&r.version>=20||r.samsungBrowser&&r.version>=4||r.firefox&&r.version>=20||r.safari&&r.version>=6||r.opera&&r.version>=10||r.ios&&r.osversion&&r.osversion.split(".")[0]>=6||r.blackberry&&r.version>=10.1||r.chromium&&r.version>=20?r.a=o:r.msie&&r.version<10||r.chrome&&r.version<20||r.firefox&&r.version<20||r.safari&&r.version<6||r.opera&&r.version<10||r.ios&&r.osversion&&r.osversion.split(".")[0]<6||r.chromium&&r.version<20?r.c=o:r.x=o,r}function n(e){return e.split(".").length}function t(e,n){var t,i=[];if(Array.prototype.map)return Array.prototype.map.call(e,n);for(t=0;t<e.length;t++)i.push(n(e[t]));return i}function i(e){for(var i=Math.max(n(e[0]),n(e[1])),r=t(e,function(e){var r=i-n(e);return e+=new Array(r+1).join(".0"),t(e.split("."),function(e){return new Array(20-e.length).join("0")+e}).reverse()});--i>=0;){if(r[0][i]>r[1][i])return 1;if(r[0][i]!==r[1][i])return-1;if(0===i)return 0}}function r(n,t,r){var a=s;"string"==typeof t&&(r=t,t=void 0),void 0===t&&(t=!1),r&&(a=e(r));var o=""+a.version;for(var l in n)if(n.hasOwnProperty(l)&&a[l]){if("string"!=typeof n[l])throw new Error("Browser version in the minVersion map should be a string: "+l+": "+String(n));return i([o,n[l]])<0}return t}function a(e,n,t){return!r(e,n,t)}var o=!0,s=e("undefined"!=typeof navigator?navigator.userAgent||"":"");return s.test=function(e){for(var n=0;n<e.length;++n){var t=e[n];if("string"==typeof t&&t in s)return!0}return!1},s.isUnsupportedBrowser=r,s.compareVersions=i,s.check=a,s._detect=e,s.detect=e,s})},"util/theme_utils":function(e,n,t){"use strict";function i(){return window.__splunk_page_theme__||o}function r(){var e=i();return"dark"===e?"ace/theme/xml-dark":"ace/theme/chrome"}function a(){var e=i();return"dark"===e?"dark":"light"}t(546),Object.defineProperty(n,"__esModule",{value:!0}),n.getCurrentTheme=i,n.getXmlEditorTheme=r,n.getSearchEditorTheme=a;var o="light"},"shim/splunk.legend":function(e,n,t){var i,r;i=[t("shim/splunk"),t("legend")],r=function(e){return e.Legend}.apply(n,i),!(void 0!==r&&(e.exports=r))},legend:function(e,n){Splunk.Legend={_numLabels:0,_targetMap:{},_targetList:[],_labelMap:{},_labelList:[],_isLabelMapValid:!0,_timeoutID:0,_listeners:{},numLabels:function(){return this._validateLabelMap(),this._numLabels},register:function(e){if(null==e)throw new Error("Parameter id must be non-null.");var n=this._getOwn(this._targetMap,e);n||(n={id:e,labels:null,sortIndex:+e.match(/\d+/g).join("")},this._targetMap[e]=n,this._targetList.push(n),this._targetList.sort(function(e,n){return e.sortIndex-n.sortIndex}))},unregister:function(e){var n=this._getOwn(this._targetMap,e);if(n){for(var t=this._targetList.length-1;t>=0;t--)if(this._targetList[t]===n){this._targetList.splice(t,1);break}delete this._targetMap[e],this._invalidateLabelMap()}},setLabels:function(e,n){var t=this._getOwn(this._targetMap,e);t&&(t.labels=n?n.concat():null,this._invalidateLabelMap())},getLabelIndex:function(e){this._validateLabelMap();var n=this._getOwn(this._labelMap,e);return null!=n?n:-1},getLabelAt:function(e){return this._validateLabelMap(),e=Math.floor(e),e>=0&&e<this._labelList.length?this._labelList[e]:null},addEventListener:function(e,n){var t=this._getOwn(this._listeners,e);t||(t=this._listeners[e]=[]);for(var i=t.length,r=0;r<i;r++)if(t[r]===n)return;t.push(n)},removeEventListener:function(e,n){var t=this._getOwn(this._listeners,e);if(t)for(var i=t.length,r=0;r<i;r++)if(t[r]===n)return void t.splice(r,1)},dispatchEvent:function(e){var n=this._getOwn(this._listeners,e);if(n){n=n.concat();var t,i=[],r=arguments.length;for(t=1;t<r;t++)i.push(arguments[t]);var a,o=n.length;for(t=0;t<o;t++){a=n[t];try{a.apply(null,i)}catch(s){}}}},_invalidateLabelMap:function(){if(this._isLabelMapValid){this._isLabelMapValid=!1;var e=this,n=function(){e._validateLabelMap()};this._timeoutID=setTimeout(n,0)}},_validateLabelMap:function(){this._isLabelMapValid||(this._updateLabelMap(),this._isLabelMapValid=!0,clearTimeout(this._timeoutID))},_updateLabelMap:function(){var e,n,t,i,r,a,o,s=this._labelList,l=!1,h={},d=[],c=this._targetList,p=c.length;for(a=0;a<p;a++)if(e=c[a],n=e.labels)for(t=n.length,o=0;o<t;o++)i=n[o],null==this._getOwn(h,i)&&(h[i]=d.length,d.push(i));if(r=d.length,r!==s.length)l=!0;else for(a=0;a<r;a++)if(d[a]!==s[a]){l=!0;break}l&&(this._labelMap=h,this._labelList=d,this._numLabels=r,this.dispatchEvent("labelIndexMapChanged"))},_getOwn:function(e,n){return Object.prototype.hasOwnProperty.call(e,n)?e[n]:void 0}}},581:function(e,n){e.exports=function(){throw new Error("define cannot be used indirect")}},"util/jscharting_utils":function(e,n,t){var i,r;i=[t("require/underscore"),t("helpers/user_agent"),t("models/config"),t("splunk/palettes/ColorCodes"),t("util/console"),t("util/theme_utils"),t("shim/splunk.util"),t("stubs/i18n")],r=function(e,n,t,i,r,a,o,s){var l=function(e){return parseInt(e,10)||1/0},h=/^[^_]|^_time/,d=l(o.getConfigValue("JSCHART_SERIES_LIMIT",100)),c=5e4,p=function(){var e=o.getConfigValue("JSCHART_TRUNCATION_LIMIT",c);return l(null!==e?e:n.isFirefox()?o.getConfigValue("JSCHART_TRUNCATION_LIMIT_FIREFOX",c):n.isSafari()?o.getConfigValue("JSCHART_TRUNCATION_LIMIT_SAFARI",c):n.isIE11()?o.getConfigValue("JSCHART_TRUNCATION_LIMIT_IE11",c):o.getConfigValue("JSCHART_TRUNCATION_LIMIT_CHROME",c))}(),u=function(e,n){n=n||{};var t={};return n.JSCHART_TEST_MODE&&(t.testMode=!0),e.hasField("_tc")&&(t.fieldHideList=["percent"]),t},f=function(n,t){var i={fields:n.fields,columns:[]};return e(n.columns).each(function(e,n){i.columns[n]=e.slice(0,t)}),i},m=function(n){var t=e.isString(n)?n:n.name;return h.test(t)},g=function(n,t){if(0===n.columns.length||0===n.columns[0].length)return n;var i=t.chart||"column";if(i in{pie:!0,scatter:!0,radialGauge:!0,fillerGauge:!0,markerGauge:!0})return n;if(n.fields.length>=d){var r,a=e(n.fields).map(function(n){return e.isString(n)?n:n.name}),o=e(a).indexOf("_span");o>-1&&o>=d&&(r=n.columns[o]),n={columns:n.columns.slice(0,d),fields:n.fields.slice(0,d)},r&&(n.columns.push(r),n.fields.push("_span"))}var s=parseInt(t["chart.resultTruncationLimit"],10)||parseInt(t.resultTruncationLimit,10),l=s>0?s:p,h=e(n.fields).filter(m),c=h.length-1,u=n.columns[0].length,g=Math.floor(l/c);return u>g?f(n,g):n},x=function(e,n){n=n||{},e.setLoggingConsole(r),"dark"===a.getCurrentTheme()&&e.setTheme("dark"),e.setColorPalette(i.CATEGORICAL),e.setTimezone(n.SERVER_ZONEINFO||t.get("SERVER_ZONEINFO")),e.useSplunkI18nLibrary(s)};return{getCustomDisplayProperties:u,preprocessChartData:g,prepareChartingLibrary:x,getSeriesLimit:function(){return d},setSeriesLimit:function(e){d=e},getTruncationLimit:function(){return p},setTruncationLimit:function(e){p=e}}}.apply(n,i),!(void 0!==r&&(e.exports=r))},582:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=50)}({0:function(e,n){e.exports=t("require/underscore")},2:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),window.locale_name()in{ko_KR:!0,zh_CN:!0,zh_TW:!0}&&(window._i18n_locale.date_formats["short"]={pattern:"yy/MM/dd",format:"%(yy)s/%(MM)s/%(dd)s"},window._i18n_locale.date_formats.medium={pattern:"yyyy/MM/dd",format:"%(yyyy)s/%(MM)s/%(dd)s"},window._i18n_locale.time_formats["short"]={pattern:"H:mm",format:"%(H)s:%(mm)s"},window._i18n_locale.time_formats.medium={pattern:"H:mm:ss",format:"%(H)s:%(mm)s:%(ss)s"});var i=[[/^ccc MMM d$/,"M/d (ccc)"],[/^YYYY-MM/,"YYYY/MM"],[/MM-dd/,"MM/dd"]],r={ja_JP:i,ko_KR:i,zh_CN:i,zh_TW:i},a=[["MMM d","d MMM"]],o=window.format_date;window.format_date=function(e,n){n=n||"medium";var t,i,s=window.locale_name();if(n&&"string"==typeof n&&window.locale_uses_day_before_month())for(i=a,t=0;t<i.length;t++)n=n.replace(i[t][0],i[t][1]);if(n&&"string"==typeof n&&s in r)for(i=r[s],t=0;t<i.length;t++){var l=i[t];n=n.replace(l[0],l[1])}return o(e,n)},n["default"]={_:window.gettext,ungettext:window.ungettext,format_decimal:window.format_decimal,format_number:window.format_number,format_percent:window.format_percent,format_scientific:window.format_scientific,format_date:window.format_date,format_datetime:window.format_datetime,format_time:window.format_time,format_datetime_microseconds:window.format_datetime_microseconds,format_time_microseconds:window.format_time_microseconds,locale_uses_day_before_month:window.locale_uses_day_before_month,format_datetime_range:window.format_datetime_range,locale_name:window.locale_name,DateTime:window.DateTime,moment_install:window.moment_install,numeral_install:window.numeral_install,jQuery_ui_datepicker_install:window.jQuery_ui_datepicker_install},e.exports=n["default"]},50:function(e,n,t){"use strict";function i(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n["default"]=e,n}function r(e){return e&&e.__esModule?e:{"default":e}}function a(e){var n=f.exec(e)||m.exec(e);n?(this.year=parseInt(n[1],10),this.month=parseInt(n[2],10),this.day=parseInt(n[3],10),this.hour=parseInt(n[4],10),this.minute=parseInt(n[5],10),this.second=parseInt(n[6],10),this.millisecond=n.length>7?parseInt(n[7],10):0):this.isInvalid=!0}Object.defineProperty(n,"__esModule",{value:!0});var o=t(0),s=r(o),l=t(51),h=r(l),d=t(2),c=r(d),p=t(6),u=i(p),f=/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})\.(\d+)[+-]{1}\d{2}[:]?\d{2}$/,m=/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})[+-]{1}\d{2}[:]?\d{2}$/,g=function(e){return new a(e)},x=function(e,n){var t=parseFloat(n[0]);return e instanceof a||(e=g(e)),t?t>=0&&t<1||0!==e.millisecond?"millisecond":t>=1&&t<60||0!==e.second?"second":t>=60&&t<3600||0!==e.minute?"minute":t>=3600&&t<=82800||0!==e.hour?"hour":t>82800&&t<=2419200||1!==e.day?"day":t>2419200&&t<=31535999||1!==e.month?"month":t>=31536e3?"year":(u.log("_span value ("+t+") did not meet any time formatting condition"),"second"):0===e.millisecond?"second":"millisecond"},b=function(e){var n=e.year,t=e.month-1,i=e.day,r=e.hour,a=e.minute,o=e.second,s=e.millisecond;return new Date(n,t,i,r,a,o,s)},y={SECS_PER_MIN:60,SECS_PER_HOUR:3600,isoToDateObject:function(e){return(0,h["default"])(e).toDate()},getEpochTimeFromISO:function(e){var n=y.isoToDateObject(e).getTime();return(n/1e3).toFixed(3)},extractBdTime:function(e){return g(e)},determineLabelGranularity:function(e,n){if(e[0]instanceof a||(e=(0,s["default"])(e).map(y.extractBdTime)),e=(0,s["default"])(e).filter(function(e){return!e.isInvalid}),1===e.length&&(!n||0===n.length))return 0===e[0].millisecond?"second":"millisecond";if(1===e.length&&n)return x(e[0],n);var t=[],i=[],r=[],o=[],l=[],h=[],d=function(e,n){for(var t=0;t<e.length;t++)if(e[t]!==n)return!1;return!0};return(0,s["default"])(e).each(function(e){t.push(e.millisecond),i.push(e.second),r.push(e.minute),o.push(e.hour),l.push(e.day),h.push(e.month)}),d(t,0)?d(i,0)?d(r,0)?d(o,0)?d(l,1)?d(h,1)?"year":"month":"day":"hour":"minute":"second":"millisecond"},formatBdTimeAsAxisLabel:function(e,n,t){if(e.isInvalid)return null;var i=b(e),r=t in{millisecond:!0,second:!0,minute:!0,hour:!0,day:!0},a=t in{millisecond:!0,second:!0,minute:!0,hour:!0},o=t in{millisecond:!0,second:!0},s="millisecond"===t,l=o?"medium":"short",h=r?"ccc MMM d":"MMMM",d=function(e,n){return s?c["default"].format_time_microseconds(e,n):c["default"].format_time(e,n)};if("year"===t)return[c["default"].format_date(i,"YYYY")];if(n&&n.year===e.year&&e.month===n.month&&e.day===n.day)return[d(i,l)];var p=a?[d(i,l),c["default"].format_date(i,h)]:[c["default"].format_date(i,h)];return n&&e.year===n.year||p.push(c["default"].format_date(i,"YYYY")),p}};n["default"]=y,e.exports=n["default"]},51:function(e,n){e.exports=t(583)},6:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var i=window.console,r=n.setLoggingConsole=function(e){i=e},a=function(e){return function(){var n;(n=i)[e].apply(n,arguments)}},o=n.debug=a("debug"),s=n.info=a("info"),l=n.warn=a("warn"),h=n.error=a("error"),d=n.log=a("log"),c=n.trace=a("trace");n["default"]={setLoggingConsole:r,debug:o,info:s,warn:l,error:h,log:d,trace:c}}})},583:function(e,n,t){(function(e){!function(n,t){e.exports=t()}(this,function(){"use strict";function n(){return Li.apply(null,arguments)}function i(e){Li=e}function r(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function a(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function o(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var n;for(n in e)if(e.hasOwnProperty(n))return!1;return!0}function s(e){return void 0===e}function l(e){return"number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function h(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function d(e,n){var t,i=[];for(t=0;t<e.length;++t)i.push(n(e[t],t));return i}function c(e,n){return Object.prototype.hasOwnProperty.call(e,n)}function p(e,n){for(var t in n)c(n,t)&&(e[t]=n[t]);return c(n,"toString")&&(e.toString=n.toString),c(n,"valueOf")&&(e.valueOf=n.valueOf),e}function u(e,n,t,i){return Pn(e,n,t,i,!0).utc()}function f(){return{empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}}function m(e){return null==e._pf&&(e._pf=f()),e._pf}function g(e){if(null==e._isValid){var n=m(e),t=_i.call(n.parsedDateParts,function(e){return null!=e}),i=!isNaN(e._d.getTime())&&n.overflow<0&&!n.empty&&!n.invalidMonth&&!n.invalidWeekday&&!n.weekdayMismatch&&!n.nullInput&&!n.invalidFormat&&!n.userInvalidated&&(!n.meridiem||n.meridiem&&t);if(e._strict&&(i=i&&0===n.charsLeftOver&&0===n.unusedTokens.length&&void 0===n.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return i;e._isValid=i}return e._isValid}function x(e){var n=u(NaN);return null!=e?p(m(n),e):m(n).userInvalidated=!0,n}function b(e,n){var t,i,r;if(s(n._isAMomentObject)||(e._isAMomentObject=n._isAMomentObject),s(n._i)||(e._i=n._i),s(n._f)||(e._f=n._f),s(n._l)||(e._l=n._l),s(n._strict)||(e._strict=n._strict),s(n._tzm)||(e._tzm=n._tzm),s(n._isUTC)||(e._isUTC=n._isUTC),s(n._offset)||(e._offset=n._offset),s(n._pf)||(e._pf=m(n)),s(n._locale)||(e._locale=n._locale),Ci.length>0)for(t=0;t<Ci.length;t++)i=Ci[t],r=n[i],s(r)||(e[i]=r);return e}function y(e){b(this,e),this._d=new Date(null!=e._d?e._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),Hi===!1&&(Hi=!0,n.updateOffset(this),Hi=!1)}function v(e){return e instanceof y||null!=e&&null!=e._isAMomentObject}function w(e){return e<0?Math.ceil(e)||0:Math.floor(e)}function k(e){var n=+e,t=0;return 0!==n&&isFinite(n)&&(t=w(n)),t}function S(e,n,t){var i,r=Math.min(e.length,n.length),a=Math.abs(e.length-n.length),o=0;for(i=0;i<r;i++)(t&&e[i]!==n[i]||!t&&k(e[i])!==k(n[i]))&&o++;return o+a}function T(e){n.suppressDeprecationWarnings===!1&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+e)}function O(e,t){var i=!0;return p(function(){if(null!=n.deprecationHandler&&n.deprecationHandler(null,e),i){for(var r,a=[],o=0;o<arguments.length;o++){if(r="","object"==typeof arguments[o]){r+="\n["+o+"] ";for(var s in arguments[0])r+=s+": "+arguments[0][s]+", ";r=r.slice(0,-2)}else r=arguments[o];a.push(r)}T(e+"\nArguments: "+Array.prototype.slice.call(a).join("")+"\n"+(new Error).stack),i=!1}return t.apply(this,arguments)},t)}function M(e,t){null!=n.deprecationHandler&&n.deprecationHandler(e,t),Ii[e]||(T(t),Ii[e]=!0)}function P(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function A(e){var n,t;for(t in e)n=e[t],P(n)?this[t]=n:this["_"+t]=n;this._config=e,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)}function L(e,n){var t,i=p({},e);for(t in n)c(n,t)&&(a(e[t])&&a(n[t])?(i[t]={},p(i[t],e[t]),p(i[t],n[t])):null!=n[t]?i[t]=n[t]:delete i[t]);for(t in e)c(e,t)&&!c(n,t)&&a(e[t])&&(i[t]=p({},i[t]));return i}function _(e){null!=e&&this.set(e)}function C(e,n,t){var i=this._calendar[e]||this._calendar.sameElse;return P(i)?i.call(n,t):i}function H(e){var n=this._longDateFormat[e],t=this._longDateFormat[e.toUpperCase()];return n||!t?n:(this._longDateFormat[e]=t.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e])}function I(){return this._invalidDate}function D(e){return this._ordinal.replace("%d",e)}function E(e,n,t,i){var r=this._relativeTime[t];return P(r)?r(e,n,t,i):r.replace(/%d/i,e)}function R(e,n){var t=this._relativeTime[e>0?"future":"past"];return P(t)?t(n):t.replace(/%s/i,n)}function z(e,n){var t=e.toLowerCase();Fi[t]=Fi[t+"s"]=Fi[n]=e}function N(e){return"string"==typeof e?Fi[e]||Fi[e.toLowerCase()]:void 0}function W(e){var n,t,i={};for(t in e)c(e,t)&&(n=N(t),n&&(i[n]=e[t]));return i}function j(e,n){Bi[e]=n}function F(e){var n=[];for(var t in e)n.push({unit:t,priority:Bi[t]});return n.sort(function(e,n){return e.priority-n.priority}),n}function B(e,n,t){var i=""+Math.abs(e),r=n-i.length,a=e>=0;return(a?t?"+":"":"-")+Math.pow(10,Math.max(0,r)).toString().substr(1)+i}function G(e,n,t,i){var r=i;"string"==typeof i&&(r=function(){return this[i]()}),e&&(Xi[e]=r),n&&(Xi[n[0]]=function(){return B(r.apply(this,arguments),n[1],n[2])}),t&&(Xi[t]=function(){return this.localeData().ordinal(r.apply(this,arguments),e)})}function Y(e){return e.match(/\[[\s\S]/)?e.replace(/^\[|\]$/g,""):e.replace(/\\/g,"")}function V(e){var n,t,i=e.match(Gi);for(n=0,t=i.length;n<t;n++)Xi[i[n]]?i[n]=Xi[i[n]]:i[n]=Y(i[n]);return function(n){var r,a="";for(r=0;r<t;r++)a+=P(i[r])?i[r].call(n,e):i[r];return a}}function X(e,n){return e.isValid()?(n=U(n,e.localeData()),Vi[n]=Vi[n]||V(n),Vi[n](e)):e.localeData().invalidDate()}function U(e,n){function t(e){return n.longDateFormat(e)||e}var i=5;for(Yi.lastIndex=0;i>=0&&Yi.test(e);)e=e.replace(Yi,t),Yi.lastIndex=0,i-=1;return e}function K(e,n,t){dr[e]=P(n)?n:function(e,i){return e&&t?t:n}}function q(e,n){return c(dr,e)?dr[e](n._strict,n._locale):new RegExp(Z(e))}function Z(e){return $(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,n,t,i,r){return n||t||i||r}))}function $(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function J(e,n){var t,i=n;for("string"==typeof e&&(e=[e]),l(n)&&(i=function(e,t){t[n]=k(e)}),t=0;t<e.length;t++)cr[e[t]]=i}function Q(e,n){J(e,function(e,t,i,r){i._w=i._w||{},n(e,i._w,i,r)})}function ee(e,n,t){null!=n&&c(cr,e)&&cr[e](n,t._a,t,e)}function ne(e){return te(e)?366:365}function te(e){return e%4===0&&e%100!==0||e%400===0}function ie(){return te(this.year())}function re(e,t){return function(i){return null!=i?(oe(this,e,i),n.updateOffset(this,t),this):ae(this,e)}}function ae(e,n){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+n]():NaN}function oe(e,n,t){e.isValid()&&!isNaN(t)&&("FullYear"===n&&te(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+n](t,e.month(),de(t,e.month())):e._d["set"+(e._isUTC?"UTC":"")+n](t))}function se(e){return e=N(e),P(this[e])?this[e]():this}function le(e,n){if("object"==typeof e){e=W(e);for(var t=F(e),i=0;i<t.length;i++)this[t[i].unit](e[t[i].unit])}else if(e=N(e),P(this[e]))return this[e](n);return this}function he(e,n){return(e%n+n)%n}function de(e,n){if(isNaN(e)||isNaN(n))return NaN;var t=he(n,12);return e+=(n-t)/12,1===t?te(e)?29:28:31-t%7%2}function ce(e,n){return e?r(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||Sr).test(n)?"format":"standalone"][e.month()]:r(this._months)?this._months:this._months.standalone}function pe(e,n){return e?r(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[Sr.test(n)?"format":"standalone"][e.month()]:r(this._monthsShort)?this._monthsShort:this._monthsShort.standalone}function ue(e,n,t){var i,r,a,o=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],i=0;i<12;++i)a=u([2e3,i]),this._shortMonthsParse[i]=this.monthsShort(a,"").toLocaleLowerCase(),this._longMonthsParse[i]=this.months(a,"").toLocaleLowerCase();return t?"MMM"===n?(r=wr.call(this._shortMonthsParse,o),r!==-1?r:null):(r=wr.call(this._longMonthsParse,o),r!==-1?r:null):"MMM"===n?(r=wr.call(this._shortMonthsParse,o),r!==-1?r:(r=wr.call(this._longMonthsParse,o),r!==-1?r:null)):(r=wr.call(this._longMonthsParse,o),r!==-1?r:(r=wr.call(this._shortMonthsParse,o),r!==-1?r:null))}function fe(e,n,t){var i,r,a;if(this._monthsParseExact)return ue.call(this,e,n,t);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),i=0;i<12;i++){if(r=u([2e3,i]),t&&!this._longMonthsParse[i]&&(this._longMonthsParse[i]=new RegExp("^"+this.months(r,"").replace(".","")+"$","i"),this._shortMonthsParse[i]=new RegExp("^"+this.monthsShort(r,"").replace(".","")+"$","i")),t||this._monthsParse[i]||(a="^"+this.months(r,"")+"|^"+this.monthsShort(r,""),this._monthsParse[i]=new RegExp(a.replace(".",""),"i")),t&&"MMMM"===n&&this._longMonthsParse[i].test(e))return i;if(t&&"MMM"===n&&this._shortMonthsParse[i].test(e))return i;if(!t&&this._monthsParse[i].test(e))return i}}function me(e,n){var t;if(!e.isValid())return e;if("string"==typeof n)if(/^\d+$/.test(n))n=k(n);else if(n=e.localeData().monthsParse(n),!l(n))return e;return t=Math.min(e.date(),de(e.year(),n)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](n,t),e}function ge(e){return null!=e?(me(this,e),n.updateOffset(this,!0),this):ae(this,"Month")}function xe(){return de(this.year(),this.month())}function be(e){return this._monthsParseExact?(c(this,"_monthsRegex")||ve.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(c(this,"_monthsShortRegex")||(this._monthsShortRegex=Mr),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)}function ye(e){return this._monthsParseExact?(c(this,"_monthsRegex")||ve.call(this),e?this._monthsStrictRegex:this._monthsRegex):(c(this,"_monthsRegex")||(this._monthsRegex=Pr),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)}function ve(){function e(e,n){return n.length-e.length}var n,t,i=[],r=[],a=[];for(n=0;n<12;n++)t=u([2e3,n]),i.push(this.monthsShort(t,"")),r.push(this.months(t,"")),a.push(this.months(t,"")),a.push(this.monthsShort(t,""));for(i.sort(e),r.sort(e),a.sort(e),n=0;n<12;n++)i[n]=$(i[n]),r[n]=$(r[n]);for(n=0;n<24;n++)a[n]=$(a[n]);this._monthsRegex=new RegExp("^("+a.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+i.join("|")+")","i")}function we(e,n,t,i,r,a,o){var s=new Date(e,n,t,i,r,a,o);return e<100&&e>=0&&isFinite(s.getFullYear())&&s.setFullYear(e),s}function ke(e){var n=new Date(Date.UTC.apply(null,arguments));return e<100&&e>=0&&isFinite(n.getUTCFullYear())&&n.setUTCFullYear(e),n}function Se(e,n,t){var i=7+n-t,r=(7+ke(e,0,i).getUTCDay()-n)%7;return-r+i-1}function Te(e,n,t,i,r){var a,o,s=(7+t-i)%7,l=Se(e,i,r),h=1+7*(n-1)+s+l;return h<=0?(a=e-1,o=ne(a)+h):h>ne(e)?(a=e+1,o=h-ne(e)):(a=e,o=h),{year:a,dayOfYear:o}}function Oe(e,n,t){var i,r,a=Se(e.year(),n,t),o=Math.floor((e.dayOfYear()-a-1)/7)+1;return o<1?(r=e.year()-1,i=o+Me(r,n,t)):o>Me(e.year(),n,t)?(i=o-Me(e.year(),n,t),r=e.year()+1):(r=e.year(),i=o),{week:i,year:r}}function Me(e,n,t){var i=Se(e,n,t),r=Se(e+1,n,t);return(ne(e)-i+r)/7}function Pe(e){return Oe(e,this._week.dow,this._week.doy).week}function Ae(){return this._week.dow}function Le(){return this._week.doy}function _e(e){var n=this.localeData().week(this);return null==e?n:this.add(7*(e-n),"d")}function Ce(e){var n=Oe(this,1,4).week;return null==e?n:this.add(7*(e-n),"d")}function He(e,n){return"string"!=typeof e?e:isNaN(e)?(e=n.weekdaysParse(e),"number"==typeof e?e:null):parseInt(e,10)}function Ie(e,n){return"string"==typeof e?n.weekdaysParse(e)%7||7:isNaN(e)?null:e}function De(e,n){return e?r(this._weekdays)?this._weekdays[e.day()]:this._weekdays[this._weekdays.isFormat.test(n)?"format":"standalone"][e.day()]:r(this._weekdays)?this._weekdays:this._weekdays.standalone}function Ee(e){return e?this._weekdaysShort[e.day()]:this._weekdaysShort}function Re(e){return e?this._weekdaysMin[e.day()]:this._weekdaysMin}function ze(e,n,t){var i,r,a,o=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],i=0;i<7;++i)a=u([2e3,1]).day(i),this._minWeekdaysParse[i]=this.weekdaysMin(a,"").toLocaleLowerCase(),this._shortWeekdaysParse[i]=this.weekdaysShort(a,"").toLocaleLowerCase(),this._weekdaysParse[i]=this.weekdays(a,"").toLocaleLowerCase();return t?"dddd"===n?(r=wr.call(this._weekdaysParse,o),r!==-1?r:null):"ddd"===n?(r=wr.call(this._shortWeekdaysParse,o),r!==-1?r:null):(r=wr.call(this._minWeekdaysParse,o),r!==-1?r:null):"dddd"===n?(r=wr.call(this._weekdaysParse,o),r!==-1?r:(r=wr.call(this._shortWeekdaysParse,o),r!==-1?r:(r=wr.call(this._minWeekdaysParse,o),r!==-1?r:null))):"ddd"===n?(r=wr.call(this._shortWeekdaysParse,o),r!==-1?r:(r=wr.call(this._weekdaysParse,o),r!==-1?r:(r=wr.call(this._minWeekdaysParse,o),r!==-1?r:null))):(r=wr.call(this._minWeekdaysParse,o),r!==-1?r:(r=wr.call(this._weekdaysParse,o),r!==-1?r:(r=wr.call(this._shortWeekdaysParse,o),r!==-1?r:null)))}function Ne(e,n,t){var i,r,a;if(this._weekdaysParseExact)return ze.call(this,e,n,t);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),i=0;i<7;i++){if(r=u([2e3,1]).day(i),t&&!this._fullWeekdaysParse[i]&&(this._fullWeekdaysParse[i]=new RegExp("^"+this.weekdays(r,"").replace(".","\\.?")+"$","i"),this._shortWeekdaysParse[i]=new RegExp("^"+this.weekdaysShort(r,"").replace(".","\\.?")+"$","i"),this._minWeekdaysParse[i]=new RegExp("^"+this.weekdaysMin(r,"").replace(".","\\.?")+"$","i")),this._weekdaysParse[i]||(a="^"+this.weekdays(r,"")+"|^"+this.weekdaysShort(r,"")+"|^"+this.weekdaysMin(r,""),
this._weekdaysParse[i]=new RegExp(a.replace(".",""),"i")),t&&"dddd"===n&&this._fullWeekdaysParse[i].test(e))return i;if(t&&"ddd"===n&&this._shortWeekdaysParse[i].test(e))return i;if(t&&"dd"===n&&this._minWeekdaysParse[i].test(e))return i;if(!t&&this._weekdaysParse[i].test(e))return i}}function We(e){if(!this.isValid())return null!=e?this:NaN;var n=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(e=He(e,this.localeData()),this.add(e-n,"d")):n}function je(e){if(!this.isValid())return null!=e?this:NaN;var n=(this.day()+7-this.localeData()._week.dow)%7;return null==e?n:this.add(e-n,"d")}function Fe(e){if(!this.isValid())return null!=e?this:NaN;if(null!=e){var n=Ie(e,this.localeData());return this.day(this.day()%7?n:n-7)}return this.day()||7}function Be(e){return this._weekdaysParseExact?(c(this,"_weekdaysRegex")||Ve.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(c(this,"_weekdaysRegex")||(this._weekdaysRegex=Hr),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)}function Ge(e){return this._weekdaysParseExact?(c(this,"_weekdaysRegex")||Ve.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(c(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=Ir),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)}function Ye(e){return this._weekdaysParseExact?(c(this,"_weekdaysRegex")||Ve.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(c(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=Dr),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)}function Ve(){function e(e,n){return n.length-e.length}var n,t,i,r,a,o=[],s=[],l=[],h=[];for(n=0;n<7;n++)t=u([2e3,1]).day(n),i=this.weekdaysMin(t,""),r=this.weekdaysShort(t,""),a=this.weekdays(t,""),o.push(i),s.push(r),l.push(a),h.push(i),h.push(r),h.push(a);for(o.sort(e),s.sort(e),l.sort(e),h.sort(e),n=0;n<7;n++)s[n]=$(s[n]),l[n]=$(l[n]),h[n]=$(h[n]);this._weekdaysRegex=new RegExp("^("+h.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+l.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+s.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+o.join("|")+")","i")}function Xe(){return this.hours()%12||12}function Ue(){return this.hours()||24}function Ke(e,n){G(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),n)})}function qe(e,n){return n._meridiemParse}function Ze(e){return"p"===(e+"").toLowerCase().charAt(0)}function $e(e,n,t){return e>11?t?"pm":"PM":t?"am":"AM"}function Je(e){return e?e.toLowerCase().replace("_","-"):e}function Qe(e){for(var n,t,i,r,a=0;a<e.length;){for(r=Je(e[a]).split("-"),n=r.length,t=Je(e[a+1]),t=t?t.split("-"):null;n>0;){if(i=en(r.slice(0,n).join("-")))return i;if(t&&t.length>=n&&S(r,t,!0)>=n-1)break;n--}a++}return Er}function en(n){var i=null;if(!Wr[n]&&"undefined"!=typeof e&&e&&e.exports)try{i=Er._abbr;t(514)("./"+n),nn(i)}catch(r){}return Wr[n]}function nn(e,n){var t;return e&&(t=s(n)?an(e):tn(e,n),t?Er=t:"undefined"!=typeof console&&console.warn&&console.warn("Locale "+e+" not found. Did you forget to load it?")),Er._abbr}function tn(e,n){if(null!==n){var t,i=Nr;if(n.abbr=e,null!=Wr[e])M("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),i=Wr[e]._config;else if(null!=n.parentLocale)if(null!=Wr[n.parentLocale])i=Wr[n.parentLocale]._config;else{if(t=en(n.parentLocale),null==t)return jr[n.parentLocale]||(jr[n.parentLocale]=[]),jr[n.parentLocale].push({name:e,config:n}),null;i=t._config}return Wr[e]=new _(L(i,n)),jr[e]&&jr[e].forEach(function(e){tn(e.name,e.config)}),nn(e),Wr[e]}return delete Wr[e],null}function rn(e,n){if(null!=n){var t,i,r=Nr;i=en(e),null!=i&&(r=i._config),n=L(r,n),t=new _(n),t.parentLocale=Wr[e],Wr[e]=t,nn(e)}else null!=Wr[e]&&(null!=Wr[e].parentLocale?Wr[e]=Wr[e].parentLocale:null!=Wr[e]&&delete Wr[e]);return Wr[e]}function an(e){var n;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return Er;if(!r(e)){if(n=en(e))return n;e=[e]}return Qe(e)}function on(){return Di(Wr)}function sn(e){var n,t=e._a;return t&&m(e).overflow===-2&&(n=t[ur]<0||t[ur]>11?ur:t[fr]<1||t[fr]>de(t[pr],t[ur])?fr:t[mr]<0||t[mr]>24||24===t[mr]&&(0!==t[gr]||0!==t[xr]||0!==t[br])?mr:t[gr]<0||t[gr]>59?gr:t[xr]<0||t[xr]>59?xr:t[br]<0||t[br]>999?br:-1,m(e)._overflowDayOfYear&&(n<pr||n>fr)&&(n=fr),m(e)._overflowWeeks&&n===-1&&(n=yr),m(e)._overflowWeekday&&n===-1&&(n=vr),m(e).overflow=n),e}function ln(e,n,t){return null!=e?e:null!=n?n:t}function hn(e){var t=new Date(n.now());return e._useUTC?[t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate()]:[t.getFullYear(),t.getMonth(),t.getDate()]}function dn(e){var n,t,i,r,a,o=[];if(!e._d){for(i=hn(e),e._w&&null==e._a[fr]&&null==e._a[ur]&&cn(e),null!=e._dayOfYear&&(a=ln(e._a[pr],i[pr]),(e._dayOfYear>ne(a)||0===e._dayOfYear)&&(m(e)._overflowDayOfYear=!0),t=ke(a,0,e._dayOfYear),e._a[ur]=t.getUTCMonth(),e._a[fr]=t.getUTCDate()),n=0;n<3&&null==e._a[n];++n)e._a[n]=o[n]=i[n];for(;n<7;n++)e._a[n]=o[n]=null==e._a[n]?2===n?1:0:e._a[n];24===e._a[mr]&&0===e._a[gr]&&0===e._a[xr]&&0===e._a[br]&&(e._nextDay=!0,e._a[mr]=0),e._d=(e._useUTC?ke:we).apply(null,o),r=e._useUTC?e._d.getUTCDay():e._d.getDay(),null!=e._tzm&&e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),e._nextDay&&(e._a[mr]=24),e._w&&"undefined"!=typeof e._w.d&&e._w.d!==r&&(m(e).weekdayMismatch=!0)}}function cn(e){var n,t,i,r,a,o,s,l;if(n=e._w,null!=n.GG||null!=n.W||null!=n.E)a=1,o=4,t=ln(n.GG,e._a[pr],Oe(An(),1,4).year),i=ln(n.W,1),r=ln(n.E,1),(r<1||r>7)&&(l=!0);else{a=e._locale._week.dow,o=e._locale._week.doy;var h=Oe(An(),a,o);t=ln(n.gg,e._a[pr],h.year),i=ln(n.w,h.week),null!=n.d?(r=n.d,(r<0||r>6)&&(l=!0)):null!=n.e?(r=n.e+a,(n.e<0||n.e>6)&&(l=!0)):r=a}i<1||i>Me(t,a,o)?m(e)._overflowWeeks=!0:null!=l?m(e)._overflowWeekday=!0:(s=Te(t,i,r,a,o),e._a[pr]=s.year,e._dayOfYear=s.dayOfYear)}function pn(e){var n,t,i,r,a,o,s=e._i,l=Fr.exec(s)||Br.exec(s);if(l){for(m(e).iso=!0,n=0,t=Yr.length;n<t;n++)if(Yr[n][1].exec(l[1])){r=Yr[n][0],i=Yr[n][2]!==!1;break}if(null==r)return void(e._isValid=!1);if(l[3]){for(n=0,t=Vr.length;n<t;n++)if(Vr[n][1].exec(l[3])){a=(l[2]||" ")+Vr[n][0];break}if(null==a)return void(e._isValid=!1)}if(!i&&null!=a)return void(e._isValid=!1);if(l[4]){if(!Gr.exec(l[4]))return void(e._isValid=!1);o="Z"}e._f=r+(a||"")+(o||""),vn(e)}else e._isValid=!1}function un(e,n,t,i,r,a){var o=[fn(e),Or.indexOf(n),parseInt(t,10),parseInt(i,10),parseInt(r,10)];return a&&o.push(parseInt(a,10)),o}function fn(e){var n=parseInt(e,10);return n<=49?2e3+n:n<=999?1900+n:n}function mn(e){return e.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").replace(/^\s\s*/,"").replace(/\s\s*$/,"")}function gn(e,n,t){if(e){var i=_r.indexOf(e),r=new Date(n[0],n[1],n[2]).getDay();if(i!==r)return m(t).weekdayMismatch=!0,t._isValid=!1,!1}return!0}function xn(e,n,t){if(e)return Kr[e];if(n)return 0;var i=parseInt(t,10),r=i%100,a=(i-r)/100;return 60*a+r}function bn(e){var n=Ur.exec(mn(e._i));if(n){var t=un(n[4],n[3],n[2],n[5],n[6],n[7]);if(!gn(n[1],t,e))return;e._a=t,e._tzm=xn(n[8],n[9],n[10]),e._d=ke.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),m(e).rfc2822=!0}else e._isValid=!1}function yn(e){var t=Xr.exec(e._i);return null!==t?void(e._d=new Date((+t[1]))):(pn(e),void(e._isValid===!1&&(delete e._isValid,bn(e),e._isValid===!1&&(delete e._isValid,n.createFromInputFallback(e)))))}function vn(e){if(e._f===n.ISO_8601)return void pn(e);if(e._f===n.RFC_2822)return void bn(e);e._a=[],m(e).empty=!0;var t,i,r,a,o,s=""+e._i,l=s.length,h=0;for(r=U(e._f,e._locale).match(Gi)||[],t=0;t<r.length;t++)a=r[t],i=(s.match(q(a,e))||[])[0],i&&(o=s.substr(0,s.indexOf(i)),o.length>0&&m(e).unusedInput.push(o),s=s.slice(s.indexOf(i)+i.length),h+=i.length),Xi[a]?(i?m(e).empty=!1:m(e).unusedTokens.push(a),ee(a,i,e)):e._strict&&!i&&m(e).unusedTokens.push(a);m(e).charsLeftOver=l-h,s.length>0&&m(e).unusedInput.push(s),e._a[mr]<=12&&m(e).bigHour===!0&&e._a[mr]>0&&(m(e).bigHour=void 0),m(e).parsedDateParts=e._a.slice(0),m(e).meridiem=e._meridiem,e._a[mr]=wn(e._locale,e._a[mr],e._meridiem),dn(e),sn(e)}function wn(e,n,t){var i;return null==t?n:null!=e.meridiemHour?e.meridiemHour(n,t):null!=e.isPM?(i=e.isPM(t),i&&n<12&&(n+=12),i||12!==n||(n=0),n):n}function kn(e){var n,t,i,r,a;if(0===e._f.length)return m(e).invalidFormat=!0,void(e._d=new Date(NaN));for(r=0;r<e._f.length;r++)a=0,n=b({},e),null!=e._useUTC&&(n._useUTC=e._useUTC),n._f=e._f[r],vn(n),g(n)&&(a+=m(n).charsLeftOver,a+=10*m(n).unusedTokens.length,m(n).score=a,(null==i||a<i)&&(i=a,t=n));p(e,t||n)}function Sn(e){if(!e._d){var n=W(e._i);e._a=d([n.year,n.month,n.day||n.date,n.hour,n.minute,n.second,n.millisecond],function(e){return e&&parseInt(e,10)}),dn(e)}}function Tn(e){var n=new y(sn(On(e)));return n._nextDay&&(n.add(1,"d"),n._nextDay=void 0),n}function On(e){var n=e._i,t=e._f;return e._locale=e._locale||an(e._l),null===n||void 0===t&&""===n?x({nullInput:!0}):("string"==typeof n&&(e._i=n=e._locale.preparse(n)),v(n)?new y(sn(n)):(h(n)?e._d=n:r(t)?kn(e):t?vn(e):Mn(e),g(e)||(e._d=null),e))}function Mn(e){var t=e._i;s(t)?e._d=new Date(n.now()):h(t)?e._d=new Date(t.valueOf()):"string"==typeof t?yn(e):r(t)?(e._a=d(t.slice(0),function(e){return parseInt(e,10)}),dn(e)):a(t)?Sn(e):l(t)?e._d=new Date(t):n.createFromInputFallback(e)}function Pn(e,n,t,i,s){var l={};return t!==!0&&t!==!1||(i=t,t=void 0),(a(e)&&o(e)||r(e)&&0===e.length)&&(e=void 0),l._isAMomentObject=!0,l._useUTC=l._isUTC=s,l._l=t,l._i=e,l._f=n,l._strict=i,Tn(l)}function An(e,n,t,i){return Pn(e,n,t,i,!1)}function Ln(e,n){var t,i;if(1===n.length&&r(n[0])&&(n=n[0]),!n.length)return An();for(t=n[0],i=1;i<n.length;++i)n[i].isValid()&&!n[i][e](t)||(t=n[i]);return t}function _n(){var e=[].slice.call(arguments,0);return Ln("isBefore",e)}function Cn(){var e=[].slice.call(arguments,0);return Ln("isAfter",e)}function Hn(e){for(var n in e)if(wr.call(Jr,n)===-1||null!=e[n]&&isNaN(e[n]))return!1;for(var t=!1,i=0;i<Jr.length;++i)if(e[Jr[i]]){if(t)return!1;parseFloat(e[Jr[i]])!==k(e[Jr[i]])&&(t=!0)}return!0}function In(){return this._isValid}function Dn(){return Qn(NaN)}function En(e){var n=W(e),t=n.year||0,i=n.quarter||0,r=n.month||0,a=n.week||0,o=n.day||0,s=n.hour||0,l=n.minute||0,h=n.second||0,d=n.millisecond||0;this._isValid=Hn(n),this._milliseconds=+d+1e3*h+6e4*l+1e3*s*60*60,this._days=+o+7*a,this._months=+r+3*i+12*t,this._data={},this._locale=an(),this._bubble()}function Rn(e){return e instanceof En}function zn(e){return e<0?Math.round(-1*e)*-1:Math.round(e)}function Nn(e,n){G(e,0,0,function(){var e=this.utcOffset(),t="+";return e<0&&(e=-e,t="-"),t+B(~~(e/60),2)+n+B(~~e%60,2)})}function Wn(e,n){var t=(n||"").match(e);if(null===t)return null;var i=t[t.length-1]||[],r=(i+"").match(Qr)||["-",0,0],a=+(60*r[1])+k(r[2]);return 0===a?0:"+"===r[0]?a:-a}function jn(e,t){var i,r;return t._isUTC?(i=t.clone(),r=(v(e)||h(e)?e.valueOf():An(e).valueOf())-i.valueOf(),i._d.setTime(i._d.valueOf()+r),n.updateOffset(i,!1),i):An(e).local()}function Fn(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Bn(e,t,i){var r,a=this._offset||0;if(!this.isValid())return null!=e?this:NaN;if(null!=e){if("string"==typeof e){if(e=Wn(sr,e),null===e)return this}else Math.abs(e)<16&&!i&&(e=60*e);return!this._isUTC&&t&&(r=Fn(this)),this._offset=e,this._isUTC=!0,null!=r&&this.add(r,"m"),a!==e&&(!t||this._changeInProgress?rt(this,Qn(e-a,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,n.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?a:Fn(this)}function Gn(e,n){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,n),this):-this.utcOffset()}function Yn(e){return this.utcOffset(0,e)}function Vn(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Fn(this),"m")),this}function Xn(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=Wn(or,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0)}return this}function Un(e){return!!this.isValid()&&(e=e?An(e).utcOffset():0,(this.utcOffset()-e)%60===0)}function Kn(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()}function qn(){if(!s(this._isDSTShifted))return this._isDSTShifted;var e={};if(b(e,this),e=On(e),e._a){var n=e._isUTC?u(e._a):An(e._a);this._isDSTShifted=this.isValid()&&S(e._a,n.toArray())>0}else this._isDSTShifted=!1;return this._isDSTShifted}function Zn(){return!!this.isValid()&&!this._isUTC}function $n(){return!!this.isValid()&&this._isUTC}function Jn(){return!!this.isValid()&&(this._isUTC&&0===this._offset)}function Qn(e,n){var t,i,r,a=e,o=null;return Rn(e)?a={ms:e._milliseconds,d:e._days,M:e._months}:l(e)?(a={},n?a[n]=e:a.milliseconds=e):(o=ea.exec(e))?(t="-"===o[1]?-1:1,a={y:0,d:k(o[fr])*t,h:k(o[mr])*t,m:k(o[gr])*t,s:k(o[xr])*t,ms:k(zn(1e3*o[br]))*t}):(o=na.exec(e))?(t="-"===o[1]?-1:("+"===o[1],1),a={y:et(o[2],t),M:et(o[3],t),w:et(o[4],t),d:et(o[5],t),h:et(o[6],t),m:et(o[7],t),s:et(o[8],t)}):null==a?a={}:"object"==typeof a&&("from"in a||"to"in a)&&(r=tt(An(a.from),An(a.to)),a={},a.ms=r.milliseconds,a.M=r.months),i=new En(a),Rn(e)&&c(e,"_locale")&&(i._locale=e._locale),i}function et(e,n){var t=e&&parseFloat(e.replace(",","."));return(isNaN(t)?0:t)*n}function nt(e,n){var t={milliseconds:0,months:0};return t.months=n.month()-e.month()+12*(n.year()-e.year()),e.clone().add(t.months,"M").isAfter(n)&&--t.months,t.milliseconds=+n-+e.clone().add(t.months,"M"),t}function tt(e,n){var t;return e.isValid()&&n.isValid()?(n=jn(n,e),e.isBefore(n)?t=nt(e,n):(t=nt(n,e),t.milliseconds=-t.milliseconds,t.months=-t.months),t):{milliseconds:0,months:0}}function it(e,n){return function(t,i){var r,a;return null===i||isNaN(+i)||(M(n,"moment()."+n+"(period, number) is deprecated. Please use moment()."+n+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),a=t,t=i,i=a),t="string"==typeof t?+t:t,r=Qn(t,i),rt(this,r,e),this}}function rt(e,t,i,r){var a=t._milliseconds,o=zn(t._days),s=zn(t._months);e.isValid()&&(r=null==r||r,s&&me(e,ae(e,"Month")+s*i),o&&oe(e,"Date",ae(e,"Date")+o*i),a&&e._d.setTime(e._d.valueOf()+a*i),r&&n.updateOffset(e,o||s))}function at(e,n){var t=e.diff(n,"days",!0);return t<-6?"sameElse":t<-1?"lastWeek":t<0?"lastDay":t<1?"sameDay":t<2?"nextDay":t<7?"nextWeek":"sameElse"}function ot(e,t){var i=e||An(),r=jn(i,this).startOf("day"),a=n.calendarFormat(this,r)||"sameElse",o=t&&(P(t[a])?t[a].call(this,i):t[a]);return this.format(o||this.localeData().calendar(a,this,An(i)))}function st(){return new y(this)}function lt(e,n){var t=v(e)?e:An(e);return!(!this.isValid()||!t.isValid())&&(n=N(s(n)?"millisecond":n),"millisecond"===n?this.valueOf()>t.valueOf():t.valueOf()<this.clone().startOf(n).valueOf())}function ht(e,n){var t=v(e)?e:An(e);return!(!this.isValid()||!t.isValid())&&(n=N(s(n)?"millisecond":n),"millisecond"===n?this.valueOf()<t.valueOf():this.clone().endOf(n).valueOf()<t.valueOf())}function dt(e,n,t,i){return i=i||"()",("("===i[0]?this.isAfter(e,t):!this.isBefore(e,t))&&(")"===i[1]?this.isBefore(n,t):!this.isAfter(n,t))}function ct(e,n){var t,i=v(e)?e:An(e);return!(!this.isValid()||!i.isValid())&&(n=N(n||"millisecond"),"millisecond"===n?this.valueOf()===i.valueOf():(t=i.valueOf(),this.clone().startOf(n).valueOf()<=t&&t<=this.clone().endOf(n).valueOf()))}function pt(e,n){return this.isSame(e,n)||this.isAfter(e,n)}function ut(e,n){return this.isSame(e,n)||this.isBefore(e,n)}function ft(e,n,t){var i,r,a;if(!this.isValid())return NaN;if(i=jn(e,this),!i.isValid())return NaN;switch(r=6e4*(i.utcOffset()-this.utcOffset()),n=N(n)){case"year":a=mt(this,i)/12;break;case"month":a=mt(this,i);break;case"quarter":a=mt(this,i)/3;break;case"second":a=(this-i)/1e3;break;case"minute":a=(this-i)/6e4;break;case"hour":a=(this-i)/36e5;break;case"day":a=(this-i-r)/864e5;break;case"week":a=(this-i-r)/6048e5;break;default:a=this-i}return t?a:w(a)}function mt(e,n){var t,i,r=12*(n.year()-e.year())+(n.month()-e.month()),a=e.clone().add(r,"months");return n-a<0?(t=e.clone().add(r-1,"months"),i=(n-a)/(a-t)):(t=e.clone().add(r+1,"months"),i=(n-a)/(t-a)),-(r+i)||0}function gt(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")}function xt(e){if(!this.isValid())return null;var n=e!==!0,t=n?this.clone().utc():this;return t.year()<0||t.year()>9999?X(t,n?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):P(Date.prototype.toISOString)?n?this.toDate().toISOString():new Date(this.valueOf()+60*this.utcOffset()*1e3).toISOString().replace("Z",X(t,"Z")):X(t,n?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")}function bt(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var e="moment",n="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",n="Z");var t="["+e+'("]',i=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",r="-MM-DD[T]HH:mm:ss.SSS",a=n+'[")]';return this.format(t+i+r+a)}function yt(e){e||(e=this.isUtc()?n.defaultFormatUtc:n.defaultFormat);var t=X(this,e);return this.localeData().postformat(t)}function vt(e,n){return this.isValid()&&(v(e)&&e.isValid()||An(e).isValid())?Qn({to:this,from:e}).locale(this.locale()).humanize(!n):this.localeData().invalidDate()}function wt(e){return this.from(An(),e)}function kt(e,n){return this.isValid()&&(v(e)&&e.isValid()||An(e).isValid())?Qn({from:this,to:e}).locale(this.locale()).humanize(!n):this.localeData().invalidDate()}function St(e){return this.to(An(),e)}function Tt(e){var n;return void 0===e?this._locale._abbr:(n=an(e),null!=n&&(this._locale=n),this)}function Ot(){return this._locale}function Mt(e){switch(e=N(e)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":case"date":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===e&&this.weekday(0),"isoWeek"===e&&this.isoWeekday(1),"quarter"===e&&this.month(3*Math.floor(this.month()/3)),this}function Pt(e){return e=N(e),void 0===e||"millisecond"===e?this:("date"===e&&(e="day"),this.startOf(e).add(1,"isoWeek"===e?"week":e).subtract(1,"ms"))}function At(){return this._d.valueOf()-6e4*(this._offset||0)}function Lt(){return Math.floor(this.valueOf()/1e3)}function _t(){return new Date(this.valueOf())}function Ct(){var e=this;return[e.year(),e.month(),e.date(),e.hour(),e.minute(),e.second(),e.millisecond()]}function Ht(){var e=this;return{years:e.year(),months:e.month(),date:e.date(),hours:e.hours(),minutes:e.minutes(),seconds:e.seconds(),milliseconds:e.milliseconds()}}function It(){return this.isValid()?this.toISOString():null}function Dt(){return g(this)}function Et(){return p({},m(this))}function Rt(){return m(this).overflow}function zt(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}}function Nt(e,n){G(0,[e,e.length],0,n)}function Wt(e){return Gt.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)}function jt(e){return Gt.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)}function Ft(){return Me(this.year(),1,4)}function Bt(){var e=this.localeData()._week;return Me(this.year(),e.dow,e.doy)}function Gt(e,n,t,i,r){var a;return null==e?Oe(this,i,r).year:(a=Me(e,i,r),n>a&&(n=a),Yt.call(this,e,n,t,i,r))}function Yt(e,n,t,i,r){var a=Te(e,n,t,i,r),o=ke(a.year,0,a.dayOfYear);return this.year(o.getUTCFullYear()),this.month(o.getUTCMonth()),this.date(o.getUTCDate()),this}function Vt(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)}function Xt(e){var n=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?n:this.add(e-n,"d")}function Ut(e,n){n[br]=k(1e3*("0."+e))}function Kt(){return this._isUTC?"UTC":""}function qt(){return this._isUTC?"Coordinated Universal Time":""}function Zt(e){return An(1e3*e)}function $t(){return An.apply(null,arguments).parseZone()}function Jt(e){return e}function Qt(e,n,t,i){var r=an(),a=u().set(i,n);return r[t](a,e)}function ei(e,n,t){if(l(e)&&(n=e,e=void 0),e=e||"",null!=n)return Qt(e,n,t,"month");var i,r=[];for(i=0;i<12;i++)r[i]=Qt(e,i,t,"month");return r}function ni(e,n,t,i){"boolean"==typeof e?(l(n)&&(t=n,n=void 0),n=n||""):(n=e,t=n,e=!1,l(n)&&(t=n,n=void 0),n=n||"");var r=an(),a=e?r._week.dow:0;if(null!=t)return Qt(n,(t+a)%7,i,"day");var o,s=[];for(o=0;o<7;o++)s[o]=Qt(n,(o+a)%7,i,"day");return s}function ti(e,n){return ei(e,n,"months")}function ii(e,n){return ei(e,n,"monthsShort")}function ri(e,n,t){return ni(e,n,t,"weekdays")}function ai(e,n,t){return ni(e,n,t,"weekdaysShort")}function oi(e,n,t){return ni(e,n,t,"weekdaysMin")}function si(){var e=this._data;return this._milliseconds=pa(this._milliseconds),this._days=pa(this._days),this._months=pa(this._months),e.milliseconds=pa(e.milliseconds),e.seconds=pa(e.seconds),e.minutes=pa(e.minutes),e.hours=pa(e.hours),e.months=pa(e.months),e.years=pa(e.years),this}function li(e,n,t,i){var r=Qn(n,t);return e._milliseconds+=i*r._milliseconds,e._days+=i*r._days,e._months+=i*r._months,e._bubble()}function hi(e,n){return li(this,e,n,1)}function di(e,n){return li(this,e,n,-1)}function ci(e){return e<0?Math.floor(e):Math.ceil(e)}function pi(){var e,n,t,i,r,a=this._milliseconds,o=this._days,s=this._months,l=this._data;return a>=0&&o>=0&&s>=0||a<=0&&o<=0&&s<=0||(a+=864e5*ci(fi(s)+o),o=0,s=0),l.milliseconds=a%1e3,e=w(a/1e3),l.seconds=e%60,n=w(e/60),l.minutes=n%60,t=w(n/60),l.hours=t%24,o+=w(t/24),r=w(ui(o)),s+=r,o-=ci(fi(r)),i=w(s/12),s%=12,l.days=o,l.months=s,l.years=i,this}function ui(e){return 4800*e/146097}function fi(e){return 146097*e/4800}function mi(e){if(!this.isValid())return NaN;var n,t,i=this._milliseconds;if(e=N(e),"month"===e||"year"===e)return n=this._days+i/864e5,t=this._months+ui(n),"month"===e?t:t/12;switch(n=this._days+Math.round(fi(this._months)),e){case"week":return n/7+i/6048e5;case"day":return n+i/864e5;case"hour":return 24*n+i/36e5;case"minute":return 1440*n+i/6e4;case"second":return 86400*n+i/1e3;case"millisecond":return Math.floor(864e5*n)+i;default:throw new Error("Unknown unit "+e)}}function gi(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*k(this._months/12):NaN}function xi(e){return function(){return this.as(e)}}function bi(){return Qn(this)}function yi(e){return e=N(e),this.isValid()?this[e+"s"]():NaN}function vi(e){return function(){return this.isValid()?this._data[e]:NaN}}function wi(){return w(this.days()/7)}function ki(e,n,t,i,r){return r.relativeTime(n||1,!!t,e,i)}function Si(e,n,t){var i=Qn(e).abs(),r=Aa(i.as("s")),a=Aa(i.as("m")),o=Aa(i.as("h")),s=Aa(i.as("d")),l=Aa(i.as("M")),h=Aa(i.as("y")),d=r<=La.ss&&["s",r]||r<La.s&&["ss",r]||a<=1&&["m"]||a<La.m&&["mm",a]||o<=1&&["h"]||o<La.h&&["hh",o]||s<=1&&["d"]||s<La.d&&["dd",s]||l<=1&&["M"]||l<La.M&&["MM",l]||h<=1&&["y"]||["yy",h];return d[2]=n,d[3]=+e>0,d[4]=t,ki.apply(null,d)}function Ti(e){return void 0===e?Aa:"function"==typeof e&&(Aa=e,!0)}function Oi(e,n){return void 0!==La[e]&&(void 0===n?La[e]:(La[e]=n,"s"===e&&(La.ss=n-1),!0))}function Mi(e){if(!this.isValid())return this.localeData().invalidDate();var n=this.localeData(),t=Si(this,!e,n);return e&&(t=n.pastFuture(+this,t)),n.postformat(t)}function Pi(e){return(e>0)-(e<0)||+e}function Ai(){if(!this.isValid())return this.localeData().invalidDate();var e,n,t,i=_a(this._milliseconds)/1e3,r=_a(this._days),a=_a(this._months);e=w(i/60),n=w(e/60),i%=60,e%=60,t=w(a/12),a%=12;var o=t,s=a,l=r,h=n,d=e,c=i?i.toFixed(3).replace(/\.?0+$/,""):"",p=this.asSeconds();if(!p)return"P0D";var u=p<0?"-":"",f=Pi(this._months)!==Pi(p)?"-":"",m=Pi(this._days)!==Pi(p)?"-":"",g=Pi(this._milliseconds)!==Pi(p)?"-":"";return u+"P"+(o?f+o+"Y":"")+(s?f+s+"M":"")+(l?m+l+"D":"")+(h||d||c?"T":"")+(h?g+h+"H":"")+(d?g+d+"M":"")+(c?g+c+"S":"")}var Li,_i;_i=Array.prototype.some?Array.prototype.some:function(e){for(var n=Object(this),t=n.length>>>0,i=0;i<t;i++)if(i in n&&e.call(this,n[i],i,n))return!0;return!1};var Ci=n.momentProperties=[],Hi=!1,Ii={};n.suppressDeprecationWarnings=!1,n.deprecationHandler=null;var Di;Di=Object.keys?Object.keys:function(e){var n,t=[];for(n in e)c(e,n)&&t.push(n);return t};var Ei={sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},Ri={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},zi="Invalid date",Ni="%d",Wi=/\d{1,2}/,ji={future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},Fi={},Bi={},Gi=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,Yi=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,Vi={},Xi={},Ui=/\d/,Ki=/\d\d/,qi=/\d{3}/,Zi=/\d{4}/,$i=/[+-]?\d{6}/,Ji=/\d\d?/,Qi=/\d\d\d\d?/,er=/\d\d\d\d\d\d?/,nr=/\d{1,3}/,tr=/\d{1,4}/,ir=/[+-]?\d{1,6}/,rr=/\d+/,ar=/[+-]?\d+/,or=/Z|[+-]\d\d:?\d\d/gi,sr=/Z|[+-]\d\d(?::?\d\d)?/gi,lr=/[+-]?\d+(\.\d{1,3})?/,hr=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,dr={},cr={},pr=0,ur=1,fr=2,mr=3,gr=4,xr=5,br=6,yr=7,vr=8;G("Y",0,0,function(){var e=this.year();return e<=9999?""+e:"+"+e}),G(0,["YY",2],0,function(){return this.year()%100}),G(0,["YYYY",4],0,"year"),G(0,["YYYYY",5],0,"year"),G(0,["YYYYYY",6,!0],0,"year"),z("year","y"),j("year",1),K("Y",ar),K("YY",Ji,Ki),K("YYYY",tr,Zi),K("YYYYY",ir,$i),K("YYYYYY",ir,$i),J(["YYYYY","YYYYYY"],pr),J("YYYY",function(e,t){t[pr]=2===e.length?n.parseTwoDigitYear(e):k(e)}),J("YY",function(e,t){t[pr]=n.parseTwoDigitYear(e)}),J("Y",function(e,n){n[pr]=parseInt(e,10)}),n.parseTwoDigitYear=function(e){return k(e)+(k(e)>68?1900:2e3)};var wr,kr=re("FullYear",!0);wr=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var n;for(n=0;n<this.length;++n)if(this[n]===e)return n;return-1},G("M",["MM",2],"Mo",function(){return this.month()+1}),G("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),G("MMMM",0,0,function(e){return this.localeData().months(this,e)}),z("month","M"),j("month",8),K("M",Ji),K("MM",Ji,Ki),K("MMM",function(e,n){return n.monthsShortRegex(e)}),K("MMMM",function(e,n){return n.monthsRegex(e)}),J(["M","MM"],function(e,n){n[ur]=k(e)-1}),J(["MMM","MMMM"],function(e,n,t,i){var r=t._locale.monthsParse(e,i,t._strict);null!=r?n[ur]=r:m(t).invalidMonth=e});var Sr=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Tr="January_February_March_April_May_June_July_August_September_October_November_December".split("_"),Or="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),Mr=hr,Pr=hr;G("w",["ww",2],"wo","week"),G("W",["WW",2],"Wo","isoWeek"),z("week","w"),z("isoWeek","W"),j("week",5),j("isoWeek",5),K("w",Ji),K("ww",Ji,Ki),K("W",Ji),K("WW",Ji,Ki),Q(["w","ww","W","WW"],function(e,n,t,i){n[i.substr(0,1)]=k(e)});var Ar={dow:0,doy:6};G("d",0,"do","day"),G("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),G("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),G("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),G("e",0,0,"weekday"),G("E",0,0,"isoWeekday"),z("day","d"),z("weekday","e"),z("isoWeekday","E"),j("day",11),j("weekday",11),j("isoWeekday",11),K("d",Ji),K("e",Ji),K("E",Ji),K("dd",function(e,n){return n.weekdaysMinRegex(e)}),K("ddd",function(e,n){return n.weekdaysShortRegex(e)}),K("dddd",function(e,n){return n.weekdaysRegex(e)}),Q(["dd","ddd","dddd"],function(e,n,t,i){var r=t._locale.weekdaysParse(e,i,t._strict);null!=r?n.d=r:m(t).invalidWeekday=e}),Q(["d","e","E"],function(e,n,t,i){n[i]=k(e)});var Lr="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),_r="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),Cr="Su_Mo_Tu_We_Th_Fr_Sa".split("_"),Hr=hr,Ir=hr,Dr=hr;G("H",["HH",2],0,"hour"),G("h",["hh",2],0,Xe),G("k",["kk",2],0,Ue),G("hmm",0,0,function(){return""+Xe.apply(this)+B(this.minutes(),2)}),G("hmmss",0,0,function(){return""+Xe.apply(this)+B(this.minutes(),2)+B(this.seconds(),2)}),G("Hmm",0,0,function(){return""+this.hours()+B(this.minutes(),2)}),G("Hmmss",0,0,function(){return""+this.hours()+B(this.minutes(),2)+B(this.seconds(),2)}),Ke("a",!0),Ke("A",!1),z("hour","h"),j("hour",13),K("a",qe),K("A",qe),K("H",Ji),K("h",Ji),K("k",Ji),K("HH",Ji,Ki),K("hh",Ji,Ki),K("kk",Ji,Ki),K("hmm",Qi),K("hmmss",er),K("Hmm",Qi),K("Hmmss",er),J(["H","HH"],mr),J(["k","kk"],function(e,n,t){var i=k(e);n[mr]=24===i?0:i}),J(["a","A"],function(e,n,t){t._isPm=t._locale.isPM(e),t._meridiem=e}),J(["h","hh"],function(e,n,t){n[mr]=k(e),m(t).bigHour=!0}),J("hmm",function(e,n,t){var i=e.length-2;n[mr]=k(e.substr(0,i)),n[gr]=k(e.substr(i)),m(t).bigHour=!0}),J("hmmss",function(e,n,t){var i=e.length-4,r=e.length-2;n[mr]=k(e.substr(0,i)),n[gr]=k(e.substr(i,2)),n[xr]=k(e.substr(r)),m(t).bigHour=!0}),J("Hmm",function(e,n,t){var i=e.length-2;n[mr]=k(e.substr(0,i)),n[gr]=k(e.substr(i))}),J("Hmmss",function(e,n,t){var i=e.length-4,r=e.length-2;n[mr]=k(e.substr(0,i)),n[gr]=k(e.substr(i,2)),n[xr]=k(e.substr(r))});var Er,Rr=/[ap]\.?m?\.?/i,zr=re("Hours",!0),Nr={calendar:Ei,longDateFormat:Ri,invalidDate:zi,ordinal:Ni,dayOfMonthOrdinalParse:Wi,relativeTime:ji,months:Tr,monthsShort:Or,week:Ar,weekdays:Lr,weekdaysMin:Cr,weekdaysShort:_r,meridiemParse:Rr},Wr={},jr={},Fr=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,Br=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,Gr=/Z|[+-]\d\d(?::?\d\d)?/,Yr=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],Vr=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],Xr=/^\/?Date\((\-?\d+)/i,Ur=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,Kr={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};n.createFromInputFallback=O("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""))}),n.ISO_8601=function(){},n.RFC_2822=function(){};var qr=O("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=An.apply(null,arguments);return this.isValid()&&e.isValid()?e<this?this:e:x()}),Zr=O("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=An.apply(null,arguments);return this.isValid()&&e.isValid()?e>this?this:e:x()}),$r=function(){return Date.now?Date.now():+new Date},Jr=["year","quarter","month","week","day","hour","minute","second","millisecond"];Nn("Z",":"),Nn("ZZ",""),K("Z",sr),K("ZZ",sr),J(["Z","ZZ"],function(e,n,t){
t._useUTC=!0,t._tzm=Wn(sr,e)});var Qr=/([\+\-]|\d\d)/gi;n.updateOffset=function(){};var ea=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,na=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;Qn.fn=En.prototype,Qn.invalid=Dn;var ta=it(1,"add"),ia=it(-1,"subtract");n.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",n.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var ra=O("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});G(0,["gg",2],0,function(){return this.weekYear()%100}),G(0,["GG",2],0,function(){return this.isoWeekYear()%100}),Nt("gggg","weekYear"),Nt("ggggg","weekYear"),Nt("GGGG","isoWeekYear"),Nt("GGGGG","isoWeekYear"),z("weekYear","gg"),z("isoWeekYear","GG"),j("weekYear",1),j("isoWeekYear",1),K("G",ar),K("g",ar),K("GG",Ji,Ki),K("gg",Ji,Ki),K("GGGG",tr,Zi),K("gggg",tr,Zi),K("GGGGG",ir,$i),K("ggggg",ir,$i),Q(["gggg","ggggg","GGGG","GGGGG"],function(e,n,t,i){n[i.substr(0,2)]=k(e)}),Q(["gg","GG"],function(e,t,i,r){t[r]=n.parseTwoDigitYear(e)}),G("Q",0,"Qo","quarter"),z("quarter","Q"),j("quarter",7),K("Q",Ui),J("Q",function(e,n){n[ur]=3*(k(e)-1)}),G("D",["DD",2],"Do","date"),z("date","D"),j("date",9),K("D",Ji),K("DD",Ji,Ki),K("Do",function(e,n){return e?n._dayOfMonthOrdinalParse||n._ordinalParse:n._dayOfMonthOrdinalParseLenient}),J(["D","DD"],fr),J("Do",function(e,n){n[fr]=k(e.match(Ji)[0])});var aa=re("Date",!0);G("DDD",["DDDD",3],"DDDo","dayOfYear"),z("dayOfYear","DDD"),j("dayOfYear",4),K("DDD",nr),K("DDDD",qi),J(["DDD","DDDD"],function(e,n,t){t._dayOfYear=k(e)}),G("m",["mm",2],0,"minute"),z("minute","m"),j("minute",14),K("m",Ji),K("mm",Ji,Ki),J(["m","mm"],gr);var oa=re("Minutes",!1);G("s",["ss",2],0,"second"),z("second","s"),j("second",15),K("s",Ji),K("ss",Ji,Ki),J(["s","ss"],xr);var sa=re("Seconds",!1);G("S",0,0,function(){return~~(this.millisecond()/100)}),G(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),G(0,["SSS",3],0,"millisecond"),G(0,["SSSS",4],0,function(){return 10*this.millisecond()}),G(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),G(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),G(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),G(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),G(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),z("millisecond","ms"),j("millisecond",16),K("S",nr,Ui),K("SS",nr,Ki),K("SSS",nr,qi);var la;for(la="SSSS";la.length<=9;la+="S")K(la,rr);for(la="S";la.length<=9;la+="S")J(la,Ut);var ha=re("Milliseconds",!1);G("z",0,0,"zoneAbbr"),G("zz",0,0,"zoneName");var da=y.prototype;da.add=ta,da.calendar=ot,da.clone=st,da.diff=ft,da.endOf=Pt,da.format=yt,da.from=vt,da.fromNow=wt,da.to=kt,da.toNow=St,da.get=se,da.invalidAt=Rt,da.isAfter=lt,da.isBefore=ht,da.isBetween=dt,da.isSame=ct,da.isSameOrAfter=pt,da.isSameOrBefore=ut,da.isValid=Dt,da.lang=ra,da.locale=Tt,da.localeData=Ot,da.max=Zr,da.min=qr,da.parsingFlags=Et,da.set=le,da.startOf=Mt,da.subtract=ia,da.toArray=Ct,da.toObject=Ht,da.toDate=_t,da.toISOString=xt,da.inspect=bt,da.toJSON=It,da.toString=gt,da.unix=Lt,da.valueOf=At,da.creationData=zt,da.year=kr,da.isLeapYear=ie,da.weekYear=Wt,da.isoWeekYear=jt,da.quarter=da.quarters=Vt,da.month=ge,da.daysInMonth=xe,da.week=da.weeks=_e,da.isoWeek=da.isoWeeks=Ce,da.weeksInYear=Bt,da.isoWeeksInYear=Ft,da.date=aa,da.day=da.days=We,da.weekday=je,da.isoWeekday=Fe,da.dayOfYear=Xt,da.hour=da.hours=zr,da.minute=da.minutes=oa,da.second=da.seconds=sa,da.millisecond=da.milliseconds=ha,da.utcOffset=Bn,da.utc=Yn,da.local=Vn,da.parseZone=Xn,da.hasAlignedHourOffset=Un,da.isDST=Kn,da.isLocal=Zn,da.isUtcOffset=$n,da.isUtc=Jn,da.isUTC=Jn,da.zoneAbbr=Kt,da.zoneName=qt,da.dates=O("dates accessor is deprecated. Use date instead.",aa),da.months=O("months accessor is deprecated. Use month instead",ge),da.years=O("years accessor is deprecated. Use year instead",kr),da.zone=O("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",Gn),da.isDSTShifted=O("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",qn);var ca=_.prototype;ca.calendar=C,ca.longDateFormat=H,ca.invalidDate=I,ca.ordinal=D,ca.preparse=Jt,ca.postformat=Jt,ca.relativeTime=E,ca.pastFuture=R,ca.set=A,ca.months=ce,ca.monthsShort=pe,ca.monthsParse=fe,ca.monthsRegex=ye,ca.monthsShortRegex=be,ca.week=Pe,ca.firstDayOfYear=Le,ca.firstDayOfWeek=Ae,ca.weekdays=De,ca.weekdaysMin=Re,ca.weekdaysShort=Ee,ca.weekdaysParse=Ne,ca.weekdaysRegex=Be,ca.weekdaysShortRegex=Ge,ca.weekdaysMinRegex=Ye,ca.isPM=Ze,ca.meridiem=$e,nn("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var n=e%10,t=1===k(e%100/10)?"th":1===n?"st":2===n?"nd":3===n?"rd":"th";return e+t}}),n.lang=O("moment.lang is deprecated. Use moment.locale instead.",nn),n.langData=O("moment.langData is deprecated. Use moment.localeData instead.",an);var pa=Math.abs,ua=xi("ms"),fa=xi("s"),ma=xi("m"),ga=xi("h"),xa=xi("d"),ba=xi("w"),ya=xi("M"),va=xi("y"),wa=vi("milliseconds"),ka=vi("seconds"),Sa=vi("minutes"),Ta=vi("hours"),Oa=vi("days"),Ma=vi("months"),Pa=vi("years"),Aa=Math.round,La={ss:44,s:45,m:45,h:22,d:26,M:11},_a=Math.abs,Ca=En.prototype;return Ca.isValid=In,Ca.abs=si,Ca.add=hi,Ca.subtract=di,Ca.as=mi,Ca.asMilliseconds=ua,Ca.asSeconds=fa,Ca.asMinutes=ma,Ca.asHours=ga,Ca.asDays=xa,Ca.asWeeks=ba,Ca.asMonths=ya,Ca.asYears=va,Ca.valueOf=gi,Ca._bubble=pi,Ca.clone=bi,Ca.get=yi,Ca.milliseconds=wa,Ca.seconds=ka,Ca.minutes=Sa,Ca.hours=Ta,Ca.days=Oa,Ca.weeks=wi,Ca.months=Ma,Ca.years=Pa,Ca.humanize=Mi,Ca.toISOString=Ai,Ca.toString=Ai,Ca.toJSON=Ai,Ca.locale=Tt,Ca.localeData=Ot,Ca.toIsoString=O("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",Ai),Ca.lang=ra,G("X",0,0,"unix"),G("x",0,0,"valueOf"),K("x",ar),K("X",lr),J("X",function(e,n,t){t._d=new Date(1e3*parseFloat(e,10))}),J("x",function(e,n,t){t._d=new Date(k(e))}),n.version="2.22.2",i(An),n.fn=da,n.min=_n,n.max=Cn,n.now=$r,n.utc=u,n.unix=Zt,n.months=ti,n.isDate=h,n.locale=nn,n.invalid=x,n.duration=Qn,n.isMoment=v,n.weekdays=ri,n.parseZone=$t,n.localeData=an,n.isDuration=Rn,n.monthsShort=ii,n.weekdaysMin=oi,n.defineLocale=tn,n.updateLocale=rn,n.locales=on,n.weekdaysShort=ai,n.normalizeUnits=N,n.relativeTimeRounding=Ti,n.relativeTimeThreshold=Oi,n.calendarFormat=at,n.prototype=da,n.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"YYYY-[W]WW",MONTH:"YYYY-MM"},n})}).call(n,t(350)(e))},584:function(e,n){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=6)}({6:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var i=window.console,r=n.setLoggingConsole=function(e){i=e},a=function(e){return function(){var n;(n=i)[e].apply(n,arguments)}},o=n.debug=a("debug"),s=n.info=a("info"),l=n.warn=a("warn"),h=n.error=a("error"),d=n.log=a("log"),c=n.trace=a("trace");n["default"]={setLoggingConsole:r,debug:o,info:s,warn:l,error:h,log:d,trace:c}}})},585:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=18)}({0:function(e,n){e.exports=t("require/underscore")},18:function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0}),n.getRangeSeriesConfig=n.isRangeSeriesDataSet=void 0;var r=t(0),a=i(r);n.isRangeSeriesDataSet=function(e){var n=e.allFields();return(0,a["default"])(n).any(function(e){return/^_predicted/.test(e)})&&(0,a["default"])(n).any(function(e){return/^_lower/.test(e)})&&(0,a["default"])(n).any(function(e){return/^_upper/.test(e)})},n.getRangeSeriesConfig=function(e){var n=(0,a["default"])(e.allFields()).filter(function(e){return/^_predicted/.test(e)});return(0,a["default"])(n).map(function(n){var t=n.replace(/^_predicted/,""),i="_lower"+t,r="_upper"+t,o=(0,a["default"])(e.getSeries(n)).find(function(e){return!!e}),s=(0,a["default"])(e.getSeries(i)).find(function(e){return!!e}),l=(0,a["default"])(e.getSeries(r)).find(function(e){return!!e});return{predicted:o,lower:s,upper:l}})}}})},586:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=22)}([function(e,n){e.exports=t("require/underscore")},function(e,n){e.exports=t("shim/jquery")},,,,,,function(e,n){var t=e.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=t)},function(e,n){var t=e.exports={version:"2.5.1"};"number"==typeof __e&&(__e=t)},function(e,n){e.exports=function(e){return"object"==typeof e?null!==e:"function"==typeof e}},function(e,n,t){e.exports=!t(11)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(e,n){e.exports=function(e){try{return!!e()}catch(n){return!0}}},function(e,n){e.exports=function(e){if(void 0==e)throw TypeError("Can't call method on  "+e);return e}},function(e,n,t){var i=t(30),r=t(12);e.exports=function(e){return i(r(e))}},function(e,n){var t=Math.ceil,i=Math.floor;e.exports=function(e){return isNaN(e=+e)?0:(e>0?i:t)(e)}},,,,,,,,function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0}),n.createGlobalReference=n.gaugeAddTestingMetadata=n.gaugeUpdate=n.initializeTestingMetaData=n.getPointCoordinates=void 0;var r=t(23),a=i(r),o=t(1),s=i(o),l=t(0),h=i(l),d=function(e){return e=e.replace(/\s/g,""),/^[-]?[A-Za-z]/.test(e)?e.replace(/[^A-Za-z0-9_-]/g,""):""},c=function(e,n){e&&(n=d(n),""!==n&&(e.className.baseVal?e.className.baseVal+=" "+n:e.className.baseVal=n))},p=n.getPointCoordinates=function(e,n,t){var i=e.series[n],r=i.type,a=i.data[t],o=(0,s["default"])(e.container).offset();if(r in{line:!0,area:!0,scatter:!0})return e.inverted?{x:i.yAxis.translate(a.y)+o.left+e.plotLeft,y:e.plotHeight+e.plotTop+o.top-i.xAxis.translate(a.x)}:{x:a.plotX+o.left+e.plotLeft,y:a.plotY+o.top+e.plotTop};if("column"===r){var l=a.shapeArgs;return{x:a.plotX+o.left+e.plotLeft,y:a.plotY+o.top+e.plotTop+l.height/2}}if("bar"===r)return{x:o.left+e.plotLeft+e.plotWidth-a.shapeArgs.y-a.shapeArgs.height/2,y:o.top+e.plotTop+e.plotHeight-i.xAxis.translate(a.x)-i.barW/2-i.pointXOffset};if("pie"===r){var h=i.center[0],d=i.center[1],c=a.labelPos[0],p=a.labelPos[1];return{x:(h+c)/2+o.left+e.plotLeft,y:(d+p)/2+o.top+e.plotTop}}return{}},u=function(e){var n=void 0,t=void 0;(0,s["default"])(".highcharts-series",(0,s["default"])(e.container)).each(function(i,r){n=e.series[i].name,(0,s["default"])(r).attr("id",n+"-series"),t=(0,s["default"])("rect, path",(0,s["default"])(r)),t.each(function(e,n){c(n,"spl-display-object")})})},f=function(e){var n=void 0,t=void 0;(0,h["default"])(e.xAxis).each(function(n,t){var i=e.inverted?"vertical-axis":"horizontal-axis";c(n.axisGroup.element,i),c(n.labelGroup.element,i),c(n.gridGroup.element,"x-axis-"+t+"-grid-group")}),(0,h["default"])(e.yAxis).each(function(n,t){var i=e.inverted?"horizontal-axis":"vertical-axis";c(n.axisGroup.element,i),c(n.labelGroup.element,i),c(n.gridGroup.element,"y-axis-"+t+"-grid-group")}),(0,s["default"])(".highcharts-axis, .highcharts-axis-labels",(0,s["default"])(e.container)).each(function(e,t){n=(0,s["default"])("text",(0,s["default"])(t)),n.each(function(e,n){c(n,"spl-text-label")})});var i=function(e){(0,h["default"])(e.ticks).each(function(e){e.mark&&e.mark.element&&c(e.mark.element,"highcharts-axis-tickmark")})};for(t=0;t<e.xAxis.length;t++)e.xAxis[t].axisTitle&&c(e.xAxis[t].axisTitle.element,"x-axis-title"),i(e.xAxis[t]);for(t=0;t<e.yAxis.length;t++)e.yAxis[t].axisTitle&&c(e.yAxis[t].axisTitle.element,"y-axis-title"),i(e.yAxis[t])},m=function(e){var n=void 0;e.legend&&e.legend.down&&c(e.legend.down.element,"page-down-button"),e.legend&&e.legend.up&&c(e.legend.up.element,"page-up-button"),(0,s["default"])(e.series).each(function(e,t){t.legendItem&&(n=t.legendItem.textStr,t.legendSymbol&&(c(t.legendSymbol.element,"symbol"),c(t.legendSymbol.element,n+"-symbol")),t.legendLine&&(c(t.legendLine.element,"symbol"),c(t.legendLine.element,n+"-symbol")),t.legendItem&&c(t.legendItem.element,"legend-label"))})},g=function(){var e=void 0,n=void 0,t=void 0,i=(0,s["default"])(".highcharts-tooltip"),r=(0,s["default"])("tr",i);for(e=0;e<r.length;e++)t=(0,s["default"])("td",r[e]),0===e?((0,s["default"])(t[0]).addClass("time-value"),(0,s["default"])(t[0]).addClass("time")):(n=r[e].textContent.split(":"),(0,s["default"])(t[0]).addClass("key"),(0,s["default"])(t[0]).addClass(d(n[0]+"-key")),(0,s["default"])(t[1]).addClass("value"),(0,s["default"])(t[1]).addClass(d(n[0]+"-value")))},x=function(){var e=void 0,n=void 0,t=void 0,i=(0,s["default"])(".highcharts-tooltip"),r=(0,s["default"])("tr",i);for(e=0;e<r.length;e++)t=(0,s["default"])("td",r[e]),n=r[e].textContent,(0,s["default"])(t[0]).addClass("key"),(0,s["default"])(t[0]).addClass(d(n[0]+"-key")),(0,s["default"])(t[1]).addClass("value"),(0,s["default"])(t[1]).addClass(d(n[0]+"-value"))},b=(n.initializeTestingMetaData=function(e,n,t){e.$container.addClass("highcharts-wrapper"),e.$container.attr("id")||e.$container.attr("id",e.id);var i=e.hcChart;if((0,s["default"])(i.container).addClass(t),u(i),f(i),i.options.legend.enabled&&m(i),i.tooltip&&i.tooltip.refresh){var r=i.tooltip.refresh,a="_time"===h["default"].find(n,function(e){return"_time"===e})?g:x;i.tooltip.refresh=function(e){r.call(i.tooltip,e),a(i)}}i.getPointCoordinates=(0,h["default"])(p).bind(null,i)},n.gaugeUpdate=function(e,n){e.attr("data-gauge-value",n)});n.gaugeAddTestingMetadata=function(e,n,t,i){e.$container.attr("id")||e.$container.attr("id",e.id);var r=e.$hcContainer;r.addClass(t),b(r,i),n.valueDisplay&&c(n.valueDisplay.element,"gauge-value");var o=(0,a["default"])(n);o.filter(function(e){return/^tickLabel_/.test(e)}).forEach(function(e){c(n[e].element,"gauge-tick-label")}),o.filter(function(e){return/^colorBand/.test(e)}).forEach(function(e){c(n[e].element,"gauge-color-band")}),(0,s["default"])(".gauge-color-band").each(function(){(0,s["default"])(this).attr("data-band-color",(0,s["default"])(this).attr("fill"))}),n.fill&&(0,s["default"])(n.fill.element).attr("data-indicator-color",(0,s["default"])(n.fill.element).attr("fill")),n.needle&&c(n.needle.element,"gauge-indicator"),n.markerLine&&c(n.markerLine.element,"gauge-indicator")},n.createGlobalReference=function(e,n){var t=window.Splunk;if(t){t.JSCharting=t.JSCharting||{},t.JSCharting.chartByIdMap=t.JSCharting.chartByIdMap||{};var i=e.$container.attr("id");t.JSCharting.chartByIdMap[i]=n}}},function(e,n,t){e.exports={"default":t(24),__esModule:!0}},function(e,n,t){t(25),e.exports=t(8).Object.keys},function(e,n,t){var i=t(26),r=t(27);t(39)("keys",function(){return function(e){return r(i(e))}})},function(e,n,t){var i=t(12);e.exports=function(e){return Object(i(e))}},function(e,n,t){var i=t(28),r=t(38);e.exports=Object.keys||function(e){return i(e,r)}},function(e,n,t){var i=t(29),r=t(13),a=t(32)(!1),o=t(35)("IE_PROTO");e.exports=function(e,n){var t,s=r(e),l=0,h=[];for(t in s)t!=o&&i(s,t)&&h.push(t);for(;n.length>l;)i(s,t=n[l++])&&(~a(h,t)||h.push(t));return h}},function(e,n){var t={}.hasOwnProperty;e.exports=function(e,n){return t.call(e,n)}},function(e,n,t){var i=t(31);e.exports=Object("z").propertyIsEnumerable(0)?Object:function(e){return"String"==i(e)?e.split(""):Object(e)}},function(e,n){var t={}.toString;e.exports=function(e){return t.call(e).slice(8,-1)}},function(e,n,t){var i=t(13),r=t(33),a=t(34);e.exports=function(e){return function(n,t,o){var s,l=i(n),h=r(l.length),d=a(o,h);if(e&&t!=t){for(;h>d;)if(s=l[d++],s!=s)return!0}else for(;h>d;d++)if((e||d in l)&&l[d]===t)return e||d||0;return!e&&-1}}},function(e,n,t){var i=t(14),r=Math.min;e.exports=function(e){return e>0?r(i(e),9007199254740991):0}},function(e,n,t){var i=t(14),r=Math.max,a=Math.min;e.exports=function(e,n){return e=i(e),e<0?r(e+n,0):a(e,n)}},function(e,n,t){var i=t(36)("keys"),r=t(37);e.exports=function(e){return i[e]||(i[e]=r(e))}},function(e,n,t){var i=t(7),r="__core-js_shared__",a=i[r]||(i[r]={});e.exports=function(e){return a[e]||(a[e]={})}},function(e,n){var t=0,i=Math.random();e.exports=function(e){return"Symbol(".concat(void 0===e?"":e,")_",(++t+i).toString(36))}},function(e,n){e.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(e,n,t){var i=t(40),r=t(8),a=t(11);e.exports=function(e,n){var t=(r.Object||{})[e]||Object[e],o={};o[e]=n(t),i(i.S+i.F*a(function(){t(1)}),"Object",o)}},function(e,n,t){var i=t(7),r=t(8),a=t(41),o=t(43),s="prototype",l=function(e,n,t){var h,d,c,p=e&l.F,u=e&l.G,f=e&l.S,m=e&l.P,g=e&l.B,x=e&l.W,b=u?r:r[n]||(r[n]={}),y=b[s],v=u?i:f?i[n]:(i[n]||{})[s];u&&(t=n);for(h in t)d=!p&&v&&void 0!==v[h],d&&h in b||(c=d?v[h]:t[h],b[h]=u&&"function"!=typeof v[h]?t[h]:g&&d?a(c,i):x&&v[h]==c?function(e){var n=function(n,t,i){if(this instanceof e){switch(arguments.length){case 0:return new e;case 1:return new e(n);case 2:return new e(n,t)}return new e(n,t,i)}return e.apply(this,arguments)};return n[s]=e[s],n}(c):m&&"function"==typeof c?a(Function.call,c):c,m&&((b.virtual||(b.virtual={}))[h]=c,e&l.R&&y&&!y[h]&&o(y,h,c)))};l.F=1,l.G=2,l.S=4,l.P=8,l.B=16,l.W=32,l.U=64,l.R=128,e.exports=l},function(e,n,t){var i=t(42);e.exports=function(e,n,t){if(i(e),void 0===n)return e;switch(t){case 1:return function(t){return e.call(n,t)};case 2:return function(t,i){return e.call(n,t,i)};case 3:return function(t,i,r){return e.call(n,t,i,r)}}return function(){return e.apply(n,arguments)}}},function(e,n){e.exports=function(e){if("function"!=typeof e)throw TypeError(e+" is not a function!");return e}},function(e,n,t){var i=t(44),r=t(49);e.exports=t(10)?function(e,n,t){return i.f(e,n,r(1,t))}:function(e,n,t){return e[n]=t,e}},function(e,n,t){var i=t(45),r=t(46),a=t(48),o=Object.defineProperty;n.f=t(10)?Object.defineProperty:function(e,n,t){if(i(e),n=a(n,!0),i(t),r)try{return o(e,n,t)}catch(s){}if("get"in t||"set"in t)throw TypeError("Accessors not supported!");return"value"in t&&(e[n]=t.value),e}},function(e,n,t){var i=t(9);e.exports=function(e){if(!i(e))throw TypeError(e+" is not an object!");return e}},function(e,n,t){e.exports=!t(10)&&!t(11)(function(){return 7!=Object.defineProperty(t(47)("div"),"a",{get:function(){return 7}}).a})},function(e,n,t){var i=t(9),r=t(7).document,a=i(r)&&i(r.createElement);e.exports=function(e){return a?r.createElement(e):{}}},function(e,n,t){var i=t(9);e.exports=function(e,n){if(!i(e))return e;var t,r;if(n&&"function"==typeof(t=e.toString)&&!i(r=t.call(e)))return r;if("function"==typeof(t=e.valueOf)&&!i(r=t.call(e)))return r;if(!n&&"function"==typeof(t=e.toString)&&!i(r=t.call(e)))return r;throw TypeError("Can't convert object to primitive value")}},function(e,n){e.exports=function(e,n){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:n}}}])},587:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=17)}({1:function(e,n){e.exports=t("shim/jquery")},17:function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0}),n.showTickLabel=n.hideTickLabel=n.setLegendItemText=void 0;var r=t(1),a=i(r);n.setLegendItemText=function(e,n){e.attr("text")!==n&&(e.added=!0,e.attr({text:n}))},n.hideTickLabel=function(e){var n=e.label,t=e.label.element.nodeName.toLowerCase();"text"===t?n.hide():(0,a["default"])(n.element).hide()},n.showTickLabel=function(e){var n=e.label,t=e.label.element.nodeName.toLowerCase();"text"===t?n.show():(0,a["default"])(n.element).show()}}})},588:function(e,n){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=2)}([,,function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0});var r=t(3),a=i(r);n["default"]=a["default"],e.exports=n["default"]},function(e,n,t){"use strict";/**
	 * @license Highcharts JS v5.0.12 (2017-05-24)
	 *
	 * (c) 2009-2016 Torstein Honsi
	 *
	 * License: www.highcharts.com/license
	 */
!function(n){"object"==typeof e&&e.exports?e.exports=n:n(Highcharts)}(function(e){!function(e){function n(e,n){this.init(e,n)}var t=e.CenteredSeriesMixin,i=e.each,r=e.extend,a=e.merge,o=e.splat;r(n.prototype,{coll:"pane",init:function(e,n){this.chart=n,this.background=[],n.pane.push(this),this.setOptions(e)},setOptions:function(e){this.options=e=a(this.defaultOptions,this.chart.angular?{background:{}}:void 0,e)},render:function(){var e,n,t=this.options,i=this.options.background,r=this.chart.renderer;if(this.group||(this.group=r.g("pane-group").attr({zIndex:t.zIndex||0}).add()),this.updateCenter(),i)for(i=o(i),e=Math.max(i.length,this.background.length||0),n=0;n<e;n++)i[n]&&this.axis?this.renderBackground(a(this.defaultBackgroundOptions,i[n]),n):this.background[n]&&(this.background[n]=this.background[n].destroy(),this.background.splice(n,1))},renderBackground:function(e,n){var t="animate";this.background[n]||(this.background[n]=this.chart.renderer.path().add(this.group),t="attr"),this.background[n][t]({d:this.axis.getPlotBandPath(e.from,e.to,e)}).attr({fill:e.backgroundColor,stroke:e.borderColor,"stroke-width":e.borderWidth,"class":"highcharts-pane "+(e.className||"")})},defaultOptions:{center:["50%","50%"],size:"85%",startAngle:0},defaultBackgroundOptions:{shape:"circle",borderWidth:1,borderColor:"#cccccc",backgroundColor:{linearGradient:{x1:0,y1:0,x2:0,y2:1},stops:[[0,"#ffffff"],[1,"#e6e6e6"]]},from:-Number.MAX_VALUE,innerRadius:0,to:Number.MAX_VALUE,outerRadius:"105%"},updateCenter:function(e){this.center=(e||this.axis||{}).center=t.getCenter.call(this)},update:function(e,n){a(!0,this.options,e),this.setOptions(this.options),this.render(),i(this.chart.axes,function(e){e.pane===this&&(e.pane=null,e.update({},n))},this)}}),e.Pane=n}(e),function(e){var n,t,i=e.Axis,r=e.each,a=e.extend,o=e.map,s=e.merge,l=e.noop,h=e.pick,d=e.pInt,c=e.Tick,p=e.wrap,u=i.prototype,f=c.prototype;n={getOffset:l,redraw:function(){this.isDirty=!1},render:function(){this.isDirty=!1},setScale:l,setCategories:l,setTitle:l},t={defaultRadialGaugeOptions:{labels:{align:"center",x:0,y:null},minorGridLineWidth:0,minorTickInterval:"auto",minorTickLength:10,minorTickPosition:"inside",minorTickWidth:1,tickLength:10,tickPosition:"inside",tickWidth:2,title:{rotation:0},zIndex:2},defaultRadialXOptions:{gridLineWidth:1,labels:{align:null,distance:15,x:0,y:null},maxPadding:0,minPadding:0,showLastLabel:!1,tickLength:0},defaultRadialYOptions:{gridLineInterpolation:"circle",labels:{align:"right",x:-3,y:-2},showLastLabel:!1,title:{x:4,text:null,rotation:90}},setOptions:function(e){var n=this.options=s(this.defaultOptions,this.defaultRadialOptions,e);n.plotBands||(n.plotBands=[])},getOffset:function(){u.getOffset.call(this),this.chart.axisOffset[this.side]=0},getLinePath:function(e,n){var t,i,r=this.center,a=this.chart,o=h(n,r[2]/2-this.offset);return this.isCircular||void 0!==n?i=this.chart.renderer.symbols.arc(this.left+r[0],this.top+r[1],o,o,{start:this.startAngleRad,end:this.endAngleRad,open:!0,innerR:0}):(t=this.postTranslate(this.angleRad,o),i=["M",r[0]+a.plotLeft,r[1]+a.plotTop,"L",t.x,t.y]),i},setAxisTranslation:function(){u.setAxisTranslation.call(this),this.center&&(this.isCircular?this.transA=(this.endAngleRad-this.startAngleRad)/(this.max-this.min||1):this.transA=this.center[2]/2/(this.max-this.min||1),this.isXAxis?this.minPixelPadding=this.transA*this.minPointOffset:this.minPixelPadding=0)},beforeSetTickPositions:function(){this.autoConnect=this.isCircular&&void 0===h(this.userMax,this.options.max)&&this.endAngleRad-this.startAngleRad===2*Math.PI,this.autoConnect&&(this.max+=this.categories&&1||this.pointRange||this.closestPointRange||0)},setAxisSize:function(){u.setAxisSize.call(this),this.isRadial&&(this.pane.updateCenter(this),this.isCircular&&(this.sector=this.endAngleRad-this.startAngleRad),this.len=this.width=this.height=this.center[2]*h(this.sector,1)/2)},getPosition:function(e,n){return this.postTranslate(this.isCircular?this.translate(e):this.angleRad,h(this.isCircular?n:this.translate(e),this.center[2]/2)-this.offset)},postTranslate:function(e,n){var t=this.chart,i=this.center;return e=this.startAngleRad+e,{x:t.plotLeft+i[0]+Math.cos(e)*n,y:t.plotTop+i[1]+Math.sin(e)*n}},getPlotBandPath:function(e,n,t){var i,r,a,s,l=this.center,c=this.startAngleRad,p=l[2]/2,u=[h(t.outerRadius,"100%"),t.innerRadius,h(t.thickness,10)],f=Math.min(this.offset,0),m=/%$/,g=this.isCircular;return"polygon"===this.options.gridLineInterpolation?s=this.getPlotLinePath(e).concat(this.getPlotLinePath(n,!0)):(e=Math.max(e,this.min),n=Math.min(n,this.max),g||(u[0]=this.translate(e),u[1]=this.translate(n)),u=o(u,function(e){return m.test(e)&&(e=d(e,10)*p/100),e}),"circle"!==t.shape&&g?(i=c+this.translate(e),r=c+this.translate(n)):(i=-Math.PI/2,r=1.5*Math.PI,a=!0),u[0]-=f,u[2]-=f,s=this.chart.renderer.symbols.arc(this.left+l[0],this.top+l[1],u[0],u[0],{start:Math.min(i,r),end:Math.max(i,r),innerR:h(u[1],u[0]-u[2]),open:a})),s},getPlotLinePath:function(e,n){var t,i,a,o,s=this,l=s.center,h=s.chart,d=s.getPosition(e);return s.isCircular?o=["M",l[0]+h.plotLeft,l[1]+h.plotTop,"L",d.x,d.y]:"circle"===s.options.gridLineInterpolation?(e=s.translate(e),e&&(o=s.getLinePath(0,e))):(r(h.xAxis,function(e){e.pane===s.pane&&(t=e)}),o=[],e=s.translate(e),a=t.tickPositions,t.autoConnect&&(a=a.concat([a[0]])),n&&(a=[].concat(a).reverse()),r(a,function(n,r){i=t.getPosition(n,e),o.push(r?"L":"M",i.x,i.y)})),o},getTitlePosition:function(){var e=this.center,n=this.chart,t=this.options.title;return{x:n.plotLeft+e[0]+(t.x||0),y:n.plotTop+e[1]-{high:.5,middle:.25,low:0}[t.align]*e[2]+(t.y||0)}}},p(u,"init",function(e,i,r){var o,l,d=i.angular,c=i.polar,p=r.isX,u=d&&p,f=i.options,m=r.pane||0,g=this.pane=i.pane[m],x=g.options;d?(a(this,u?n:t),o=!p,o&&(this.defaultRadialOptions=this.defaultRadialGaugeOptions)):c&&(a(this,t),o=p,this.defaultRadialOptions=p?this.defaultRadialXOptions:s(this.defaultYAxisOptions,this.defaultRadialYOptions)),d||c?(this.isRadial=!0,i.inverted=!1,f.chart.zoomType=null):this.isRadial=!1,o&&(g.axis=this),e.call(this,i,r),u||!d&&!c||(l=this.options,this.angleRad=(l.angle||0)*Math.PI/180,this.startAngleRad=(x.startAngle-90)*Math.PI/180,this.endAngleRad=(h(x.endAngle,x.startAngle+360)-90)*Math.PI/180,this.offset=l.offset||0,this.isCircular=o)}),p(u,"autoLabelAlign",function(e){if(!this.isRadial)return e.apply(this,[].slice.call(arguments,1))}),p(f,"getPosition",function(e,n,t,i,r){var a=this.axis;return a.getPosition?a.getPosition(t):e.call(this,n,t,i,r)}),p(f,"getLabelPosition",function(e,n,t,i,r,a,o,s,l){var d,c=this.axis,p=a.y,u=20,f=a.align,m=(c.translate(this.pos)+c.startAngleRad+Math.PI/2)/Math.PI*180%360;return c.isRadial?(d=c.getPosition(this.pos,c.center[2]/2+h(a.distance,-25)),"auto"===a.rotation?i.attr({rotation:m}):null===p&&(p=c.chart.renderer.fontMetrics(i.styles.fontSize).b-i.getBBox().height/2),null===f&&(c.isCircular?(this.label.getBBox().width>c.len*c.tickInterval/(c.max-c.min)&&(u=0),f=m>u&&m<180-u?"left":m>180+u&&m<360-u?"right":"center"):f="center",i.attr({align:f})),d.x+=a.x,d.y+=p):d=e.call(this,n,t,i,r,a,o,s,l),d}),p(f,"getMarkPath",function(e,n,t,i,r,a,o){var s,l,h=this.axis;return h.isRadial?(s=h.getPosition(this.pos,h.center[2]/2+i),l=["M",n,t,"L",s.x,s.y]):l=e.call(this,n,t,i,r,a,o),l})}(e),function(e){var n=e.each,t=e.noop,i=e.pick,r=e.Series,a=e.seriesType,o=e.seriesTypes;a("arearange","area",{lineWidth:1,marker:null,threshold:null,tooltip:{pointFormat:'<span style="color:{series.color}"></span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'},trackByArea:!0,dataLabels:{align:null,verticalAlign:null,xLow:0,xHigh:0,yLow:0,yHigh:0},states:{hover:{halo:!1}}},{pointArrayMap:["low","high"],dataLabelCollections:["dataLabel","dataLabelUpper"],toYData:function(e){return[e.low,e.high]},pointValKey:"low",deferTranslatePolar:!0,highToXY:function(e){var n=this.chart,t=this.xAxis.postTranslate(e.rectPlotX,this.yAxis.len-e.plotHigh);e.plotHighX=t.x-n.plotLeft,e.plotHigh=t.y-n.plotTop},translate:function(){var e=this,t=e.yAxis,i=!!e.modifyValue;o.area.prototype.translate.apply(e),n(e.points,function(n){var r=n.low,a=n.high,o=n.plotY;null===a||null===r?n.isNull=!0:(n.plotLow=o,n.plotHigh=t.translate(i?e.modifyValue(a,n):a,0,1,0,1),i&&(n.yBottom=n.plotHigh))}),this.chart.polar&&n(this.points,function(n){e.highToXY(n)})},getGraphPath:function(e){var n,t,r,a,s,l,h,d=[],c=[],p=o.area.prototype.getGraphPath,u=this.options,f=this.chart.polar&&u.connectEnds!==!1,m=u.connectNulls,g=u.step;for(e=e||this.points,n=e.length,n=e.length;n--;)t=e[n],t.isNull||f||m||e[n+1]&&!e[n+1].isNull||c.push({plotX:t.plotX,plotY:t.plotY,doCurve:!1}),r={polarPlotY:t.polarPlotY,rectPlotX:t.rectPlotX,yBottom:t.yBottom,plotX:i(t.plotHighX,t.plotX),plotY:t.plotHigh,isNull:t.isNull},c.push(r),d.push(r),t.isNull||f||m||e[n-1]&&!e[n-1].isNull||c.push({plotX:t.plotX,plotY:t.plotY,doCurve:!1});return s=p.call(this,e),g&&(g===!0&&(g="left"),u.step={left:"right",center:"center",right:"left"}[g]),l=p.call(this,d),h=p.call(this,c),u.step=g,a=[].concat(s,l),this.chart.polar||"M"!==h[0]||(h[0]="L"),this.graphPath=a,this.areaPath=this.areaPath.concat(s,h),a.isArea=!0,a.xMap=s.xMap,this.areaPath.xMap=s.xMap,a},drawDataLabels:function(){var e,n,t,i=this.data,a=i.length,o=[],s=r.prototype,l=this.options.dataLabels,h=l.align,d=l.verticalAlign,c=l.inside,p=this.chart.inverted;if(l.enabled||this._hasPointLabels){for(e=a;e--;)n=i[e],n&&(t=c?n.plotHigh<n.plotLow:n.plotHigh>n.plotLow,n.y=n.high,n._plotY=n.plotY,n.plotY=n.plotHigh,o[e]=n.dataLabel,n.dataLabel=n.dataLabelUpper,n.below=t,p?h||(l.align=t?"right":"left"):d||(l.verticalAlign=t?"top":"bottom"),l.x=l.xHigh,l.y=l.yHigh);for(s.drawDataLabels&&s.drawDataLabels.apply(this,arguments),e=a;e--;)n=i[e],n&&(t=c?n.plotHigh<n.plotLow:n.plotHigh>n.plotLow,n.dataLabelUpper=n.dataLabel,n.dataLabel=o[e],n.y=n.low,n.plotY=n._plotY,n.below=!t,p?h||(l.align=t?"left":"right"):d||(l.verticalAlign=t?"bottom":"top"),l.x=l.xLow,l.y=l.yLow);s.drawDataLabels&&s.drawDataLabels.apply(this,arguments)}l.align=h,l.verticalAlign=d},alignDataLabel:function(){o.column.prototype.alignDataLabel.apply(this,arguments)},setStackedPoints:t,getSymbol:t,drawPoints:t})}(e),function(e){var n=e.seriesType,t=e.seriesTypes;n("areasplinerange","arearange",null,{getPointSpline:t.spline.prototype.getPointSpline})}(e),function(e){var n=e.defaultPlotOptions,t=e.each,i=e.merge,r=e.noop,a=e.pick,o=e.seriesType,s=e.seriesTypes,l=s.column.prototype;o("columnrange","arearange",i(n.column,n.arearange,{lineWidth:1,pointRange:null}),{translate:function(){var e,n,i=this,r=i.yAxis,o=i.xAxis,s=o.startAngleRad,h=i.chart,d=i.xAxis.isRadial;l.translate.apply(i),t(i.points,function(t){var l,c,p,u=t.shapeArgs,f=i.options.minPointLength;t.plotHigh=n=r.translate(t.high,0,1,0,1),t.plotLow=t.plotY,p=n,c=a(t.rectPlotY,t.plotY)-n,Math.abs(c)<f?(l=f-c,c+=l,p-=l/2):c<0&&(c*=-1,p-=c),d?(e=t.barX+s,t.shapeType="path",t.shapeArgs={d:i.polarArc(p+c,p,e,e+t.pointWidth)}):(u.height=c,u.y=p,t.tooltipPos=h.inverted?[r.len+r.pos-h.plotLeft-p-c/2,o.len+o.pos-h.plotTop-u.x-u.width/2,c]:[o.left-h.plotLeft+u.x+u.width/2,r.pos-h.plotTop+p+c/2,c])})},directTouch:!0,trackerGroups:["group","dataLabelsGroup"],drawGraph:r,crispCol:l.crispCol,drawPoints:l.drawPoints,drawTracker:l.drawTracker,getColumnMetrics:l.getColumnMetrics,animate:function(){return l.animate.apply(this,arguments)},polarArc:function(){return l.polarArc.apply(this,arguments)},pointAttribs:l.pointAttribs})}(e),function(e){var n=e.each,t=e.isNumber,i=e.merge,r=e.noop,a=e.pick,o=e.pInt,s=e.Series,l=e.seriesType,h=e.TrackerMixin;l("gauge","line",{dataLabels:{enabled:!0,defer:!1,y:15,borderRadius:3,crop:!1,verticalAlign:"top",zIndex:2,borderWidth:1,borderColor:"#cccccc"},dial:{},pivot:{},tooltip:{headerFormat:""},showInLegend:!1},{angular:!0,directTouch:!0,drawGraph:r,fixedBox:!0,forceDL:!0,noSharedTooltip:!0,trackerGroups:["group","dataLabelsGroup"],translate:function(){var e=this,r=e.yAxis,s=e.options,l=r.center;e.generatePoints(),n(e.points,function(e){var n=i(s.dial,e.dial),h=o(a(n.radius,80))*l[2]/200,d=o(a(n.baseLength,70))*h/100,c=o(a(n.rearLength,10))*h/100,p=n.baseWidth||3,u=n.topWidth||1,f=s.overshoot,m=r.startAngleRad+r.translate(e.y,null,null,null,!0);t(f)?(f=f/180*Math.PI,m=Math.max(r.startAngleRad-f,Math.min(r.endAngleRad+f,m))):s.wrap===!1&&(m=Math.max(r.startAngleRad,Math.min(r.endAngleRad,m))),m=180*m/Math.PI,e.shapeType="path",e.shapeArgs={d:n.path||["M",-c,-p/2,"L",d,-p/2,h,-u/2,h,u/2,d,p/2,-c,p/2,"z"],translateX:l[0],translateY:l[1],rotation:m},e.plotX=l[0],e.plotY=l[1]})},drawPoints:function(){var e=this,t=e.yAxis.center,r=e.pivot,o=e.options,s=o.pivot,l=e.chart.renderer;n(e.points,function(n){var t=n.graphic,r=n.shapeArgs,a=r.d,s=i(o.dial,n.dial);t?(t.animate(r),r.d=a):(n.graphic=l[n.shapeType](r).attr({rotation:r.rotation,zIndex:1}).addClass("highcharts-dial").add(e.group),n.graphic.attr({stroke:s.borderColor||"none","stroke-width":s.borderWidth||0,fill:s.backgroundColor||"#000000"}))}),r?r.animate({translateX:t[0],translateY:t[1]}):(e.pivot=l.circle(0,0,a(s.radius,5)).attr({zIndex:2}).addClass("highcharts-pivot").translate(t[0],t[1]).add(e.group),e.pivot.attr({"stroke-width":s.borderWidth||0,stroke:s.borderColor||"#cccccc",fill:s.backgroundColor||"#000000"}))},animate:function(e){var t=this;e||(n(t.points,function(e){var n=e.graphic;n&&(n.attr({rotation:180*t.yAxis.startAngleRad/Math.PI}),n.animate({rotation:e.shapeArgs.rotation},t.options.animation))}),t.animate=null)},render:function(){this.group=this.plotGroup("group","series",this.visible?"visible":"hidden",this.options.zIndex,this.chart.seriesGroup),s.prototype.render.call(this),this.group.clip(this.chart.clipRect)},setData:function(e,n){s.prototype.setData.call(this,e,!1),this.processData(),this.generatePoints(),a(n,!0)&&this.chart.redraw()},drawTracker:h&&h.drawTrackerPoint},{setState:function(e){this.state=e}})}(e),function(e){var n=e.each,t=e.noop,i=e.pick,r=e.seriesType,a=e.seriesTypes;r("boxplot","column",{threshold:null,tooltip:{pointFormat:'<span style="color:{point.color}"></span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'},whiskerLength:"50%",fillColor:"#ffffff",lineWidth:1,medianWidth:2,states:{hover:{brightness:-.3}},whiskerWidth:2},{pointArrayMap:["low","q1","median","q3","high"],toYData:function(e){return[e.low,e.q1,e.median,e.q3,e.high]},pointValKey:"high",pointAttribs:function(e){var n=this.options,t=e&&e.color||this.color;return{fill:e.fillColor||n.fillColor||t,stroke:n.lineColor||t,"stroke-width":n.lineWidth||0}},drawDataLabels:t,translate:function(){var e=this,t=e.yAxis,i=e.pointArrayMap;a.column.prototype.translate.apply(e),n(e.points,function(e){n(i,function(n){null!==e[n]&&(e[n+"Plot"]=t.translate(e[n],0,1,0,1))})})},drawPoints:function(){var e,t,r,a,o,s,l,h,d,c,p,u,f,m=this,g=m.points,x=m.options,b=m.chart,y=b.renderer,v=0,w=m.doQuartiles!==!1,k=m.options.whiskerLength;n(g,function(n){var g,b=n.graphic,S=b?"animate":"attr",T=n.shapeArgs,O={},M={},P={},A=n.color||m.color;void 0!==n.plotY&&(d=T.width,c=Math.floor(T.x),p=c+d,u=Math.round(d/2),e=Math.floor(w?n.q1Plot:n.lowPlot),t=Math.floor(w?n.q3Plot:n.lowPlot),r=Math.floor(n.highPlot),a=Math.floor(n.lowPlot),b||(n.graphic=b=y.g("point").add(m.group),n.stem=y.path().addClass("highcharts-boxplot-stem").add(b),k&&(n.whiskers=y.path().addClass("highcharts-boxplot-whisker").add(b)),w&&(n.box=y.path(h).addClass("highcharts-boxplot-box").add(b)),n.medianShape=y.path(s).addClass("highcharts-boxplot-median").add(b)),O.stroke=n.stemColor||x.stemColor||A,O["stroke-width"]=i(n.stemWidth,x.stemWidth,x.lineWidth),O.dashstyle=n.stemDashStyle||x.stemDashStyle,n.stem.attr(O),k&&(M.stroke=n.whiskerColor||x.whiskerColor||A,M["stroke-width"]=i(n.whiskerWidth,x.whiskerWidth,x.lineWidth),n.whiskers.attr(M)),w&&(g=m.pointAttribs(n),n.box.attr(g)),P.stroke=n.medianColor||x.medianColor||A,P["stroke-width"]=i(n.medianWidth,x.medianWidth,x.lineWidth),n.medianShape.attr(P),l=n.stem.strokeWidth()%2/2,v=c+u+l,n.stem[S]({d:["M",v,t,"L",v,r,"M",v,e,"L",v,a]}),w&&(l=n.box.strokeWidth()%2/2,e=Math.floor(e)+l,t=Math.floor(t)+l,c+=l,p+=l,n.box[S]({d:["M",c,t,"L",c,e,"L",p,e,"L",p,t,"L",c,t,"z"]})),k&&(l=n.whiskers.strokeWidth()%2/2,r+=l,a+=l,f=/%$/.test(k)?u*parseFloat(k)/100:k/2,n.whiskers[S]({d:["M",v-f,r,"L",v+f,r,"M",v-f,a,"L",v+f,a]})),o=Math.round(n.medianPlot),l=n.medianShape.strokeWidth()%2/2,o+=l,n.medianShape[S]({d:["M",c,o,"L",p,o]}))})},setStackedPoints:t})}(e),function(e){var n=e.each,t=e.noop,i=e.seriesType,r=e.seriesTypes;i("errorbar","boxplot",{color:"#000000",grouping:!1,linkedTo:":previous",tooltip:{pointFormat:'<span style="color:{point.color}"></span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'},whiskerWidth:null},{type:"errorbar",pointArrayMap:["low","high"],toYData:function(e){return[e.low,e.high]},pointValKey:"high",doQuartiles:!1,drawDataLabels:r.arearange?function(){var e=this.pointValKey;r.arearange.prototype.drawDataLabels.call(this),n(this.data,function(n){n.y=n[e]})}:t,getColumnMetrics:function(){return this.linkedParent&&this.linkedParent.columnMetrics||r.column.prototype.getColumnMetrics.call(this)}})}(e),function(e){var n=e.correctFloat,t=e.isNumber,i=e.pick,r=e.Point,a=e.Series,o=e.seriesType,s=e.seriesTypes;o("waterfall","column",{dataLabels:{inside:!0},lineWidth:1,lineColor:"#333333",dashStyle:"dot",borderColor:"#333333",states:{hover:{lineWidthPlus:0}}},{pointValKey:"y",translate:function(){var e,t,r,a,o,l,h,d,c,p,u,f,m,g=this,x=g.options,b=g.yAxis,y=i(x.minPointLength,5),v=y/2,w=x.threshold,k=x.stacking;for(s.column.prototype.translate.apply(g),c=p=w,r=g.points,t=0,e=r.length;t<e;t++)a=r[t],d=g.processedYData[t],o=a.shapeArgs,l=k&&b.stacks[(g.negStacks&&d<w?"-":"")+g.stackKey],f=g.getStackIndicator(f,a.x,g.index),u=l?l[a.x].points[f.key]:[0,d],a.isSum?a.y=n(d):a.isIntermediateSum&&(a.y=n(d-p)),h=Math.max(c,c+a.y)+u[0],o.y=b.translate(h,0,1,0,1),a.isSum?(o.y=b.translate(u[1],0,1,0,1),o.height=Math.min(b.translate(u[0],0,1,0,1),b.len)-o.y):a.isIntermediateSum?(o.y=b.translate(u[1],0,1,0,1),o.height=Math.min(b.translate(p,0,1,0,1),b.len)-o.y,p=u[1]):(o.height=d>0?b.translate(c,0,1,0,1)-o.y:b.translate(c,0,1,0,1)-b.translate(c-d,0,1,0,1),c+=l&&l[a.x]?l[a.x].total:d),o.height<0&&(o.y+=o.height,o.height*=-1),a.plotY=o.y=Math.round(o.y)-g.borderWidth%2/2,o.height=Math.max(Math.round(o.height),.001),a.yBottom=o.y+o.height,o.height<=y&&!a.isNull?(o.height=y,o.y-=v,a.plotY=o.y,a.y<0?a.minPointLengthOffset=-v:a.minPointLengthOffset=v):a.minPointLengthOffset=0,m=a.plotY+(a.negative?o.height:0),g.chart.inverted?a.tooltipPos[0]=b.len-m:a.tooltipPos[1]=m},processData:function(e){var t,i,r,o,s,l,h,d=this,c=d.options,p=d.yData,u=d.options.data,f=p.length,m=c.threshold||0;for(r=i=o=s=m,h=0;h<f;h++)l=p[h],t=u&&u[h]?u[h]:{},"sum"===l||t.isSum?p[h]=n(r):"intermediateSum"===l||t.isIntermediateSum?p[h]=n(i):(r+=l,i+=l),o=Math.min(r,o),s=Math.max(r,s);a.prototype.processData.call(this,e),d.options.stacking||(d.dataMin=o,d.dataMax=s)},toYData:function(e){return e.isSum?0===e.x?null:"sum":e.isIntermediateSum?0===e.x?null:"intermediateSum":e.y},pointAttribs:function(e,n){var t,i=this.options.upColor;return i&&!e.options.color&&(e.color=e.y>0?i:null),t=s.column.prototype.pointAttribs.call(this,e,n),delete t.dashstyle,t},getGraphPath:function(){return["M",0,0]},getCrispPath:function(){var e,n,t,i,r=this.data,a=r.length,o=this.graph.strokeWidth()+this.borderWidth,s=Math.round(o)%2/2,l=this.yAxis.reversed,h=[];for(t=1;t<a;t++)n=r[t].shapeArgs,e=r[t-1].shapeArgs,i=["M",e.x+e.width,e.y+r[t-1].minPointLengthOffset+s,"L",n.x,e.y+r[t-1].minPointLengthOffset+s],(r[t-1].y<0&&!l||r[t-1].y>0&&l)&&(i[2]+=e.height,i[5]+=e.height),h=h.concat(i);return h},drawGraph:function(){a.prototype.drawGraph.call(this),this.graph.attr({d:this.getCrispPath()})},setStackedPoints:function(){var e,n,t=this,i=t.options;for(a.prototype.setStackedPoints.apply(t,arguments),e=t.stackedYData?t.stackedYData.length:0,n=1;n<e;n++)i.data[n].isSum||i.data[n].isIntermediateSum||(t.stackedYData[n]+=t.stackedYData[n-1])},getExtremes:function(){if(this.options.stacking)return a.prototype.getExtremes.apply(this,arguments)}},{getClassName:function(){var e=r.prototype.getClassName.call(this);return this.isSum?e+=" highcharts-sum":this.isIntermediateSum&&(e+=" highcharts-intermediate-sum"),e},isValid:function(){return t(this.y,!0)||this.isSum||this.isIntermediateSum}})}(e),function(e){var n=e.LegendSymbolMixin,t=e.noop,i=e.Series,r=e.seriesType,a=e.seriesTypes;r("polygon","scatter",{marker:{enabled:!1,states:{hover:{enabled:!1}}},stickyTracking:!1,tooltip:{followPointer:!0,pointFormat:""},trackByArea:!0},{type:"polygon",getGraphPath:function(){for(var e=i.prototype.getGraphPath.call(this),n=e.length+1;n--;)(n===e.length||"M"===e[n])&&n>0&&e.splice(n,0,"z");return this.areaPath=e,e},drawGraph:function(){this.options.fillColor=this.color,a.area.prototype.drawGraph.call(this)},drawLegendSymbol:n.drawRectangle,drawTracker:i.prototype.drawTracker,setStackedPoints:t})}(e),function(e){var n=e.arrayMax,t=e.arrayMin,i=e.Axis,r=e.color,a=e.each,o=e.isNumber,s=e.noop,l=e.pick,h=e.pInt,d=e.Point,c=e.Series,p=e.seriesType,u=e.seriesTypes;p("bubble","scatter",{dataLabels:{formatter:function(){return this.point.z},inside:!0,verticalAlign:"middle"},marker:{lineColor:null,lineWidth:1,radius:null,states:{hover:{radiusPlus:0}},symbol:"circle"},minSize:8,maxSize:"20%",softThreshold:!1,states:{hover:{halo:{size:5}}},tooltip:{pointFormat:"({point.x}, {point.y}), Size: {point.z}"},turboThreshold:0,zThreshold:0,zoneAxis:"z"},{pointArrayMap:["y","z"],parallelArrays:["x","y","z"],trackerGroups:["group","dataLabelsGroup"],specialGroup:"group",bubblePadding:!0,zoneAxis:"z",directTouch:!0,pointAttribs:function(e,n){var t=this.options.marker,i=l(t.fillOpacity,.5),a=c.prototype.pointAttribs.call(this,e,n);return 1!==i&&(a.fill=r(a.fill).setOpacity(i).get("rgba")),a},getRadii:function(e,n,t,i){var r,a,o,s,l,h=this.zData,d=[],c=this.options,p="width"!==c.sizeBy,u=c.zThreshold,f=n-e;for(a=0,r=h.length;a<r;a++)s=h[a],c.sizeByAbsoluteValue&&null!==s&&(s=Math.abs(s-u),n=Math.max(n-u,Math.abs(e-u)),e=0),null===s?l=null:s<e?l=t/2-1:(o=f>0?(s-e)/f:.5,p&&o>=0&&(o=Math.sqrt(o)),l=Math.ceil(t+o*(i-t))/2),d.push(l);this.radii=d},animate:function(e){var n=this.options.animation;e||(a(this.points,function(e){var t,i=e.graphic;i&&i.width&&(t={x:i.x,y:i.y,width:i.width,height:i.height},i.attr({x:e.plotX,y:e.plotY,width:1,height:1}),i.animate(t,n))}),this.animate=null)},translate:function(){var n,t,i,r=this.data,a=this.radii;for(u.scatter.prototype.translate.call(this),n=r.length;n--;)t=r[n],i=a?a[n]:0,o(i)&&i>=this.minPxSize/2?(t.marker=e.extend(t.marker,{radius:i,width:2*i,height:2*i}),t.dlBox={x:t.plotX-i,y:t.plotY-i,width:2*i,height:2*i}):t.shapeArgs=t.plotY=t.dlBox=void 0},alignDataLabel:u.column.prototype.alignDataLabel,buildKDTree:s,applyZones:s},{haloPath:function(e){return d.prototype.haloPath.call(this,0===e?0:(this.marker?this.marker.radius||0:0)+e)},ttBelow:!1}),i.prototype.beforePadding=function(){var e=this,i=this.len,r=this.chart,s=0,d=i,c=this.isXAxis,p=c?"xData":"yData",u=this.min,f={},m=Math.min(r.plotWidth,r.plotHeight),g=Number.MAX_VALUE,x=-Number.MAX_VALUE,b=this.max-u,y=i/b,v=[];a(this.series,function(i){var o,s=i.options;!i.bubblePadding||!i.visible&&r.options.chart.ignoreHiddenSeries||(e.allowZoomOutside=!0,v.push(i),c&&(a(["minSize","maxSize"],function(e){var n=s[e],t=/%$/.test(n);n=h(n),f[e]=t?m*n/100:n}),i.minPxSize=f.minSize,i.maxPxSize=Math.max(f.maxSize,f.minSize),o=i.zData,o.length&&(g=l(s.zMin,Math.min(g,Math.max(t(o),s.displayNegative===!1?s.zThreshold:-Number.MAX_VALUE))),x=l(s.zMax,Math.max(x,n(o))))))}),a(v,function(n){var t,i=n[p],r=i.length;if(c&&n.getRadii(g,x,n.minPxSize,n.maxPxSize),b>0)for(;r--;)o(i[r])&&e.dataMin<=i[r]&&i[r]<=e.dataMax&&(t=n.radii[r],s=Math.min((i[r]-u)*y-t,s),d=Math.max((i[r]-u)*y+t,d))}),v.length&&b>0&&!this.isLog&&(d-=i,y*=(i+s-d)/i,a([["min","userMin",s],["max","userMax",d]],function(n){void 0===l(e.options[n[0]],e[n[1]])&&(e[n[0]]+=n[2]/y)}))}}(e),function(e){function n(e,n){var t,i=this.chart,r=this.options.animation,a=this.group,o=this.markerGroup,s=this.xAxis.center,l=i.plotLeft,h=i.plotTop;i.polar?i.renderer.isSVG&&(r===!0&&(r={}),n?(t={translateX:s[0]+l,translateY:s[1]+h,scaleX:.001,scaleY:.001},a.attr(t),o&&o.attr(t)):(t={translateX:l,translateY:h,scaleX:1,scaleY:1},a.animate(t,r),o&&o.animate(t,r),this.animate=null)):e.call(this,n)}var t,i=e.each,r=e.pick,a=e.Pointer,o=e.Series,s=e.seriesTypes,l=e.wrap,h=o.prototype,d=a.prototype;h.searchPointByAngle=function(e){var n=this,t=n.chart,i=n.xAxis,r=i.pane.center,a=e.chartX-r[0]-t.plotLeft,o=e.chartY-r[1]-t.plotTop;return this.searchKDTree({clientX:180+Math.atan2(a,o)*(-180/Math.PI)})},h.getConnectors=function(e,n,t,i){var r,a,o,s,l,h,d,c,p,u,f,m,g,x,b,y,v,w,k,S,T,O=1.5,M=O+1,P=i?1:0;return r=n>=0&&n<=e.length-1?n:n<0?e.length-1+n:0,a=r-1<0?e.length-(1+P):r-1,o=r+1>e.length-1?P:r+1,s=e[a],l=e[o],h=s.plotX,d=s.plotY,c=l.plotX,p=l.plotY,u=e[r].plotX,f=e[r].plotY,g=(O*u+h)/M,x=(O*f+d)/M,b=(O*u+c)/M,y=(O*f+p)/M,v=Math.sqrt(Math.pow(g-u,2)+Math.pow(x-f,2)),w=Math.sqrt(Math.pow(b-u,2)+Math.pow(y-f,2)),k=Math.atan2(x-f,g-u),S=Math.atan2(y-f,b-u),T=Math.PI/2+(k+S)/2,Math.abs(k-T)>Math.PI/2&&(T-=Math.PI),g=u+Math.cos(T)*v,x=f+Math.sin(T)*v,b=u+Math.cos(Math.PI+T)*w,y=f+Math.sin(Math.PI+T)*w,m={rightContX:b,rightContY:y,leftContX:g,leftContY:x,plotX:u,plotY:f},t&&(m.prevPointCont=this.getConnectors(e,a,!1,i)),m},l(h,"buildKDTree",function(e){this.chart.polar&&(this.kdByAngle?this.searchPoint=this.searchPointByAngle:this.options.findNearestPointBy="xy"),e.apply(this)}),h.toXY=function(e){var n,t,i=this.chart,r=e.plotX,a=e.plotY;e.rectPlotX=r,e.rectPlotY=a,n=this.xAxis.postTranslate(e.plotX,this.yAxis.len-a),e.plotX=e.polarPlotX=n.x-i.plotLeft,e.plotY=e.polarPlotY=n.y-i.plotTop,this.kdByAngle?(t=(r/Math.PI*180+this.xAxis.pane.options.startAngle)%360,t<0&&(t+=360),e.clientX=t):e.clientX=e.plotX},s.spline&&(l(s.spline.prototype,"getPointSpline",function(e,n,t,i){var r,a;return this.chart.polar?i?(a=this.getConnectors(n,i,!0,this.connectEnds),r=["C",a.prevPointCont.rightContX,a.prevPointCont.rightContY,a.leftContX,a.leftContY,a.plotX,a.plotY]):r=["M",t.plotX,t.plotY]:r=e.call(this,n,t,i),r}),s.areasplinerange&&(s.areasplinerange.prototype.getPointSpline=s.spline.prototype.getPointSpline)),l(h,"translate",function(e){var n,t,i=this.chart;if(e.call(this),i.polar&&(this.kdByAngle=i.tooltip&&i.tooltip.shared,!this.preventPostTranslate))for(n=this.points,t=n.length;t--;)this.toXY(n[t])}),l(h,"getGraphPath",function(e,n){var t,r,a,o=this;if(this.chart.polar){for(n=n||this.points,t=0;t<n.length;t++)if(!n[t].isNull){r=t;break}this.options.connectEnds!==!1&&void 0!==r&&(this.connectEnds=!0,n.splice(n.length,0,n[r]),a=!0),i(n,function(e){void 0===e.polarPlotY&&o.toXY(e)})}var s=e.apply(this,[].slice.call(arguments,1));return a&&n.pop(),s}),l(h,"animate",n),s.column&&(t=s.column.prototype,t.polarArc=function(e,n,t,i){var a=this.xAxis.center,o=this.yAxis.len;return this.chart.renderer.symbols.arc(a[0],a[1],o-n,null,{start:t,end:i,innerR:o-r(e,o)})},l(t,"animate",n),l(t,"translate",function(e){var n,t,i,r,a=this.xAxis,o=a.startAngleRad;if(this.preventPostTranslate=!0,e.call(this),a.isRadial)for(t=this.points,r=t.length;r--;)i=t[r],n=i.barX+o,i.shapeType="path",i.shapeArgs={d:this.polarArc(i.yBottom,i.plotY,n,n+i.pointWidth)},this.toXY(i),i.tooltipPos=[i.plotX,i.plotY],i.ttBelow=i.plotY>a.center[1]}),l(t,"alignDataLabel",function(e,n,t,i,r,a){if(this.chart.polar){var o,s,l=n.rectPlotX/Math.PI*180;null===i.align&&(o=l>20&&l<160?"left":l>200&&l<340?"right":"center",i.align=o),null===i.verticalAlign&&(s=l<45||l>315?"bottom":l>135&&l<225?"top":"middle",i.verticalAlign=s),h.alignDataLabel.call(this,n,t,i,r,a)}else e.call(this,n,t,i,r,a)})),l(d,"getCoordinates",function(e,n){var t=this.chart,r={xAxis:[],yAxis:[]};return t.polar?i(t.axes,function(e){var i=e.isXAxis,a=e.center,o=n.chartX-a[0]-t.plotLeft,s=n.chartY-a[1]-t.plotTop;r[i?"xAxis":"yAxis"].push({axis:e,value:e.translate(i?Math.PI-Math.atan2(o,s):Math.sqrt(Math.pow(o,2)+Math.pow(s,2)),!0)})}):r=e.call(this,n),r}),l(e.Chart.prototype,"getAxes",function(n){this.pane||(this.pane=[]),i(e.splat(this.options.pane),function(n){new e.Pane(n,this)},this),n.call(this)}),l(e.Chart.prototype,"drawChartBox",function(e){e.call(this),i(this.pane,function(e){e.render()})}),l(e.Chart.prototype,"get",function(n,t){return e.find(this.pane,function(e){return e.options.id===t})||n.call(this,t)})}(e)})}])},589:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=57)}([function(e,n){var t=Array.isArray;e.exports=t},function(e,n,t){var i=t(32),r="object"==typeof self&&self&&self.Object===Object&&self,a=i||r||Function("return this")();e.exports=a},function(e,n){function t(e){var n=typeof e;return null!=e&&("object"==n||"function"==n)}e.exports=t},function(e,n){function t(e){return null!=e&&"object"==typeof e}e.exports=t},function(e,n,t){function i(e,n){var t=a(e,n);return r(t)?t:void 0}var r=t(70),a=t(76);e.exports=i},function(e,n,t){function i(e){return null==e?void 0===e?l:s:h&&h in Object(e)?a(e):o(e)}var r=t(11),a=t(72),o=t(73),s="[object Null]",l="[object Undefined]",h=r?r.toStringTag:void 0;e.exports=i},function(e,n,t){function i(e){return null!=e&&a(e.length)&&!r(e)}var r=t(23),a=t(27);e.exports=i},function(e,n,t){function i(e){return"symbol"==typeof e||a(e)&&r(e)==o}var r=t(5),a=t(3),o="[object Symbol]";e.exports=i},function(e,n){function t(e,n){return e===n||e!==e&&n!==n}e.exports=t},function(e,n,t){function i(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var i=e[n];this.set(i[0],i[1])}}var r=t(60),a=t(61),o=t(62),s=t(63),l=t(64);i.prototype.clear=r,i.prototype["delete"]=a,i.prototype.get=o,i.prototype.has=s,i.prototype.set=l,e.exports=i},function(e,n,t){function i(e,n){for(var t=e.length;t--;)if(r(e[t][0],n))return t;return-1}var r=t(8);e.exports=i},function(e,n,t){var i=t(1),r=i.Symbol;e.exports=r},function(e,n,t){var i=t(4),r=i(Object,"create");e.exports=r},function(e,n,t){function i(e,n){var t=e.__data__;return r(n)?t["string"==typeof n?"string":"hash"]:t.map}var r=t(85);e.exports=i},function(e,n){function t(e){var n=e&&e.constructor,t="function"==typeof n&&n.prototype||i;return e===t}var i=Object.prototype;e.exports=t},function(e,n,t){var i=t(97),r=t(3),a=Object.prototype,o=a.hasOwnProperty,s=a.propertyIsEnumerable,l=i(function(){return arguments}())?i:function(e){return r(e)&&o.call(e,"callee")&&!s.call(e,"callee")};e.exports=l},function(e,n,t){(function(e){var i=t(1),r=t(99),a="object"==typeof n&&n&&!n.nodeType&&n,o=a&&"object"==typeof e&&e&&!e.nodeType&&e,s=o&&o.exports===a,l=s?i.Buffer:void 0,h=l?l.isBuffer:void 0,d=h||r;e.exports=d}).call(n,t(26)(e))},function(e,n,t){var i=t(101),r=t(102),a=t(103),o=a&&a.isTypedArray,s=o?r(o):i;e.exports=s},function(e,n){function t(e){return e}e.exports=t},function(e,n,t){function i(e){return o(e)?r(e):a(e)}var r=t(41),a=t(42),o=t(6);e.exports=i},function(e,n,t){function i(e){if("string"==typeof e||r(e))return e;var n=e+"";return"0"==n&&1/e==-a?"-0":n}var r=t(7),a=1/0;e.exports=i},function(e,n,t){function i(e){var n=this.__data__=new r(e);this.size=n.size}var r=t(9),a=t(65),o=t(66),s=t(67),l=t(68),h=t(69);i.prototype.clear=a,i.prototype["delete"]=o,i.prototype.get=s,i.prototype.has=l,i.prototype.set=h,e.exports=i},function(e,n,t){var i=t(4),r=t(1),a=i(r,"Map");e.exports=a;
},function(e,n,t){function i(e){if(!a(e))return!1;var n=r(e);return n==s||n==l||n==o||n==h}var r=t(5),a=t(2),o="[object AsyncFunction]",s="[object Function]",l="[object GeneratorFunction]",h="[object Proxy]";e.exports=i},function(e,n,t){function i(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var i=e[n];this.set(i[0],i[1])}}var r=t(77),a=t(84),o=t(86),s=t(87),l=t(88);i.prototype.clear=r,i.prototype["delete"]=a,i.prototype.get=o,i.prototype.has=s,i.prototype.set=l,e.exports=i},function(e,n,t){function i(e,n,t){"__proto__"==n&&r?r(e,n,{configurable:!0,enumerable:!0,value:t,writable:!0}):e[n]=t}var r=t(35);e.exports=i},function(e,n){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,n){function t(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=i}var i=9007199254740991;e.exports=t},function(e,n){function t(e,n){return n=null==n?i:n,!!n&&("number"==typeof e||r.test(e))&&e>-1&&e%1==0&&e<n}var i=9007199254740991,r=/^(?:0|[1-9]\d*)$/;e.exports=t},function(e,n,t){function i(e,n,t){if(!s(t))return!1;var i=typeof n;return!!("number"==i?a(t)&&o(n,t.length):"string"==i&&n in t)&&r(t[n],e)}var r=t(8),a=t(6),o=t(28),s=t(2);e.exports=i},function(e,n,t){function i(e,n,t,o,s){return e===n||(null==e||null==n||!a(e)&&!a(n)?e!==e&&n!==n:r(e,n,t,o,i,s))}var r=t(136),a=t(3);e.exports=i},function(e,n,t){function i(e,n){if(r(e))return!1;var t=typeof e;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=e&&!a(e))||(s.test(e)||!o.test(e)||null!=n&&e in Object(n))}var r=t(0),a=t(7),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;e.exports=i},function(e,n,t){(function(n){var t="object"==typeof n&&n&&n.Object===Object&&n;e.exports=t}).call(n,t(71))},function(e,n){function t(e){if(null!=e){try{return r.call(e)}catch(n){}try{return e+""}catch(n){}}return""}var i=Function.prototype,r=i.toString;e.exports=t},function(e,n,t){function i(e,n,t){(void 0===t||a(e[n],t))&&(void 0!==t||n in e)||r(e,n,t)}var r=t(25),a=t(8);e.exports=i},function(e,n,t){var i=t(4),r=function(){try{var e=i(Object,"defineProperty");return e({},"",{}),e}catch(n){}}();e.exports=r},function(e,n,t){var i=t(89),r=i();e.exports=r},function(e,n,t){var i=t(1),r=i.Uint8Array;e.exports=r},function(e,n,t){var i=t(39),r=i(Object.getPrototypeOf,Object);e.exports=r},function(e,n){function t(e,n){return function(t){return e(n(t))}}e.exports=t},function(e,n,t){function i(e){return o(e)?r(e,!0):a(e)}var r=t(41),a=t(108),o=t(6);e.exports=i},function(e,n,t){function i(e,n){var t=o(e),i=!t&&a(e),d=!t&&!i&&s(e),p=!t&&!i&&!d&&h(e),u=t||i||d||p,f=u?r(e.length,String):[],m=f.length;for(var g in e)!n&&!c.call(e,g)||u&&("length"==g||d&&("offset"==g||"parent"==g)||p&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||l(g,m))||f.push(g);return f}var r=t(107),a=t(15),o=t(0),s=t(16),l=t(28),h=t(17),d=Object.prototype,c=d.hasOwnProperty;e.exports=i},function(e,n,t){function i(e){if(!r(e))return a(e);var n=[];for(var t in Object(e))s.call(e,t)&&"constructor"!=t&&n.push(t);return n}var r=t(14),a=t(119),o=Object.prototype,s=o.hasOwnProperty;e.exports=i},function(e,n,t){var i=t(120),r=t(22),a=t(121),o=t(122),s=t(123),l=t(5),h=t(33),d="[object Map]",c="[object Object]",p="[object Promise]",u="[object Set]",f="[object WeakMap]",m="[object DataView]",g=h(i),x=h(r),b=h(a),y=h(o),v=h(s),w=l;(i&&w(new i(new ArrayBuffer(1)))!=m||r&&w(new r)!=d||a&&w(a.resolve())!=p||o&&w(new o)!=u||s&&w(new s)!=f)&&(w=function(e){var n=l(e),t=n==c?e.constructor:void 0,i=t?h(t):"";if(i)switch(i){case g:return m;case x:return d;case b:return p;case y:return u;case v:return f}return n}),e.exports=w},function(e,n,t){function i(e,n,t){return n===n?o(e,n,t):r(e,a,t)}var r=t(125),a=t(126),o=t(127);e.exports=i},function(e,n,t){function i(e){var n=r(e),t=n%1;return n===n?t?n-t:n:0}var r=t(129);e.exports=i},function(e,n){function t(e,n){for(var t=-1,i=null==e?0:e.length,r=Array(i);++t<i;)r[t]=n(e[t],t,e);return r}e.exports=t},function(e,n){function t(e,n){for(var t=-1,i=null==e?0:e.length;++t<i;)if(n(e[t],t,e))return!0;return!1}e.exports=t},function(e,n,t){function i(e){return"function"==typeof e?e:null==e?o:"object"==typeof e?s(e)?a(e[0],e[1]):r(e):l(e)}var r=t(134),a=t(152),o=t(18),s=t(0),l=t(160);e.exports=i},function(e,n,t){function i(e,n,t,i,h,d){var c=t&s,p=e.length,u=n.length;if(p!=u&&!(c&&u>p))return!1;var f=d.get(e);if(f&&d.get(n))return f==n;var m=-1,g=!0,x=t&l?new r:void 0;for(d.set(e,n),d.set(n,e);++m<p;){var b=e[m],y=n[m];if(i)var v=c?i(y,b,m,n,e,d):i(b,y,m,e,n,d);if(void 0!==v){if(v)continue;g=!1;break}if(x){if(!a(n,function(e,n){if(!o(x,n)&&(b===e||h(b,e,t,i,d)))return x.push(n)})){g=!1;break}}else if(b!==y&&!h(b,y,t,i,d)){g=!1;break}}return d["delete"](e),d["delete"](n),g}var r=t(137),a=t(47),o=t(140),s=1,l=2;e.exports=i},function(e,n,t){function i(e){return e===e&&!r(e)}var r=t(2);e.exports=i},function(e,n){function t(e,n){return function(t){return null!=t&&(t[e]===n&&(void 0!==n||e in Object(t)))}}e.exports=t},function(e,n,t){function i(e,n){n=r(n,e);for(var t=0,i=n.length;null!=e&&t<i;)e=e[a(n[t++])];return t&&t==i?e:void 0}var r=t(53),a=t(20);e.exports=i},function(e,n,t){function i(e,n){return r(e)?e:a(e,n)?[e]:o(s(e))}var r=t(0),a=t(31),o=t(154),s=t(156);e.exports=i},function(e,n,t){function i(e,n){if("function"!=typeof e||null!=n&&"function"!=typeof n)throw new TypeError(a);var t=function(){var i=arguments,r=n?n.apply(this,i):i[0],a=t.cache;if(a.has(r))return a.get(r);var o=e.apply(this,i);return t.cache=a.set(r,o)||a,o};return t.cache=new(i.Cache||r),t}var r=t(24),a="Expected a function";i.Cache=r,e.exports=i},function(e,n,t){function i(e,n,t){n=r(n,e);for(var i=-1,d=n.length,c=!1;++i<d;){var p=h(n[i]);if(!(c=null!=e&&t(e,p)))break;e=e[p]}return c||++i!=d?c:(d=null==e?0:e.length,!!d&&l(d)&&s(p,d)&&(o(e)||a(e)))}var r=t(53),a=t(15),o=t(0),s=t(28),l=t(27),h=t(20);e.exports=i},function(e,n,t){var i=t(164),r=t(165),a=r(i);e.exports=a},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=function(e){var n=function(n){var t=e.defaultOptions.global;if(!t.useUTC||t.getTimezoneOffset){var i=n.normalizeTimeTickInterval(n.tickInterval,n.options.units);if(!("hour"!==i.unitName||i.count>=12)&&e.getTZOffset(n.min)!==e.getTZOffset(n.max)){for(var r=[],a=n.tickPositions[0];a<=n.max;)r.push(a),a+=i.unitRange*i.count;n.tickPositions=r}}},t=function(n){return parseInt(e.dateFormat("%L",n),10)},i=function(n){return parseInt(e.dateFormat("%S",n),10)},r=function(n){return parseInt(e.dateFormat("%M",n),10)},o=function(n){return parseInt(e.dateFormat("%k",n),10)},s=function(n){return parseInt(e.dateFormat("%e",n),10)-1},l=function(n){return parseInt(e.dateFormat("%m",n),10)-1},d=function(n){return parseInt(e.dateFormat("%Y",n),10)},c=function(e){return new Date(d(e),l(e),s(e)+1,o(e),r(e),i(e),t(e))},p=(0,m["default"])(function(e){var n=[],a=[],h=[],d=[],c=[],p=[];return e.forEach(function(e){n.push(t(e)),a.push(i(e)),h.push(r(e)),d.push(o(e)),c.push(s(e)),p.push(l(e))}),(0,x["default"])(n,function(e){return 0===e})?(0,x["default"])(a,function(e){return 0===e})?(0,x["default"])(h,function(e){return 0===e})?(0,x["default"])(d,function(e){return 0===e})?(0,x["default"])(c,function(e){return 0===e})?(0,x["default"])(p,function(e){return 0===e})?"year":"month":"day":"hour":"minute":"second":"millisecond"}),u=null,f=function(n,t){return u?u(c(n),n,t):e.dateFormat(A[t],n)},g=function(e,n,t){var i=(0,h["default"])(["millisecond","second","minute","hour","day"],t),r=(0,h["default"])(["millisecond","second","minute","hour"],t),a=(0,h["default"])(["millisecond","second"],t),o="millisecond"===t,c=a?"LTS":"LT",p=o?"LTMS":c,u=i?"ddd MMM D":"MMMM";if("year"===t)return[f(e,"YYYY")];if(n&&d(n)===d(e)&&l(n)===l(e)&&s(n)===s(e))return[f(e,p)];var m=r?[f(e,p),f(e,u)]:[f(e,u)];return n&&d(n)===d(e)||m.push(f(e,"YYYY")),m},b={tickLength:6,minPadding:0,maxPadding:0,minRange:1,labels:{formatter:function(){var e=this.axis.tickPositions,n=p(e),t=null;if(!this.isFirst){var i=(0,y["default"])(e,this.value);t=e[i-1]}var r=g(this.value,t,n);return r.join(" <br /> ")},style:{whiteSpace:"nowrap",textOverflow:"none"}},units:[["millisecond",[1,2,5,10,20,25,50,100,200,500]],["second",[1,2,5,10,15,30]],["minute",[1,2,3,5,10,15,30]],["hour",[1,2,4,6,8,12]],["day",[1]],["week",[1,2]],["month",[1,2,3,4,6]],["year",[1,2,4]]],"splunk-tooltip":{formatter:function(e){return t(e)>0?f(e,"llms"):i(e)>0?f(e,"lls"):r(e)>0||o(e)>0?f(e,"lll"):f(e,"ll")}}},v={labels:{align:"left",y:18}},k={labels:{y:5}},T=function(e){switch(e){case-45:return{align:"right",y:15};case 45:return{y:15};case-90:return{align:"right",y:12};case 90:return{y:12};case 0:default:return{}}};e.wrap(e.Axis.prototype,"setOptions",function(e,n){var t=n;return"datetime"===n.type&&(t=(0,a["default"])({},b,this.horiz?v:k,{labels:T(n.labels&&n.labels.rotation||0)},t)),e.call(this,t)}),e.wrap(e.Axis.prototype,"setTickPositions",function(e){if("datetime"!==this.options.type)return void e.call(this);this.options._initialUnits||(this.options._initialUnits=this.options.units,this.options._initialTickPixelInterval=this.options.tickPixelInterval),this.horiz&&this.len<=350||!this.horiz&&this.len<=245?(this.options.units=P,this.options.tickPixelInterval=50):(this.options.units=this.options._initialUnits,this.options.tickPixelInterval=this.options._initialTickPixelInterval);var t=(this.tickPositions||[]).slice();e.call(this),n(this),(0,w["default"])(t,this.tickPositions)||(this.isDirty=!0)}),e.wrap(e.Axis.prototype,"render",function(e){"datetime"===this.options.type&&(C(this),_(this)),e.call(this)}),e.setOptions({global:{useUTC:!1}});var M=function(n){e.setOptions({global:{useUTC:!0,getTimezoneOffset:n}})},L=function(e){var n=(0,O["default"])(e);M(function(e){var t=(0,S["default"])(n.untils,e);return n.offsets[t]})},H=function(e){u=e},I=function(e){H(function(n,t,i){switch(i){case"LT":return e.format_time(n,"short");case"LTS":return e.format_time(n,"medium");case"LTMS":return e.format_time_microseconds(n,"medium");case"ddd MMM D":return e.format_date(n,"ccc MMM d");case"lll":return e.format_datetime(n,"medium","short");case"ll":return e.format_date(n,"MMM d, YYYY");case"lls":return e.format_datetime(n,"medium");case"llms":return e.format_datetime_microseconds(n,"medium");default:return e.format_date(n,i)}})},D={"ddd MMM D":{de:"ddd, D. MMM","en-gb":"ddd, D MMM",en:"ddd, MMM D",fr:"ddd D MMM",it:"ddd, D MMM",ja:"MMMD dddd",ko:"MMM D dddd","zh-cn":"MMMDdddd","zh-tw":"MMMDdddd"},YYYY:{ja:"YYYY",ko:"YYYY","zh-cn":"YYYY","zh-tw":"YYYY"}},E=function(e,n){return e?n().locale(e).locale():null},R=function(e,n){H(function(t,i,r){var a=E(n,e)||e.newSplunkTime().locale(),o=r;return D[o]&&D[o][a]&&(o=D[o][a]),e.newSplunkTime({time:i,locale:a}).splunkFormat(o)}),M(function(n){return-e.newSplunkTime({time:n}).utcOffset()})};return{setTimezone:L,useSplunkI18nLibrary:I,useSplunkMoment:R}};var r=t(58),a=i(r),o=t(118),s=i(o),l=t(124),h=i(l),d=t(133),c=i(d),p=t(166),u=i(p),f=t(54),m=i(f),g=t(168),x=i(g),b=t(171),y=i(b),v=t(172),w=i(v),k=t(173),S=i(k),T=t(176),O=i(T),M=t(177),P=[["millisecond",[1,250,500]],["second",[1,15,30]],["minute",[1,15,30]],["hour",[1]],["day",[1]],["month",[1,6]],["year",[1,4]]],A={LT:"%l:%M %p",LTS:"%l:%M:%S %p",LTMS:"%l:%M:%S.%L %p","ddd MMM D":"%a %b %e",MMMM:"%B",YYYY:"%Y",ll:"%b %e, %Y",lll:"%b %e, %Y %l:%M %p",lls:"%b %e, %Y %l:%M:%S %p",llms:"%b %e, %Y %l:%M:%S.%L %p"},L=function(e){return e.tickPositions.length<2?e.len:Math.abs(e.translate(e.tickPositions[1])-e.translate(e.tickPositions[0]))},_=function(e){if(!(e.tickPositions.length<2||(0,s["default"])(e.ticks)))for(var n=1,t=L(e)-2*n,i=(e.options.labels||{}).rotation||0,r=Math.sin((0,M.degreeToRadian)(45+Math.abs(45-Math.abs(i%90)))),a=t/r,o=function(n){return!(!n.label||!(0,h["default"])(n.axis.tickPositions,n.pos))&&(e.horiz?n.label.getBBox().width>a:n.label.getBBox().height>a)};e.tickPositions.length>2&&(0,c["default"])(e.ticks,o);)e.tickPositions=e.tickPositions.filter(function(e,n){return n%2===0}),e.tickPositions.forEach(function(n){e.ticks[n].addLabel()}),a*=2},C=function(e){var n=e.options.labels;if((0,u["default"])(n,"_userX")||(n._userX=n.x),(0,u["default"])(n,"_userY")||(n._userY=n.y),"between"===e.options.tickmarkPlacement){var t=e.pointRange,i=Math.abs(e.translate(t)-e.translate(0));e.tickmarkOffset=-t/2,e.horiz?n.x=n._userX-i/2:n.y=n._userY-i/2}};e.exports=n["default"]},function(e,n,t){var i=t(59),r=t(110),a=r(function(e,n,t){i(e,n,t)});e.exports=a},function(e,n,t){function i(e,n,t,d,c){e!==n&&o(n,function(o,h){if(l(o))c||(c=new r),s(e,n,h,t,i,d,c);else{var p=d?d(e[h],o,h+"",e,n,c):void 0;void 0===p&&(p=o),a(e,h,p)}},h)}var r=t(21),a=t(34),o=t(36),s=t(90),l=t(2),h=t(40);e.exports=i},function(e,n){function t(){this.__data__=[],this.size=0}e.exports=t},function(e,n,t){function i(e){var n=this.__data__,t=r(n,e);if(t<0)return!1;var i=n.length-1;return t==i?n.pop():o.call(n,t,1),--this.size,!0}var r=t(10),a=Array.prototype,o=a.splice;e.exports=i},function(e,n,t){function i(e){var n=this.__data__,t=r(n,e);return t<0?void 0:n[t][1]}var r=t(10);e.exports=i},function(e,n,t){function i(e){return r(this.__data__,e)>-1}var r=t(10);e.exports=i},function(e,n,t){function i(e,n){var t=this.__data__,i=r(t,e);return i<0?(++this.size,t.push([e,n])):t[i][1]=n,this}var r=t(10);e.exports=i},function(e,n,t){function i(){this.__data__=new r,this.size=0}var r=t(9);e.exports=i},function(e,n){function t(e){var n=this.__data__,t=n["delete"](e);return this.size=n.size,t}e.exports=t},function(e,n){function t(e){return this.__data__.get(e)}e.exports=t},function(e,n){function t(e){return this.__data__.has(e)}e.exports=t},function(e,n,t){function i(e,n){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!a||i.length<s-1)return i.push([e,n]),this.size=++t.size,this;t=this.__data__=new o(i)}return t.set(e,n),this.size=t.size,this}var r=t(9),a=t(22),o=t(24),s=200;e.exports=i},function(e,n,t){function i(e){if(!o(e)||a(e))return!1;var n=r(e)?f:h;return n.test(s(e))}var r=t(23),a=t(74),o=t(2),s=t(33),l=/[\\^$.*+?()[\]{}|]/g,h=/^\[object .+?Constructor\]$/,d=Function.prototype,c=Object.prototype,p=d.toString,u=c.hasOwnProperty,f=RegExp("^"+p.call(u).replace(l,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");e.exports=i},function(e,n){var t;t=function(){return this}();try{t=t||Function("return this")()||(0,eval)("this")}catch(i){"object"==typeof window&&(t=window)}e.exports=t},function(e,n,t){function i(e){var n=o.call(e,l),t=e[l];try{e[l]=void 0;var i=!0}catch(r){}var a=s.call(e);return i&&(n?e[l]=t:delete e[l]),a}var r=t(11),a=Object.prototype,o=a.hasOwnProperty,s=a.toString,l=r?r.toStringTag:void 0;e.exports=i},function(e,n){function t(e){return r.call(e)}var i=Object.prototype,r=i.toString;e.exports=t},function(e,n,t){function i(e){return!!a&&a in e}var r=t(75),a=function(){var e=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}();e.exports=i},function(e,n,t){var i=t(1),r=i["__core-js_shared__"];e.exports=r},function(e,n){function t(e,n){return null==e?void 0:e[n]}e.exports=t},function(e,n,t){function i(){this.size=0,this.__data__={hash:new r,map:new(o||a),string:new r}}var r=t(78),a=t(9),o=t(22);e.exports=i},function(e,n,t){function i(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var i=e[n];this.set(i[0],i[1])}}var r=t(79),a=t(80),o=t(81),s=t(82),l=t(83);i.prototype.clear=r,i.prototype["delete"]=a,i.prototype.get=o,i.prototype.has=s,i.prototype.set=l,e.exports=i},function(e,n,t){function i(){this.__data__=r?r(null):{},this.size=0}var r=t(12);e.exports=i},function(e,n){function t(e){var n=this.has(e)&&delete this.__data__[e];return this.size-=n?1:0,n}e.exports=t},function(e,n,t){function i(e){var n=this.__data__;if(r){var t=n[e];return t===a?void 0:t}return s.call(n,e)?n[e]:void 0}var r=t(12),a="__lodash_hash_undefined__",o=Object.prototype,s=o.hasOwnProperty;e.exports=i},function(e,n,t){function i(e){var n=this.__data__;return r?void 0!==n[e]:o.call(n,e)}var r=t(12),a=Object.prototype,o=a.hasOwnProperty;e.exports=i},function(e,n,t){function i(e,n){var t=this.__data__;return this.size+=this.has(e)?0:1,t[e]=r&&void 0===n?a:n,this}var r=t(12),a="__lodash_hash_undefined__";e.exports=i},function(e,n,t){function i(e){var n=r(this,e)["delete"](e);return this.size-=n?1:0,n}var r=t(13);e.exports=i},function(e,n){function t(e){var n=typeof e;return"string"==n||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==e:null===e}e.exports=t},function(e,n,t){function i(e){return r(this,e).get(e)}var r=t(13);e.exports=i},function(e,n,t){function i(e){return r(this,e).has(e)}var r=t(13);e.exports=i},function(e,n,t){function i(e,n){var t=r(this,e),i=t.size;return t.set(e,n),this.size+=t.size==i?0:1,this}var r=t(13);e.exports=i},function(e,n){function t(e){return function(n,t,i){for(var r=-1,a=Object(n),o=i(n),s=o.length;s--;){var l=o[e?s:++r];if(t(a[l],l,a)===!1)break}return n}}e.exports=t},function(e,n,t){function i(e,n,t,i,b,y,v){var w=e[t],k=n[t],S=v.get(k);if(S)return void r(e,t,S);var T=y?y(w,k,t+"",e,n,v):void 0,O=void 0===T;if(O){var M=d(k),P=!M&&p(k),A=!M&&!P&&g(k);T=k,M||P||A?d(w)?T=w:c(w)?T=s(w):P?(O=!1,T=a(k,!0)):A?(O=!1,T=o(k,!0)):T=[]:m(k)||h(k)?(T=w,h(w)?T=x(w):(!f(w)||i&&u(w))&&(T=l(k))):O=!1}O&&(v.set(k,T),b(T,k,i,y,v),v["delete"](k)),r(e,t,T)}var r=t(34),a=t(91),o=t(92),s=t(94),l=t(95),h=t(15),d=t(0),c=t(98),p=t(16),u=t(23),f=t(2),m=t(100),g=t(17),x=t(104);e.exports=i},function(e,n,t){(function(e){function i(e,n){if(n)return e.slice();var t=e.length,i=h?h(t):new e.constructor(t);return e.copy(i),i}var r=t(1),a="object"==typeof n&&n&&!n.nodeType&&n,o=a&&"object"==typeof e&&e&&!e.nodeType&&e,s=o&&o.exports===a,l=s?r.Buffer:void 0,h=l?l.allocUnsafe:void 0;e.exports=i}).call(n,t(26)(e))},function(e,n,t){function i(e,n){var t=n?r(e.buffer):e.buffer;return new e.constructor(t,e.byteOffset,e.length)}var r=t(93);e.exports=i},function(e,n,t){function i(e){var n=new e.constructor(e.byteLength);return new r(n).set(new r(e)),n}var r=t(37);e.exports=i},function(e,n){function t(e,n){var t=-1,i=e.length;for(n||(n=Array(i));++t<i;)n[t]=e[t];return n}e.exports=t},function(e,n,t){function i(e){return"function"!=typeof e.constructor||o(e)?{}:r(a(e))}var r=t(96),a=t(38),o=t(14);e.exports=i},function(e,n,t){var i=t(2),r=Object.create,a=function(){function e(){}return function(n){if(!i(n))return{};if(r)return r(n);e.prototype=n;var t=new e;return e.prototype=void 0,t}}();e.exports=a},function(e,n,t){function i(e){return a(e)&&r(e)==o}var r=t(5),a=t(3),o="[object Arguments]";e.exports=i},function(e,n,t){function i(e){return a(e)&&r(e)}var r=t(6),a=t(3);e.exports=i},function(e,n){function t(){return!1}e.exports=t},function(e,n,t){function i(e){if(!o(e)||r(e)!=s)return!1;var n=a(e);if(null===n)return!0;var t=c.call(n,"constructor")&&n.constructor;return"function"==typeof t&&t instanceof t&&d.call(t)==p}var r=t(5),a=t(38),o=t(3),s="[object Object]",l=Function.prototype,h=Object.prototype,d=l.toString,c=h.hasOwnProperty,p=d.call(Object);e.exports=i},function(e,n,t){function i(e){return o(e)&&a(e.length)&&!!C[r(e)]}var r=t(5),a=t(27),o=t(3),s="[object Arguments]",l="[object Array]",h="[object Boolean]",d="[object Date]",c="[object Error]",p="[object Function]",u="[object Map]",f="[object Number]",m="[object Object]",g="[object RegExp]",x="[object Set]",b="[object String]",y="[object WeakMap]",v="[object ArrayBuffer]",w="[object DataView]",k="[object Float32Array]",S="[object Float64Array]",T="[object Int8Array]",O="[object Int16Array]",M="[object Int32Array]",P="[object Uint8Array]",A="[object Uint8ClampedArray]",L="[object Uint16Array]",_="[object Uint32Array]",C={};C[k]=C[S]=C[T]=C[O]=C[M]=C[P]=C[A]=C[L]=C[_]=!0,C[s]=C[l]=C[v]=C[h]=C[w]=C[d]=C[c]=C[p]=C[u]=C[f]=C[m]=C[g]=C[x]=C[b]=C[y]=!1,e.exports=i},function(e,n){function t(e){return function(n){return e(n)}}e.exports=t},function(e,n,t){(function(e){var i=t(32),r="object"==typeof n&&n&&!n.nodeType&&n,a=r&&"object"==typeof e&&e&&!e.nodeType&&e,o=a&&a.exports===r,s=o&&i.process,l=function(){try{return s&&s.binding&&s.binding("util")}catch(e){}}();e.exports=l}).call(n,t(26)(e))},function(e,n,t){function i(e){return r(e,a(e))}var r=t(105),a=t(40);e.exports=i},function(e,n,t){function i(e,n,t,i){var o=!t;t||(t={});for(var s=-1,l=n.length;++s<l;){var h=n[s],d=i?i(t[h],e[h],h,t,e):void 0;void 0===d&&(d=e[h]),o?a(t,h,d):r(t,h,d)}return t}var r=t(106),a=t(25);e.exports=i},function(e,n,t){function i(e,n,t){var i=e[n];s.call(e,n)&&a(i,t)&&(void 0!==t||n in e)||r(e,n,t)}var r=t(25),a=t(8),o=Object.prototype,s=o.hasOwnProperty;e.exports=i},function(e,n){function t(e,n){for(var t=-1,i=Array(e);++t<e;)i[t]=n(t);return i}e.exports=t},function(e,n,t){function i(e){if(!r(e))return o(e);var n=a(e),t=[];for(var i in e)("constructor"!=i||!n&&l.call(e,i))&&t.push(i);return t}var r=t(2),a=t(14),o=t(109),s=Object.prototype,l=s.hasOwnProperty;e.exports=i},function(e,n){function t(e){var n=[];if(null!=e)for(var t in Object(e))n.push(t);return n}e.exports=t},function(e,n,t){function i(e){return r(function(n,t){var i=-1,r=t.length,o=r>1?t[r-1]:void 0,s=r>2?t[2]:void 0;for(o=e.length>3&&"function"==typeof o?(r--,o):void 0,s&&a(t[0],t[1],s)&&(o=r<3?void 0:o,r=1),n=Object(n);++i<r;){var l=t[i];l&&e(n,l,i,o)}return n})}var r=t(111),a=t(29);e.exports=i},function(e,n,t){function i(e,n){return o(a(e,n,r),e+"")}var r=t(18),a=t(112),o=t(114);e.exports=i},function(e,n,t){function i(e,n,t){return n=a(void 0===n?e.length-1:n,0),function(){for(var i=arguments,o=-1,s=a(i.length-n,0),l=Array(s);++o<s;)l[o]=i[n+o];o=-1;for(var h=Array(n+1);++o<n;)h[o]=i[o];return h[n]=t(l),r(e,this,h)}}var r=t(113),a=Math.max;e.exports=i},function(e,n){function t(e,n,t){switch(t.length){case 0:return e.call(n);case 1:return e.call(n,t[0]);case 2:return e.call(n,t[0],t[1]);case 3:return e.call(n,t[0],t[1],t[2])}return e.apply(n,t)}e.exports=t},function(e,n,t){var i=t(115),r=t(117),a=r(i);e.exports=a},function(e,n,t){var i=t(116),r=t(35),a=t(18),o=r?function(e,n){return r(e,"toString",{configurable:!0,enumerable:!1,value:i(n),writable:!0})}:a;e.exports=o},function(e,n){function t(e){return function(){return e}}e.exports=t},function(e,n){function t(e){var n=0,t=0;return function(){var o=a(),s=r-(o-t);if(t=o,s>0){if(++n>=i)return arguments[0]}else n=0;return e.apply(void 0,arguments)}}var i=800,r=16,a=Date.now;e.exports=t},function(e,n,t){function i(e){if(null==e)return!0;if(l(e)&&(s(e)||"string"==typeof e||"function"==typeof e.splice||h(e)||c(e)||o(e)))return!e.length;var n=a(e);if(n==p||n==u)return!e.size;if(d(e))return!r(e).length;for(var t in e)if(m.call(e,t))return!1;return!0}var r=t(42),a=t(43),o=t(15),s=t(0),l=t(6),h=t(16),d=t(14),c=t(17),p="[object Map]",u="[object Set]",f=Object.prototype,m=f.hasOwnProperty;e.exports=i},function(e,n,t){var i=t(39),r=i(Object.keys,Object);e.exports=r},function(e,n,t){var i=t(4),r=t(1),a=i(r,"DataView");e.exports=a},function(e,n,t){var i=t(4),r=t(1),a=i(r,"Promise");e.exports=a},function(e,n,t){var i=t(4),r=t(1),a=i(r,"Set");e.exports=a},function(e,n,t){var i=t(4),r=t(1),a=i(r,"WeakMap");e.exports=a},function(e,n,t){function i(e,n,t,i){e=a(e)?e:l(e),t=t&&!i?s(t):0;var d=e.length;return t<0&&(t=h(d+t,0)),o(e)?t<=d&&e.indexOf(n,t)>-1:!!d&&r(e,n,t)>-1}var r=t(44),a=t(6),o=t(128),s=t(45),l=t(131),h=Math.max;e.exports=i},function(e,n){function t(e,n,t,i){for(var r=e.length,a=t+(i?1:-1);i?a--:++a<r;)if(n(e[a],a,e))return a;return-1}e.exports=t},function(e,n){function t(e){return e!==e}e.exports=t},function(e,n){function t(e,n,t){for(var i=t-1,r=e.length;++i<r;)if(e[i]===n)return i;return-1}e.exports=t},function(e,n,t){function i(e){return"string"==typeof e||!a(e)&&o(e)&&r(e)==s}var r=t(5),a=t(0),o=t(3),s="[object String]";e.exports=i},function(e,n,t){function i(e){if(!e)return 0===e?e:0;if(e=r(e),e===a||e===-a){var n=e<0?-1:1;return n*o}return e===e?e:0}var r=t(130),a=1/0,o=1.7976931348623157e308;e.exports=i},function(e,n,t){function i(e){if("number"==typeof e)return e;if(a(e))return o;if(r(e)){var n="function"==typeof e.valueOf?e.valueOf():e;e=r(n)?n+"":n}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(s,"");var t=h.test(e);return t||d.test(e)?c(e.slice(2),t?2:8):l.test(e)?o:+e}var r=t(2),a=t(7),o=NaN,s=/^\s+|\s+$/g,l=/^[-+]0x[0-9a-f]+$/i,h=/^0b[01]+$/i,d=/^0o[0-7]+$/i,c=parseInt;e.exports=i},function(e,n,t){function i(e){return null==e?[]:r(e,a(e))}var r=t(132),a=t(19);e.exports=i},function(e,n,t){function i(e,n){return r(n,function(n){return e[n]})}var r=t(46);e.exports=i},function(e,n,t){function i(e,n,t){var i=s(e)?r:o;return t&&l(e,n,t)&&(n=void 0),i(e,a(n,3))}var r=t(47),a=t(48),o=t(163),s=t(0),l=t(29);e.exports=i},function(e,n,t){function i(e){var n=a(e);return 1==n.length&&n[0][2]?o(n[0][0],n[0][1]):function(t){return t===e||r(t,e,n)}}var r=t(135),a=t(151),o=t(51);e.exports=i},function(e,n,t){function i(e,n,t,i){var l=t.length,h=l,d=!i;if(null==e)return!h;for(e=Object(e);l--;){var c=t[l];if(d&&c[2]?c[1]!==e[c[0]]:!(c[0]in e))return!1}for(;++l<h;){c=t[l];var p=c[0],u=e[p],f=c[1];if(d&&c[2]){if(void 0===u&&!(p in e))return!1}else{var m=new r;if(i)var g=i(u,f,p,e,n,m);if(!(void 0===g?a(f,u,o|s,i,m):g))return!1}}return!0}var r=t(21),a=t(30),o=1,s=2;e.exports=i},function(e,n,t){function i(e,n,t,i,g,b){var y=h(e),v=h(n),w=y?f:l(e),k=v?f:l(n);w=w==u?m:w,k=k==u?m:k;var S=w==m,T=k==m,O=w==k;if(O&&d(e)){if(!d(n))return!1;y=!0,S=!1}if(O&&!S)return b||(b=new r),y||c(e)?a(e,n,t,i,g,b):o(e,n,w,t,i,g,b);if(!(t&p)){var M=S&&x.call(e,"__wrapped__"),P=T&&x.call(n,"__wrapped__");if(M||P){var A=M?e.value():e,L=P?n.value():n;return b||(b=new r),g(A,L,t,i,b)}}return!!O&&(b||(b=new r),s(e,n,t,i,g,b))}var r=t(21),a=t(49),o=t(141),s=t(144),l=t(43),h=t(0),d=t(16),c=t(17),p=1,u="[object Arguments]",f="[object Array]",m="[object Object]",g=Object.prototype,x=g.hasOwnProperty;e.exports=i},function(e,n,t){function i(e){var n=-1,t=null==e?0:e.length;for(this.__data__=new r;++n<t;)this.add(e[n])}var r=t(24),a=t(138),o=t(139);i.prototype.add=i.prototype.push=a,i.prototype.has=o,e.exports=i},function(e,n){function t(e){return this.__data__.set(e,i),this}var i="__lodash_hash_undefined__";e.exports=t},function(e,n){function t(e){return this.__data__.has(e)}e.exports=t},function(e,n){function t(e,n){return e.has(n)}e.exports=t},function(e,n,t){function i(e,n,t,i,r,S,O){switch(t){case k:if(e.byteLength!=n.byteLength||e.byteOffset!=n.byteOffset)return!1;e=e.buffer,n=n.buffer;case w:return!(e.byteLength!=n.byteLength||!S(new a(e),new a(n)));case p:case u:case g:return o(+e,+n);case f:return e.name==n.name&&e.message==n.message;case x:case y:return e==n+"";case m:var M=l;case b:var P=i&d;if(M||(M=h),e.size!=n.size&&!P)return!1;var A=O.get(e);if(A)return A==n;i|=c,O.set(e,n);var L=s(M(e),M(n),i,r,S,O);return O["delete"](e),L;case v:if(T)return T.call(e)==T.call(n)}return!1}var r=t(11),a=t(37),o=t(8),s=t(49),l=t(142),h=t(143),d=1,c=2,p="[object Boolean]",u="[object Date]",f="[object Error]",m="[object Map]",g="[object Number]",x="[object RegExp]",b="[object Set]",y="[object String]",v="[object Symbol]",w="[object ArrayBuffer]",k="[object DataView]",S=r?r.prototype:void 0,T=S?S.valueOf:void 0;e.exports=i},function(e,n){function t(e){var n=-1,t=Array(e.size);return e.forEach(function(e,i){t[++n]=[i,e]}),t}e.exports=t},function(e,n){function t(e){var n=-1,t=Array(e.size);return e.forEach(function(e){t[++n]=e}),t}e.exports=t},function(e,n,t){function i(e,n,t,i,o,l){var h=t&a,d=r(e),c=d.length,p=r(n),u=p.length;if(c!=u&&!h)return!1;for(var f=c;f--;){var m=d[f];if(!(h?m in n:s.call(n,m)))return!1}var g=l.get(e);if(g&&l.get(n))return g==n;var x=!0;l.set(e,n),l.set(n,e);for(var b=h;++f<c;){m=d[f];var y=e[m],v=n[m];if(i)var w=h?i(v,y,m,n,e,l):i(y,v,m,e,n,l);if(!(void 0===w?y===v||o(y,v,t,i,l):w)){x=!1;break}b||(b="constructor"==m)}if(x&&!b){var k=e.constructor,S=n.constructor;k!=S&&"constructor"in e&&"constructor"in n&&!("function"==typeof k&&k instanceof k&&"function"==typeof S&&S instanceof S)&&(x=!1)}return l["delete"](e),l["delete"](n),x}var r=t(145),a=1,o=Object.prototype,s=o.hasOwnProperty;e.exports=i},function(e,n,t){function i(e){return r(e,o,a)}var r=t(146),a=t(148),o=t(19);e.exports=i},function(e,n,t){function i(e,n,t){var i=n(e);return a(e)?i:r(i,t(e))}var r=t(147),a=t(0);e.exports=i},function(e,n){function t(e,n){for(var t=-1,i=n.length,r=e.length;++t<i;)e[r+t]=n[t];return e}e.exports=t},function(e,n,t){var i=t(149),r=t(150),a=Object.prototype,o=a.propertyIsEnumerable,s=Object.getOwnPropertySymbols,l=s?function(e){return null==e?[]:(e=Object(e),i(s(e),function(n){return o.call(e,n)}))}:r;e.exports=l},function(e,n){function t(e,n){for(var t=-1,i=null==e?0:e.length,r=0,a=[];++t<i;){var o=e[t];n(o,t,e)&&(a[r++]=o)}return a}e.exports=t},function(e,n){function t(){return[]}e.exports=t},function(e,n,t){function i(e){for(var n=a(e),t=n.length;t--;){var i=n[t],o=e[i];n[t]=[i,o,r(o)]}return n}var r=t(50),a=t(19);e.exports=i},function(e,n,t){function i(e,n){return s(e)&&l(n)?h(d(e),n):function(t){var i=a(t,e);return void 0===i&&i===n?o(t,e):r(n,i,c|p)}}var r=t(30),a=t(153),o=t(158),s=t(31),l=t(50),h=t(51),d=t(20),c=1,p=2;e.exports=i},function(e,n,t){function i(e,n,t){var i=null==e?void 0:r(e,n);return void 0===i?t:i}var r=t(52);e.exports=i},function(e,n,t){var i=t(155),r=/^\./,a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,s=i(function(e){var n=[];return r.test(e)&&n.push(""),e.replace(a,function(e,t,i,r){n.push(i?r.replace(o,"$1"):t||e)}),n});e.exports=s},function(e,n,t){function i(e){var n=r(e,function(e){return t.size===a&&t.clear(),e}),t=n.cache;return n}var r=t(54),a=500;e.exports=i},function(e,n,t){function i(e){return null==e?"":r(e)}var r=t(157);e.exports=i},function(e,n,t){function i(e){if("string"==typeof e)return e;if(o(e))return a(e,i)+"";if(s(e))return d?d.call(e):"";var n=e+"";return"0"==n&&1/e==-l?"-0":n}var r=t(11),a=t(46),o=t(0),s=t(7),l=1/0,h=r?r.prototype:void 0,d=h?h.toString:void 0;e.exports=i},function(e,n,t){function i(e,n){return null!=e&&a(e,n,r)}var r=t(159),a=t(55);e.exports=i},function(e,n){function t(e,n){return null!=e&&n in Object(e)}e.exports=t},function(e,n,t){function i(e){return o(e)?r(s(e)):a(e)}var r=t(161),a=t(162),o=t(31),s=t(20);e.exports=i},function(e,n){function t(e){return function(n){return null==n?void 0:n[e]}}e.exports=t},function(e,n,t){function i(e){return function(n){return r(n,e)}}var r=t(52);e.exports=i},function(e,n,t){function i(e,n){var t;return r(e,function(e,i,r){return t=n(e,i,r),!t}),!!t}var r=t(56);e.exports=i},function(e,n,t){function i(e,n){return e&&r(e,n,a)}var r=t(36),a=t(19);e.exports=i},function(e,n,t){function i(e,n){return function(t,i){if(null==t)return t;if(!r(t))return e(t,i);for(var a=t.length,o=n?a:-1,s=Object(t);(n?o--:++o<a)&&i(s[o],o,s)!==!1;);return t}}var r=t(6);e.exports=i},function(e,n,t){function i(e,n){return null!=e&&a(e,n,r)}var r=t(167),a=t(55);e.exports=i},function(e,n){function t(e,n){return null!=e&&r.call(e,n)}var i=Object.prototype,r=i.hasOwnProperty;e.exports=t},function(e,n,t){function i(e,n,t){var i=s(e)?r:a;return t&&l(e,n,t)&&(n=void 0),i(e,o(n,3))}var r=t(169),a=t(170),o=t(48),s=t(0),l=t(29);e.exports=i},function(e,n){function t(e,n){for(var t=-1,i=null==e?0:e.length;++t<i;)if(!n(e[t],t,e))return!1;return!0}e.exports=t},function(e,n,t){function i(e,n){var t=!0;return r(e,function(e,i,r){return t=!!n(e,i,r)}),t}var r=t(56);e.exports=i},function(e,n,t){function i(e,n,t){var i=null==e?0:e.length;if(!i)return-1;var s=null==t?0:a(t);return s<0&&(s=o(i+s,0)),r(e,n,s)}var r=t(44),a=t(45),o=Math.max;e.exports=i},function(e,n,t){function i(e,n){return r(e,n)}var r=t(30);e.exports=i},function(e,n,t){function i(e,n){return r(e,n,!0)}var r=t(174);e.exports=i},function(e,n,t){function i(e,n,t){var i=0,s=null==e?i:e.length;
if("number"==typeof n&&n===n&&s<=l){for(;i<s;){var h=i+s>>>1,d=e[h];null!==d&&!o(d)&&(t?d<=n:d<n)?i=h+1:s=h}return s}return r(e,n,a,t)}var r=t(175),a=t(18),o=t(7),s=4294967295,l=s>>>1;e.exports=i},function(e,n,t){function i(e,n,t,i){n=t(n);for(var a=0,h=null==e?0:e.length,d=n!==n,c=null===n,p=r(n),u=void 0===n;a<h;){var f=s((a+h)/2),m=t(e[f]),g=void 0!==m,x=null===m,b=m===m,y=r(m);if(d)var v=i||b;else v=u?b&&(i||g):c?b&&g&&(i||!x):p?b&&g&&!x&&(i||!y):!x&&!y&&(i?m<=n:m<n);v?a=f+1:h=f}return l(h,o)}var r=t(7),a=4294967295,o=a-1,s=Math.floor,l=Math.min;e.exports=i},function(e,n){e.exports=t(590)},function(e,n){e.exports=t(575)}])},590:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=2)}([,function(e,n){e.exports=t(349)},function(e,n,t){"use strict";function i(e,n){var t=e.split(" ");if(t.length<5)return n;var i=parseInt(t[0],10);if(!(0,s.isFinite)(i))return n;var r=t.splice(2).reduce(function(e,n){var t=String.fromCharCode(parseInt(n,16));return""+e+t},"");return o({},n,{abbrs:n.abbrs.concat([r]),offsets:n.offsets.concat([-i/60])})}function r(e,n){var t=e.split(" ");if(t.length<2)return n;var i=parseInt(t[0],10);if(!(0,s.isFinite)(i))return n;var r=parseInt(t[1],10);return!(0,s.isFinite)(r)||r<0||r>=n.offsets.length?n:o({},n,{starts:n.starts.concat([{time:1e3*i,abbr:n.abbrs[r],offset:n.offsets[r]}])})}function a(e,n){var t={abbrs:[],offsets:[],starts:[]};e.split(";").forEach(function(e){switch(e.charAt(0)){case"C":break;case"Y":t=i(e.substring(1,e.length),t);break;default:t=r(e.substring(1,e.length),t)}});var a={name:n,abbrs:[],offsets:[],untils:[]},o=t.starts[0],s=t.starts[t.starts.length-1];return t.starts.forEach(function(e,n){e===o?(a.abbrs.push(s.abbr),a.offsets.push(s.offset),a.untils.push(e.time)):(a.abbrs.push(t.starts[n-1].abbr),a.offsets.push(t.starts[n-1].offset),a.untils.push(e.time)),e===s&&(a.abbrs.push(e.abbr),a.offsets.push(e.offset),a.untils.push(null))}),a}Object.defineProperty(n,"__esModule",{value:!0});var o=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i])}return e},s=t(1);n["default"]=a}])},591:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=7)}([function(e,n,t){e.exports=!t(6)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(e,n){e.exports=function(e){return"object"==typeof e?null!==e:"function"==typeof e}},function(e,n,t){var i=t(27),r=i.Symbol;e.exports=r},function(e,n){var t=e.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=t)},function(e,n){var t=e.exports={version:"2.5.1"};"number"==typeof __e&&(__e=t)},function(e,n,t){var i=t(17),r=t(18),a=t(20),o=Object.defineProperty;n.f=t(0)?Object.defineProperty:function(e,n,t){if(i(e),n=a(n,!0),i(t),r)try{return o(e,n,t)}catch(s){}if("get"in t||"set"in t)throw TypeError("Accessors not supported!");return"value"in t&&(e[n]=t.value),e}},function(e,n){e.exports=function(e){try{return!!e()}catch(n){return!0}}},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0});var r=t(8),a=i(r),o=t(9),s=i(o),l=t(22),h=i(l),d=t(37),c=t(38),p=i(c),u="#000000",f=1,m="-no-category",g=0,x=500,b=function(){function e(n){var t=n.axis,i=n.value,r=n.label,o=n.color,s=n.category,l=n.renderer,h=n.originalIndex,c=n.onMouseOver,p=n.onMouseOut;(0,a["default"])(this,e),this.axis=t,this.value=i,this.label=r,this.color=(0,d.normalizeColor)(o)||u,this.originalIndex=h,this.category=s||m,this.renderer=l,this.onMouseOver=c,this.onMouseOut=p,this.rendered=!1}return(0,s["default"])(e,[{key:"render",value:function(){var e=this,n=this.axis.toPixels(this.value),t=this.axis.top+this.axis.height,i=this.axis.top;this.group=this.renderer.g("splunk-annotation"),this.stroke=this.renderer.path(["M",n,i,"V",t+1]).attr({stroke:this.color,"stroke-width":f,"stroke-dasharray":"3, 3",zIndex:3,"data-role":"annotation-line"}).add(this.group);var r=-8,a=5,o=10;return this.triangle=this.renderer.path(["M",n-a,i+r,"H",n+a,"L",n,i,"Z"]).attr({fill:this.color,zIndex:3,"data-role":"marker-triangle"}).add(this.group),this.triangleShadow=this.renderer.path(["M",n-o,i+r,"H",n+o,"L",n,i+(o-a),"Z"]).attr({fill:this.color,opacity:g,zIndex:4,"data-role":"hover-triangle"}).add(this.group),this.onMouseOver&&this.triangleShadow.on("mouseover",function(){return e.hover()}).on("mouseout",function(){return e.unhover()}),this.rendered=!0,this.group}},{key:"hover",value:function(){if(this.rendered){var e=this.axis.toPixels(this.value),n=this.axis.top;this.stroke.attr({"stroke-width":2}),this.onMouseOver({annotation:this,xPosition:e,yAxisMaxY:n})}}},{key:"unhover",value:function(){this.rendered&&this.stroke.attr({"stroke-width":f}),this.onMouseOut({annotation:this})}},{key:"dim",value:function(e){if(this.rendered){var n=e?.3:1;this.stroke.attr({opacity:n}),this.triangle.attr({opacity:n})}}},{key:"destroy",value:function(){this.triangleShadow&&this.triangleShadow.destroy(),this.triangleShadow=null,this.triangle&&this.triangle.destroy(),this.triangle=null,this.stroke&&this.stroke.destroy(),this.stroke=null,this.group&&this.group.destroy(),this.group=null,this.rendered=!1}}]),e}(),y=function(){function e(n){var t=n.axis,i=n.tooltipCls;(0,a["default"])(this,e),this.axis=t,this.renderer=t.chart.renderer,this.points=[],this.tooltip=new i(this.axis.chart,{enabled:!0,padding:8,useHTML:!0,backgroundColor:"#000000",hideDelay:0,style:{color:"#fff","font-size":"12px","pointer-events":"none",r:3},tooltipRole:"splunk-annotation-tooltip"}),this.labelFormatter=new p["default"](this.renderer)}return(0,s["default"])(e,[{key:"update",value:function(e){this.clear(),this.render(e)}},{key:"showTooltip",value:function(e,n){this.points.forEach(function(n){n.dim(n!==e)});var t=e.value,i=e.label,r=void 0===i?"":i,a=e.color,o=e.category,s=this.axis.top,l=this.tooltip.getLabel(),c=this.axis.options["splunk-tooltip"]||{},p=c.formatter,u=p?p(t):"",f=o===m?"":o,g=this.labelFormatter._predictLineWidth(u,11)+20,b=f?this.labelFormatter._predictLineWidth(o,11)+20:0,y=r?this.labelFormatter._predictLineWidth(r,12)+20:0,v=Math.max(g,b,y),w=n-10,k=this.axis.chart.chartWidth-n-10,S=n+v,T=this.axis.chart.plotLeft+this.axis.chart.plotWidth,O=S-T,M=v-(n-this.axis.chart.plotLeft),P=Math.min(O,M)>0?O<=M:O<0,A=Math.floor(Math.min(x,P?k:w))-16,L=(0,d.getLuminance)((0,d.hexFromColor)(a)),_=170,C=L>_?"#333":"#fff",H=L>_?"#555":"#ddd",I="max-width: "+A+"px; overflow: hidden; text-overflow: ellipsis;",D="font-size: 11px; color: "+H;l.attr({text:"\n                "+(r?'<div data-role="tooltip-label" style="margin-bottom: 2px; color: '+C+"; "+I+'">'+(0,h["default"])(r)+"</div>":"")+"\n                "+(f?'<div data-role="tooltip-category" style="margin-bottom: 2px; '+D+"; "+I+'">'+(0,h["default"])(o)+"</div>":"")+'\n                <div data-role="tooltip-timestamp" style="'+D+"; "+I+'">'+(0,h["default"])(u)+"</div>\n            "}),this.tooltip.move(P?n:n-l.width,s-8),l.attr({fill:a}),l.show(),l.toFront()}},{key:"hideTooltip",value:function(){this.points.forEach(function(e){e.dim(!1)}),this.tooltip.getLabel().hide(0)}},{key:"getVisibleDataPoints",value:function(e){var n=this,t=this.axis.width,i=this.axis.left,r=i+t,a=function(e){return function(n){return!!e[n]||(e[n]=!0,!1)}}({}),o=function(e){return e>=i&&e<=r},s=e.length-1;return e.filter(function(e,t){var i=n.axis.toPixels(e.value);return e.originalIndex=s-t,!a(i)&&o(i)})}},{key:"render",value:function(e){var n=this;if(this.axis.isXAxis){this.clear();var t=function(e){var t=e.annotation,i=e.xPosition;n.showTooltip(t,i)},i=function(){n.hideTooltip()};this.annotationLayerGroup=this.renderer.g("splunk-annotation-layer"),this.points=this.getVisibleDataPoints(e.slice().reverse()).reverse().map(function(e){var r=e.value,a=e.label,o=e.color,s=e.category,l=e.originalIndex,h=new b({axis:n.axis,renderer:n.renderer,value:r,label:a,color:o,category:s,originalIndex:l,onMouseOver:t,onMouseOut:i});return h.render().add(n.annotationLayerGroup),h}),this.annotationLayerGroup.add().toFront();var r=this.axis.chart.tooltip.label;r&&r.toFront()}}},{key:"clear",value:function(){this.hideTooltip(),this.points.forEach(function(e){return e.destroy()}),this.annotationLayerGroup&&this.annotationLayerGroup.destroy(),this.annotationLayerGroup=null}},{key:"destroy",value:function(){this.clear(),this.tooltip.destroy(),this.labelFormatter.destroy()}}]),e}(),v=function(e){e.wrap(e.Axis.prototype,"render",function(n){for(var t=arguments.length,i=Array(t>1?t-1:0),r=1;r<t;r++)i[r-1]=arguments[r];n.call.apply(n,[this].concat(i));var a=this.options;"annotations"in a&&a.annotations.length?(this.annotations||(this.annotations=new y({axis:this,tooltipCls:e.Tooltip})),this.annotations.update(a.annotations)):this.annotations&&(this.annotations.destroy(),this.annotations=null)}),e.wrap(e.Axis.prototype,"destroy",function(e){this.annotations&&(this.annotations.destroy(),this.annotations=null),e.apply(this)})};n["default"]=v,e.exports=n["default"]},function(e,n,t){"use strict";n.__esModule=!0,n["default"]=function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}},function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}n.__esModule=!0;var r=t(10),a=i(r);n["default"]=function(){function e(e,n){for(var t=0;t<n.length;t++){var i=n[t];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),(0,a["default"])(e,i.key,i)}}return function(n,t,i){return t&&e(n.prototype,t),i&&e(n,i),n}}()},function(e,n,t){e.exports={"default":t(11),__esModule:!0}},function(e,n,t){t(12);var i=t(4).Object;e.exports=function(e,n,t){return i.defineProperty(e,n,t)}},function(e,n,t){var i=t(13);i(i.S+i.F*!t(0),"Object",{defineProperty:t(5).f})},function(e,n,t){var i=t(3),r=t(4),a=t(14),o=t(16),s="prototype",l=function(e,n,t){var h,d,c,p=e&l.F,u=e&l.G,f=e&l.S,m=e&l.P,g=e&l.B,x=e&l.W,b=u?r:r[n]||(r[n]={}),y=b[s],v=u?i:f?i[n]:(i[n]||{})[s];u&&(t=n);for(h in t)d=!p&&v&&void 0!==v[h],d&&h in b||(c=d?v[h]:t[h],b[h]=u&&"function"!=typeof v[h]?t[h]:g&&d?a(c,i):x&&v[h]==c?function(e){var n=function(n,t,i){if(this instanceof e){switch(arguments.length){case 0:return new e;case 1:return new e(n);case 2:return new e(n,t)}return new e(n,t,i)}return e.apply(this,arguments)};return n[s]=e[s],n}(c):m&&"function"==typeof c?a(Function.call,c):c,m&&((b.virtual||(b.virtual={}))[h]=c,e&l.R&&y&&!y[h]&&o(y,h,c)))};l.F=1,l.G=2,l.S=4,l.P=8,l.B=16,l.W=32,l.U=64,l.R=128,e.exports=l},function(e,n,t){var i=t(15);e.exports=function(e,n,t){if(i(e),void 0===n)return e;switch(t){case 1:return function(t){return e.call(n,t)};case 2:return function(t,i){return e.call(n,t,i)};case 3:return function(t,i,r){return e.call(n,t,i,r)}}return function(){return e.apply(n,arguments)}}},function(e,n){e.exports=function(e){if("function"!=typeof e)throw TypeError(e+" is not a function!");return e}},function(e,n,t){var i=t(5),r=t(21);e.exports=t(0)?function(e,n,t){return i.f(e,n,r(1,t))}:function(e,n,t){return e[n]=t,e}},function(e,n,t){var i=t(1);e.exports=function(e){if(!i(e))throw TypeError(e+" is not an object!");return e}},function(e,n,t){e.exports=!t(0)&&!t(6)(function(){return 7!=Object.defineProperty(t(19)("div"),"a",{get:function(){return 7}}).a})},function(e,n,t){var i=t(1),r=t(3).document,a=i(r)&&i(r.createElement);e.exports=function(e){return a?r.createElement(e):{}}},function(e,n,t){var i=t(1);e.exports=function(e,n){if(!i(e))return e;var t,r;if(n&&"function"==typeof(t=e.toString)&&!i(r=t.call(e)))return r;if("function"==typeof(t=e.valueOf)&&!i(r=t.call(e)))return r;if(!n&&"function"==typeof(t=e.toString)&&!i(r=t.call(e)))return r;throw TypeError("Can't convert object to primitive value")}},function(e,n){e.exports=function(e,n){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:n}}},function(e,n,t){function i(e){return e=a(e),e&&s.test(e)?e.replace(o,r):e}var r=t(23),a=t(25),o=/[&<>"']/g,s=RegExp(o.source);e.exports=i},function(e,n,t){var i=t(24),r={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},a=i(r);e.exports=a},function(e,n){function t(e){return function(n){return null==e?void 0:e[n]}}e.exports=t},function(e,n,t){function i(e){return null==e?"":r(e)}var r=t(26);e.exports=i},function(e,n,t){function i(e){if("string"==typeof e)return e;if(o(e))return a(e,i)+"";if(s(e))return d?d.call(e):"";var n=e+"";return"0"==n&&1/e==-l?"-0":n}var r=t(2),a=t(30),o=t(31),s=t(32),l=1/0,h=r?r.prototype:void 0,d=h?h.toString:void 0;e.exports=i},function(e,n,t){var i=t(28),r="object"==typeof self&&self&&self.Object===Object&&self,a=i||r||Function("return this")();e.exports=a},function(e,n,t){(function(n){var t="object"==typeof n&&n&&n.Object===Object&&n;e.exports=t}).call(n,t(29))},function(e,n){var t;t=function(){return this}();try{t=t||Function("return this")()||(0,eval)("this")}catch(i){"object"==typeof window&&(t=window)}e.exports=t},function(e,n){function t(e,n){for(var t=-1,i=null==e?0:e.length,r=Array(i);++t<i;)r[t]=n(e[t],t,e);return r}e.exports=t},function(e,n){var t=Array.isArray;e.exports=t},function(e,n,t){function i(e){return"symbol"==typeof e||a(e)&&r(e)==o}var r=t(33),a=t(36),o="[object Symbol]";e.exports=i},function(e,n,t){function i(e){return null==e?void 0===e?l:s:h&&h in Object(e)?a(e):o(e)}var r=t(2),a=t(34),o=t(35),s="[object Null]",l="[object Undefined]",h=r?r.toStringTag:void 0;e.exports=i},function(e,n,t){function i(e){var n=o.call(e,l),t=e[l];try{e[l]=void 0;var i=!0}catch(r){}var a=s.call(e);return i&&(n?e[l]=t:delete e[l]),a}var r=t(2),a=Object.prototype,o=a.hasOwnProperty,s=a.toString,l=r?r.toStringTag:void 0;e.exports=i},function(e,n){function t(e){return r.call(e)}var i=Object.prototype,r=i.toString;e.exports=t},function(e,n){function t(e){return null!=e&&"object"==typeof e}e.exports=t},function(e,n){e.exports=t(576)},function(e,n){e.exports=t(578)}])},592:function(e,n){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=0)}([function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var i=function(e){e.wrap(e.Tooltip.prototype,"getLabel",function(e){for(var n=arguments.length,t=Array(n>1?n-1:0),i=1;i<n;i++)t[i-1]=arguments[i];var r=e.call.apply(e,[this].concat(t)),a=this.options.tooltipRole,o=void 0===a?"main-tooltip":a;return r.attr({"data-role":o}),r.div&&r.div.setAttribute("data-role",o),r})};n["default"]=i,e.exports=n["default"]}])},593:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=16)}({0:function(e,n){e.exports=t("require/underscore")},1:function(e,n){e.exports=t("shim/jquery")},16:function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0});var r=t(1),a=i(r),o=t(0),s=i(o),l={};l.CANCELLED="cancelled",l.requestFrame=(0,s["default"])(function(){return window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||function(e){window.setTimeout(e,50)}}()).bind(window),l.cancelFrame=(0,s["default"])(function(){return window.cancelAnimationFrame||window.mozCancelAnimationFrame||function(e){window.clearTimeout(e)}}()).bind(window),l.asyncEach=function(e,n){var t=void 0,i=!1,r=e.length,o=a["default"].Deferred(),s=function h(a){i||(n(e[a],a),a<r-1?t=l.requestFrame(function(){h(a+1)}):o.resolve())};return o.cancel=function(){i=!0,t&&(l.cancelFrame(t),o.reject(l.CANCELLED))},s(0),o},n["default"]=l,e.exports=n["default"]}})},594:function(e,n,t){e.exports=function(e){function n(i){if(t[i])return t[i].exports;var r=t[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:i})},n.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=19)}({0:function(e,n){e.exports=t("require/underscore")},19:function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0}),n.getSIPower=n.getSIUnit=n.abbreviateByUnit=n.abbreviateNumber=void 0;var r=t(2),a=i(r),o=t(4),s=i(o),l=t(5),h=function(e){return e<1e3?a["default"].format_decimal(e):e<1e4?(0,s["default"])(a["default"]._("%sK"),a["default"].format_decimal((0,l.roundToDecimal)(e/1e3,-2))):e<1e5?(0,s["default"])(a["default"]._("%sK"),a["default"].format_decimal((0,l.roundToDecimal)(e/1e3,-1))):e<999500?(0,s["default"])(a["default"]._("%sK"),a["default"].format_decimal((0,l.roundToDecimal)(e/1e3,0))):e<1e7?(0,s["default"])(a["default"]._("%sM"),a["default"].format_decimal((0,l.roundToDecimal)(e/1e6,-2))):e<1e8?(0,s["default"])(a["default"]._("%sM"),a["default"].format_decimal((0,l.roundToDecimal)(e/1e6,-1))):e<9995e5?(0,s["default"])(a["default"]._("%sM"),a["default"].format_decimal((0,l.roundToDecimal)(e/1e6,0))):e<1e10?(0,s["default"])(a["default"]._("%sB"),a["default"].format_decimal((0,l.roundToDecimal)(e/1e9,-2))):e<1e11?(0,s["default"])(a["default"]._("%sB"),a["default"].format_decimal((0,l.roundToDecimal)(e/1e9,-1))):(0,s["default"])(a["default"]._("%sB"),a["default"].format_decimal((0,l.roundToDecimal)(e/1e9,0)))};n.abbreviateNumber=function(e){return e<0?"-".concat(h(Math.abs(e))):h(e)},n.abbreviateByUnit=function(e,n,t){for(var i="###,###.",r="",o=0;o<t;o++)r+="0";return i+=r,0===e?"0":""===n?a["default"].format_decimal(e,i).toString():"K"===n?(0,s["default"])(a["default"]._("%sK"),a["default"].format_decimal(e/1e3,i)):"M"===n?(0,s["default"])(a["default"]._("%sM"),a["default"].format_decimal(e/1e6,i)):"B"===n?(0,s["default"])(a["default"]._("%sB"),a["default"].format_decimal(e/1e9,i)):"T"===n?(0,s["default"])(a["default"]._("%sT"),a["default"].format_decimal(e/1e12,i)):void 0},n.getSIUnit=function(e){return e>=1e12?"T":e>=1e9?"B":e>=1e6?"M":e>=1e3?"K":""},n.getSIPower=function(e){return e>=1e12?12:e>=1e9?9:e>=1e6?6:e>=1e3?3:0}},2:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),window.locale_name()in{ko_KR:!0,zh_CN:!0,zh_TW:!0}&&(window._i18n_locale.date_formats["short"]={pattern:"yy/MM/dd",format:"%(yy)s/%(MM)s/%(dd)s"},window._i18n_locale.date_formats.medium={pattern:"yyyy/MM/dd",format:"%(yyyy)s/%(MM)s/%(dd)s"},window._i18n_locale.time_formats["short"]={pattern:"H:mm",format:"%(H)s:%(mm)s"},window._i18n_locale.time_formats.medium={pattern:"H:mm:ss",format:"%(H)s:%(mm)s:%(ss)s"});var i=[[/^ccc MMM d$/,"M/d (ccc)"],[/^YYYY-MM/,"YYYY/MM"],[/MM-dd/,"MM/dd"]],r={ja_JP:i,ko_KR:i,zh_CN:i,zh_TW:i},a=[["MMM d","d MMM"]],o=window.format_date;window.format_date=function(e,n){n=n||"medium";var t,i,s=window.locale_name();if(n&&"string"==typeof n&&window.locale_uses_day_before_month())for(i=a,t=0;t<i.length;t++)n=n.replace(i[t][0],i[t][1]);if(n&&"string"==typeof n&&s in r)for(i=r[s],t=0;t<i.length;t++){var l=i[t];n=n.replace(l[0],l[1])}return o(e,n)},n["default"]={_:window.gettext,ungettext:window.ungettext,format_decimal:window.format_decimal,format_number:window.format_number,format_percent:window.format_percent,format_scientific:window.format_scientific,format_date:window.format_date,format_datetime:window.format_datetime,format_time:window.format_time,format_datetime_microseconds:window.format_datetime_microseconds,format_time_microseconds:window.format_time_microseconds,locale_uses_day_before_month:window.locale_uses_day_before_month,format_datetime_range:window.format_datetime_range,locale_name:window.locale_name,DateTime:window.DateTime,moment_install:window.moment_install,numeral_install:window.numeral_install,jQuery_ui_datepicker_install:window.jQuery_ui_datepicker_install},e.exports=n["default"]},4:function(e,n,t){"use strict";function i(){var e=/%%|%(\d+\$)?(\([^)]+\))?([-+#0 ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([scboxXuidfegEG])/g,n=arguments,t=0,i=n[t++],r=function(e,n,t,i){var r=e.length>=n?"":Array(1+n-e.length>>>0).join(t);return i?e+r:r+e},a=function(e,n,t,i,a){var o=i-e.length;return o>0&&(e=t||!a?r(e,i," ",t):e.slice(0,n.length)+r("",o,"0",!0)+e.slice(n.length)),e},o=function(e,n,t,i,o,s,l){var h=e>>>0;return t=t&&h&&{2:"0b",8:"0",16:"0x"}[n]||"",e=t+r(h.toString(n),s||0,"0",!1),a(e,t,i,o,l)},s=function(e,n,t,i,r){return null!=i&&(e=e.slice(0,i)),a(e,"",n,t,r)},l=function(e,i,l,h,d,c,p,u){if("%%"==e)return"%";for(var f=!1,m="",g=!1,x=!1,b=h.length,y=0;h&&y<b;y++)switch(h.charAt(y)){case" ":m=" ";break;case"+":m="+";break;case"-":f=!0;break;case"0":g=!0;break;case"#":x=!0}if(d=d?"*"==d?+n[t++]:"*"==d.charAt(0)?+n[d.slice(1,-1)]:+d:0,d<0&&(d=-d,f=!0),!isFinite(d))throw new Error("sprintf: (minimum-)width must be finite");if(p=p?"*"==p?+n[t++]:"*"==p.charAt(0)?+n[p.slice(1,-1)]:+p:"fFeE".indexOf(u)>-1?6:"d"==u?0:void 0,l){l=l.substr(1,l.length-2);var v=n[1][l]}else var v=i?n[i.slice(0,-1)]:n[t++];switch(u){case"s":return s(String(v),f,d,p,g);case"c":return s(String.fromCharCode(+v),f,d,p,g);case"b":return o(v,2,x,f,d,p,g);case"o":return o(v,8,x,f,d,p,g);case"x":return o(v,16,x,f,d,p,g);case"X":return o(v,16,x,f,d,p,g).toUpperCase();case"u":return o(v,10,x,f,d,p,g);case"i":case"d":var w=parseInt(+v),k=w<0?"-":m;return v=k+r(String(Math.abs(w)),p,"0",!1),a(v,k,f,d,g);case"e":case"E":case"f":case"F":case"g":case"G":var w=+v,k=w<0?"-":m,S=["toExponential","toFixed","toPrecision"]["efg".indexOf(u.toLowerCase())],T=["toString","toUpperCase"]["eEfFgG".indexOf(u)%2];return v=k+Math.abs(w)[S](p),a(v,k,f,d,g)[T]();default:return e}};return i.replace(e,l)}Object.defineProperty(n,"__esModule",{value:!0}),n["default"]=i,e.exports=n["default"]},5:function(e,n,t){"use strict";function i(e){return e&&e.__esModule?e:{"default":e}}Object.defineProperty(n,"__esModule",{value:!0}),n.roundToDecimal=n.valuesAreNumeric=n.isCommaSeparatedNumber=n.getDecimalPrecision=n.degreeToRadian=n.roundWithMinMax=n.roundWithMin=n.nearestPowerOfTen=n.absPowerTen=n.absLogBaseTen=n.logBaseTen=n.parseFloat=void 0;var r=t(0),a=i(r),o=/^( )*(0x|-0x)/,s=/(^[-+]?[0-9]*[.]?[0-9]*$)|(^[-+]?[0-9][.]?[0-9]*e[-+]?[0-9][0-9]*$)/i,l=/(^[-+]?([0]|([1-9][0-9]{0,2})|(([1-9][0-9]{0,2}[,])([0-9]{3}[,])*[0-9]{3}))(([.][0-9]+)?)$)/,h=function(e){return o.test(e)?parseInt(e,16):s.test(e)?parseFloat(e):NaN};n.parseFloat=h;var d=n.logBaseTen=function(e){var n=Math.log(e)/Math.LN10;return Math.round(1e4*n)/1e4},c=n.absLogBaseTen=function(e){if("number"!=typeof e&&(e=parseFloat(e)),(0,a["default"])(e).isNaN())return e;var n=e<0;n&&(e=-e),e<10&&(e+=(10-e)/10);var t=d(e);return n?-t:t},p=n.absPowerTen=function(e){if("number"!=typeof e&&(e=parseFloat(e)),(0,a["default"])(e).isNaN())return e;var n=e<0,t=void 0;return n&&(e=-e),t=Math.pow(10,e),t<10&&(t=10*(t-1)/9),t=n?-t:t,Math.round(1e3*t)/1e3},u=n.nearestPowerOfTen=function(e){if("number"!=typeof e)return NaN;var n=e<0;e=n?-e:e;var t=d(e),i=Math.pow(10,Math.floor(t));return n?-i:i},f=n.roundWithMin=function(e,n){return Math.max(Math.round(e),n)},m=n.roundWithMinMax=function(e,n,t){var i=Math.round(e);return i<n?n:i>t?t:i},g=n.degreeToRadian=function(e){return e*Math.PI/180},x=n.getDecimalPrecision=function(e,n){n=Math.min(n||1/0,20);for(var t=0;t<n&&e.toFixed(t)!==e.toString();)t+=1;return t},b=n.isCommaSeparatedNumber=function(e){return l.test(e)},y=n.valuesAreNumeric=function(e){var n=0,t=0;return(0,a["default"])(e).each(function(e){if((0,a["default"])(e).isArray()&&(e=e.length>0?e[0]:null),!(0,a["default"])(e).isNull()){t++;var i=!!h(e)||b(e);i&&n++}}),0!==t&&n>=t/2},v=n.roundToDecimal=function(e,n){return"undefined"==typeof n||0===+n?Math.round(e):(e=+e,n=+n,isNaN(e)||"number"!=typeof n||n%1!==0?NaN:(e=e.toString().split("e"),e=Math.round(+(e[0]+"e"+(e[1]?+e[1]-n:-n))),e=e.toString().split("e"),+(e[0]+"e"+(e[1]?+e[1]+n:n))))};n["default"]={parseFloat:h,logBaseTen:d,absLogBaseTen:c,absPowerTen:p,nearestPowerOfTen:u,roundWithMin:f,roundWithMinMax:m,degreeToRadian:g,getDecimalPrecision:x,valuesAreNumeric:y,roundToDecimal:v}}})}});
//# sourceMappingURL=1.1.js.map